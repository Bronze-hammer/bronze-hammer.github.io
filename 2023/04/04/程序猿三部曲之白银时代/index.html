<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>程序猿三部曲之白银时代 | 徐子辉的个人站点</title>
  <meta name="author" content="xuzh">
  
  <meta name="description" content="之前在某篇公众号文章中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。
曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="程序猿三部曲之白银时代">
  <meta property="og:site_name" content="徐子辉的个人站点">

  
    <meta property="og:image" content>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  <!-- <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5d4268fe3f695d6111d5659760d4d452";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
 -->

</head>
</html>
 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">徐子辉的个人站点</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-user"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> 程序猿三部曲之白银时代</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>之前在某篇<a href="https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ" target="_blank" rel="noopener">公众号文章</a>中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。</p>
<p>曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。</p>
<a id="more"></a>
<h1 id="hashmap和concurrenthashmap有什么区别">1
HashMap和ConcurrentHashMap有什么区别？</h1>
<p>HashMap是传统集合下的类，ConcurrentHashMap是并发集合下的类。除此之外，它们之间还有各种不同之处：</p>
<ul>
<li>HashMap本质上是非同步的，即HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</li>
<li>HashMap性能比较高，因为它是非同步的，任意数量的线程都可以同时访问它。而ConcurrentHashMap性能比较低，因为有时候线程需要在ConcurrentHashMap上等待请求。</li>
<li>当一个线程正在迭代HashMap时，如果有另外一个线程试图对这个HashMap的元素进行新增或者修改，我们将得到运行时异常
ConcurrentModificationException。然而，我们在迭代ConcurrentHashMap时执行任何修改都不会出现任何异常。</li>
<li>HashMap的key和value可以为null，ConcurrentHashMap不允许，否则会报运行时异常NullPointerException.</li>
<li>HashMap 是在 JDK 1.2 中引入的，而 ConcurrentHashMap 是由 SUN
Microsystem 在 JDK 1.5 中引入的</li>
</ul>
<h1 id="synchronized关键字">2 synchronized关键字</h1>
<p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p>
<ol type="1">
<li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li>
<li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li>
<li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。</li>
<li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li>
</ol>
<p>资料：<a href="https://www.cnblogs.com/weibanggang/p/9470718.html" target="_blank" rel="noopener">Java中Synchronized的用法（简单介绍）</a></p>
<h1 id="volatile关键字">3 volatile关键字</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p>
<h2 id="volatile原理">3.1 volatile原理</h2>
<p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p>
<p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p>
<img src="/2023/04/04/程序猿三部曲之白银时代/cpu_read_memory.png">
<p>当对非 volatile
变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的
CPU cache 中。</p>
<p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU
cache 这一步。</p>
<h2 id="当一个变量定义为volatile之后将具备两种特性">3.2
当一个变量定义为volatile之后，将具备两种特性</h2>
<ol type="1">
<li>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile
保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。</li>
<li>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load
addl $0x0,
(%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</li>
</ol>
<h2 id="volatile-性能">3.3 volatile 性能：</h2>
<p>volatile
的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p>
<p>资料：<a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p>
<h1 id="堆和栈的区别堆中存放的是什么栈中存放的是什么">4
堆和栈的区别，堆中存放的是什么，栈中存放的是什么？</h1>
<h2 id="堆空间">4.1 堆空间</h2>
<p>Java堆空间被Java运行时用来为对象和JRE类分配内存。每当我们创建一个对象时，它总是创建在Heap空间中。垃圾收集在堆内存上运行，以释放没有任何引用的对象所使用的内存。在堆空间中创建的任何对象都具有全局访问权，并且可以从应用程序的任何地方引用。</p>
<h2 id="栈内存">4.2 栈内存</h2>
<p>Java
Stack内存用于线程的执行。它们包含特定于方法的值，这些值存在时间很短，并引用从该方法引用的堆中其他对象。堆栈内存总是按照后进先出(LIFO)的顺序引用。每当调用一个方法时，就会在堆栈内存中为该方法创建一个新的块，用于保存本地原语值并引用该方法中的其他对象。方法一结束，该块就变为未使用的，并可用于下一个方法。与堆内存相比，堆栈内存大小要小得多。</p>
<h2 id="栈和堆申请空间后系统的响应">4.3 栈和堆申请空间后系统的响应</h2>
<ul>
<li>栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li>
<li>堆：操作系统有一个记录空间内存地址的链表，当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆节点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序。对于大多数操作系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的对节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入到链表中。</li>
</ul>
<h2 id="java-程序中的堆和栈内存">4.4 Java 程序中的堆和栈内存</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line">		<span class="keyword">int</span> i=<span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">		Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">		Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">		mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">	&#125; <span class="comment">// Line 9</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">		String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">	&#125; <span class="comment">// Line 8</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图显示了程序运行中堆空间和堆内存的引用，以及它们如何用于存储基元、对象和引用变量。</p>
<img src="/2023/04/04/程序猿三部曲之白银时代/Java-Heap-Stack-Memory.png">
<ol type="1">
<li>当我们运行该程序，系统会将所有运行时类加载到堆空间中。当在第一步执行main()方法时，Java
Runtime会创建栈内存以供main()方法线程使用。</li>
<li>Line 2定义局部变量，它会被创建并存储到main()方法的栈内存中。</li>
<li>Line 3
new了一个Object对象，Object对象会在堆空间创建，而栈内存保存对象的引用obj，同理，Line
4也是一样的过程。</li>
<li>当我们在Line
5调用foo()方法时，栈内存会在顶部创建一个块以供foo()方法使用。</li>
<li>由于Java是按值传递的，因此在Line
6处的栈内存块中创建了对Object的新引用。</li>
<li>在Line
7创建一个字符串，它进入堆空间中的字符串池，并在foo()堆空间中为它创建一个引用。</li>
<li>foo()方法在Line 8终止，此时分配给foo()的堆栈内存块变为空闲。</li>
<li>在Line
9，main()方法终止，为main()方法创建的堆栈内存被销毁。此外，程序在此行结束，因此Java
Runtime释放所有内存并结束程序的执行。</li>
</ol>
<h2 id="java堆空间和栈内存的区别">4.5 Java堆空间和栈内存的区别</h2>
<p>基于上面的解释，我们可以很容易的得出以下Heap和Stack内存的区别。</p>
<ol type="1">
<li>栈内存仅能被一个线程执行，堆空间可以被程序中所有部分使用；</li>
<li>每当创建一个对象时，它总是存储在堆空间中，栈内存包含对它的引用。栈内存只包含本地原始变量和堆空间中对象的引用变量；</li>
<li>存储在堆中的对象是全局可访问的，而堆栈内存不能被其他线程访问；</li>
<li>Memory management in stack is done in LIFO manner whereas it’s more
complex in Heap memory because it’s used globally. Heap memory is
divided into Young-Generation, Old-Generation etc, more details at <a href="https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">Java
Garbage Collection</a>；</li>
<li>堆栈内存是短暂的，而堆内存从应用程序执行开始到结束都存在；</li>
<li>我们可以使用JVM的<code>-Xms</code>和<code>-Xmx</code>选项来定义堆内存的启动内存和最大内存。我们可以使用<code>-Xss</code>来定义栈内存大小；</li>
<li>当堆栈内存已满时，Java 运行时会抛出
java.lang.StackOverFlowError，而如果堆内存已满，则会抛出
java.lang.OutOfMemoryError: Java Heap Space 错误;</li>
<li>与堆内存相比，堆栈内存非常小。由于内存分配
(LIFO)的简单性，与堆内存相比，堆栈内存非常快。</li>
</ol>
<p>资料：<a href="https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">Java
Heap Space vs Stack - Memory Allocation in Java</a></p>
<h1 id="字符串池">5 字符串池</h1>
<p>顾名思义，java中的String Pool就是一个存储在Java Heap
Memory中的Strings池。我们知道 String 是 java
中的一个特殊类，我们可以使用 new 运算符创建 String
对象，也可以在双引号中提供值。</p>
<h2 id="java中的字符串池">5.1 Java中的字符串池</h2>
<p>下面这张图很清楚的解释了String
Pool在java堆空间中是如何维护的，以及当我们使用不同的方式创建String时会发生什么</p>
<img src="/2023/04/04/程序猿三部曲之白银时代/String-Pool-Java.png">
<p>当我们使用双引号创建一个字符串时，它首先在字符串池中寻找具有相同值的字符串，如果找到则返回引用，否则在池中创建一个新的字符串，然后返回引用。但是使用new运算符，我们强制String类在堆空间中创建一个新的String对象。我们可以使用
intern() 方法将其放入池中，或者从字符串池中引用另一个具有相同值的 String
对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 == s2 :true</span><br><span class="line">s1 == s3 :false</span><br></pre></td></tr></table></figure>
<h2 id="在字符串池中创建了多少字符串对象">5.2
在字符串池中创建了多少字符串对象？</h2>
<p>有时候在java面试中，你会被问到一个关于String
pool的问题。例如，在下面的语句中创建了多少个字符串对象？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure>
<p>首先在堆空间创建一个“Cat”对象，在栈内存创建str，并指向堆空间的“Cat”对象;然后检查堆空间中的字符串池中查看是否存在“Cat”对象，如果存在，则将new出来的“Cat”对象与字符串池中的“Cat”对象联系起来。若不存在，则在字符串池中创建“Cat”对象，并将堆中的“Cat”对象与之关联起来。</p>
<p>资料：<a href="https://www.digitalocean.com/community/tutorials/what-is-java-string-pool" target="_blank" rel="noopener">What
is Java String Pool?</a></p>
<hr>
<p>未完，待续...</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/04/14/总结学习HashMap和HashTable/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/03/14/程序猿三部曲之青铜时代/" type="button" class="btn btn-default ">Next<i class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <script src="https://giscus.app/client.js" data-repo="xbronze/giscus" data-repo-id="R_kgDOJ4tM7g" data-category="Announcements" data-category-id="DIC_kwDOJ4tM7s4CXvDw" data-mapping="url" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async>
    </script>
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-04-04 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    </li><li><a href="/categories/代码人生/">代码人生<span>12</span></a></li>
  

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <a href="/tags/HashMap/">HashMap<span>2</span></a> <a href="/tags/ConcurrentHashMap/">ConcurrentHashMap<span>1</span></a> <a href="/tags/synchronized/">synchronized<span>1</span></a> <a href="/tags/volatile/">volatile<span>1</span></a>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#hashmap和concurrenthashmap有什么区别"><span class="toc-article-text">1
HashMap和ConcurrentHashMap有什么区别？</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#synchronized关键字"><span class="toc-article-text">2 synchronized关键字</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#volatile关键字"><span class="toc-article-text">3 volatile关键字</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#volatile原理"><span class="toc-article-text">3.1 volatile原理</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#当一个变量定义为volatile之后将具备两种特性"><span class="toc-article-text">3.2
当一个变量定义为volatile之后，将具备两种特性</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#volatile-性能"><span class="toc-article-text">3.3 volatile 性能：</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#堆和栈的区别堆中存放的是什么栈中存放的是什么"><span class="toc-article-text">4
堆和栈的区别，堆中存放的是什么，栈中存放的是什么？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#堆空间"><span class="toc-article-text">4.1 堆空间</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#栈内存"><span class="toc-article-text">4.2 栈内存</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#栈和堆申请空间后系统的响应"><span class="toc-article-text">4.3 栈和堆申请空间后系统的响应</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#java-程序中的堆和栈内存"><span class="toc-article-text">4.4 Java 程序中的堆和栈内存</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#java堆空间和栈内存的区别"><span class="toc-article-text">4.5 Java堆空间和栈内存的区别</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#字符串池"><span class="toc-article-text">5 字符串池</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#java中的字符串池"><span class="toc-article-text">5.1 Java中的字符串池</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#在字符串池中创建了多少字符串对象"><span class="toc-article-text">5.2
在字符串池中创建了多少字符串对象？</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2023 xuzh
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>,
     <br> Theme by <a href="https://github.com/blackshow/hexo-theme-freemind.386">Hexo-Theme-Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
