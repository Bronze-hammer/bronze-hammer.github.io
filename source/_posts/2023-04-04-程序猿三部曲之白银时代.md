---
title: 程序猿三部曲之白银时代
date: 2023-04-04 15:22:38
tags:
	- HashMap
	- ConcurrentHashMap
	- synchronized
	- volatile
categories:
	- 代码人生
toc: true
---


之前在某篇[公众号文章](https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ)中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。

曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。

<!-- more -->

# 1 HashMap和ConcurrentHashMap有什么区别？

HashMap是传统集合下的类，ConcurrentHashMap是并发集合下的类。除此之外，它们之间还有各种不同之处：

- HashMap本质上是非同步的，即HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。
- HashMap性能比较高，因为它是非同步的，任意数量的线程都可以同时访问它。而ConcurrentHashMap性能比较低，因为有时候线程需要在ConcurrentHashMap上等待请求。
- 当一个线程正在迭代HashMap时，如果有另外一个线程试图对这个HashMap的元素进行新增或者修改，我们将得到运行时异常 ConcurrentModificationException。然而，我们在迭代ConcurrentHashMap时执行任何修改都不会出现任何异常。
- HashMap的key和value可以为null，ConcurrentHashMap不允许，否则会报运行时异常NullPointerException.
- HashMap 是在 JDK 1.2 中引入的，而 ConcurrentHashMap 是由 SUN Microsystem 在 JDK 1.5 中引入的

# 2 synchronized关键字

synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：

1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
3. 修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。
4. 修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。

资料：[Java中Synchronized的用法（简单介绍）](https://www.cnblogs.com/weibanggang/p/9470718.html)


# 3 volatile关键字

```java
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        @Override
        public void run() {
            while(!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
```


NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。

## 3.1 volatile原理
Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

{% asset_img cpu_read_memory.png %}

当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。

而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

## 3.2 当一个变量定义为volatile之后，将具备两种特性

1. 保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。
2. 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

## 3.3 volatile 性能：

volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

资料：[Java中Volatile关键字详解](https://www.cnblogs.com/zhengbin/p/5654805.html)



---

未完，待续...