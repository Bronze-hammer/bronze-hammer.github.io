---
title: 程序猿三部曲之青铜时代
date: 2023-03-14 15:49:34
tags:
	- Ioc
	- AOP
	- 反射
	- 动态代理
categories:
	- 代码人生
---


之前在某篇[公众号文章](https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ)中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。

曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。

<!-- more -->


# 1 接口和抽象类的关系和区别

## 1.1 理解接口和抽象类

这个问题之前有了解过，也看过一些文章，但是好长时间不复习，也总是会忘记。因为工作中其实也不会很严谨的按照规则去使用接口和抽象类，总是按照controller、interface、mapper这样的通用格式，实现功能。借此机会，再次学习一下。

接口关心的是对象可以做什么，抽象类主要是描述对象是什么。定义一个狗狗的抽象类，这个类可以被藏獒继承、也可以被哈士奇、柯基继承，但是不能被人类继承。一个活动的接口，定义一个奔跑的方法，这个接口就不局限于藏獒和人类了，只要对象具有奔跑的能力，就可以实现这个接口，拥有奔跑的能力（方法）。所以在java中，类的单继承多实现就很好理解了。在应用场景中，抽象类用于同类事物，而接口多是可以横跨很多个类。


## 1.2 接口和抽象类的区别

1. 抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的，并且必须赋值，否则通不过编译。
3. 接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。
4. 接口里不能包含初始化块，但抽象类里完全可以包含初始化块。
5. 就是我们所说的单继承多实现了。

## 1.3 什么时候应该使用接口而不用抽象类

1. 需要实现多态
2. 要实现的方法(功能)不是当前类族的必要(属性).
3. 要为不同类族的多个类实现同样的方法(功能).

参考资料：[搞了这么多年终于知道接口和抽象类的应用场景了](https://cloud.tencent.com/developer/article/1677833)


# 2 反射机制和动态代理

## 2.1 反射机制

反射(Reflection)是Java程序开发语言的特征之一它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射机制，可以在运行时访问Java对象的属性，方法，构造方法等。

### 2.1.1 反射的应用场景

反射的主要应用场景有：

1. 开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。
2. 动态代理 - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。
3. 注解 - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。
4. 可扩展性功能 - 应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。

### 2.1.2 反射的缺点

1. 性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java 虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。
2. 破坏封装性 - 反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。
3. 内部曝光 - 由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。

## 2.2 动态代理

代理模式是为了提供额外或不同的操作，而插入的用来替代“实际”对象的对象，这些操作涉及到与“实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的策略。 

学习Spring的时候，我们知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，它利用的是反射机制，依赖注入就不用多说了，而对于Spring的核心AOP来说，使用了动态代理，其实底层也是反射。我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。

参考资料：
[深入理解Java反射和动态代理](https://zhuanlan.zhihu.com/p/60805342)
[深入理解Java反射+动态代理](https://www.cnblogs.com/aspirant/p/9036805.html)

# 3 项目中事务的使用

事务的四个特征：原子性、一致性、隔离性、持久性

## 3.1 事务传播属性

1. Propagation.REQUIRED:支持当前事务,如果当前没有事务,则新建一个事务,默认使用这种,也是最常见的.
2. Propagation.SUPPORTS:支持当前事务,如果没有事务,就以非事务的方式执行.
3. Propagation.MANDATORY:支持当前事务,如果没有事务,就抛出异常.
4. Propagation.REQUIRES_NEW:新建事务,如果当前存在事务,就把当前事务挂起.
5. Propagation.NOT_SUPPORTED:以非事务的方式执行操作,如果当前存在事务,就把当前事务挂起.
6. Propagation.NEVER:以非事务的方式执行,如果当前存在事务,则会抛出异常.
7. Propagation.NESTED:如果当前事务存在，则执行嵌套事务，否则执行类似REQUIRED的操作.

SpringBoot注解@Transactional实现事务

>一个事务内部，没有隔离的概念的。打个比方：在同一个事务里，先对一条记录执行更新操作，然后再执行查询操作，整个事务没有完全的执行完毕，那么在执行查询的时候，虽然事务还没结束，但是查询的仍然是最新的更新的值，如果是另外一个事务查询这条记录，因为第一个事务并没有完全结束，所以查询到的就是老值。


## 3.2 @Transactional事务不生效的场景

spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效。

1. private、final、static方法，事务不生效，入口方法必须是public,spring的AOP特性决定的，spring认为private自己用的方法应该自己控制，不应该用事务切进去  

2. Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚（至于为什么spring要这么设计：因为spring认为Checked的异常属于业务的，coder需要给出解决方案而不应该直接扔该框架）  

3. 同类调用不生效（service方法中调用本类中的另一个方法，事务没有生效）： 

4. 如果使用的是rollbakfor的默认，已检查的异常（所有派生自Error和RuntimeException的类,都是未检查异常.其余的是已检查异常， 比如nullPointException是未检查的，IllegalAccessException 是已检查的）不回滚,可设为rollbackFor={Exception.class}  

5. 最好不要把@Trasaction注解到接口上：在接口上使用 @Transactional 注解，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。  
 
6. 确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效 ）。
 
7. 确保你的业务和事务入口在同一个线程里，否则事务也是不生效的 。


参考资料： [《java开发事务篇】之一分钟搞懂事务、使用方式和特定场景》](https://juejin.cn/post/6844904186870497287)


# 4 Spring IoC和AOP

## 4.1 IoC 控制反转

IoC 是 Inversion of Control 的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。Spring 通过 IoC 容器来管理所有Java对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由 IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java 对象没有任何区别。

在传统的 Java 应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 new Object() 的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。

但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC 容器手里的，其大致步骤如下。

1. 开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java 对象进行定义，例如在 XML 配置文件中使用 \<bean\> 标签、在 Java 类上使用 @Component 注解等。
2. Spring 启动时，IoC 容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC 容器创建并管理的对象被称为 Spring Bean。
3. 当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过 ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 new Obejct() 的方式）创建。

*IoC 带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在 Spring 应用中，IoC 容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC 容器创建它所需要的对象（Bean）。*

这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给 IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。


> 依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004 年在对“控制反转”进行解释时提出的。Martin Fowler 认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。控制反转核心思想就是由 Spring负责对象的创建。在对象创建过程中，Spring会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。
> 
> 依赖注入本质上是 Spring Bean 属性注入的一种，只不过这个属性是一个对象属性而已。

参考资料：[Spring IoC（控制反转）](http://c.biancheng.net/spring/inversion-control.html)


# 5 在实际工作中怎样对SQL进行调优

## 5.1 防止索引失效

索引会提升数据的查询效率，但是会降低“增删改”的效率。尽管如此，索引还是很划算的，因为我们大多数的操作就是查询，查询对于程序的性能影响是很大的。索引分为单值索引、唯一索引、复合索引。


- 在MySQL中不建议使用left join，即使on过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差；
- 使用 `!=` 或者 `<>`会导致索引失效，进而会全表搜索，所以如果数据量大的话，谨慎使用；
- 类型不一致也将导致索引失效，比如age的类型是varchar类型，那么查询的时候如果where条件设置age = 12，那么索引就会失效，但是有一种情况不会使索引失效，如果age的类型是int，查询条件age传的是varchar类型的值，是可以走索引的，因为MySQL内部做了隐式类型转换。
- 索引列作为函数的入参，会导致索引失效；
- 如果索引对列进行了四则运算（\+，\-，\*，\/，\!)，都会使索引失效；
- OR导致索引失效，例如where user = 'zhangsan' or age = 11。但是也不是所有的OR都使索引失效，如果OR连接的是同一个字段，那么索引不会失效；
- 模糊查询导致索引失效；
- NOT IN、 NOT EXISTS这两种用法都不走索引，但是IN还是走索引的；
- IS NULL不走索引，IS NOT NULL走索引。

> 在设计字段时，如果字段没有要求没没有值的情况下一定要设置为NULL，那么建议设置为空字符串。

## 5.2 SELECT检查

- 尽量不使用`select *`，需要什么字段就取什么字段；
- SQL语句的SELECT后面使用自定义函数，那么SQL查询结果返回多少行，那么UDF函数就会被调用多少次，非常影响性能；
- 如果SELECT出现text类型的字段，就会消耗大量的网络和IO宽带，由于返回的内容过大，超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用。
- `gorup_concat`是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。
- 在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。

## 5.3 LIMIT

- 当查询我们知道只会有一条结果或者我们只需要一条结果的时候，加上limit 1可以增加性能，因为mysql数据库引擎会在找到一条数据后停止检索，而不是往后查找下一条符合条件的数据。
- 慎用LIMIT m,n分页查询，越往后面翻页，即m值越大的情况下SQL的耗时会越长。

