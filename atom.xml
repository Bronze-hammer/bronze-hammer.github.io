<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐子辉的个人站点</title>
  
  <subtitle>在总结中一步步提升自己，要善于总结，好记性不如烂笔头.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-04-23T08:57:24.306Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xuzh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot项目下实践设计模式之工厂模式</title>
    <link href="http://yoursite.com/2023/04/23/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%8B%E5%AE%9E%E8%B7%B5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/</id>
    <published>2023-04-23T08:50:50.000Z</published>
    <updated>2023-04-23T08:57:24.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例结构红框内的">示例结构（红框内的）</h2><p>工厂模式（Factory Pattern）是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><a id="more"></a><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423161023.png"><h2 id="接口">接口</h2><p><code>com.springcloud.business.service.ICarService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xbronze</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类">实现类</h2><p><code>com.springcloud.business.service.impl.BusServiceImpl</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"大巴车一般要求时速控制在每小时80公里"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>com.springcloud.business.service.impl.SuperCarServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超跑的车速轻松能达到每小时200公里"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个工厂注册类">一个工厂注册类</h2><p><code>com.springcloud.business.service.impl.CarServiceContent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 15:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceContent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, ICarService&gt; carServiceMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICarService <span class="title">getCarService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carServiceMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.carServiceMap.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>项目启动，系统会把<code>ICarService</code>的实现类都注入到<code>carServiceMap</code>，key值为实现类上@Service注解定义的value，如果没有显式的设置value，如示例上所示，那么默认value值为类名（首字母小写）。## Controller类VehicleController</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/vehicle"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IVehicleService vehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;type&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">vehicle</span><span class="params">(@PathVariable(<span class="string">"type"</span>)</span> String type)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vehicleService.choose(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口ivehicleservice">接口IVehicleService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVehicleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">choose</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类vehicleserviceimpl">实现类VehicleServiceImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.IVehicleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 15:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleServiceImpl</span> <span class="keyword">implements</span> <span class="title">IVehicleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CarServiceContent carServiceContent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">choose</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        ICarService carService = carServiceContent.getCarService(type);</span><br><span class="line">        <span class="keyword">return</span> carService.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164156.png"><p><br></p><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164134.png"><p><br></p><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164322.png"><p><br></p><hr><p>完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;示例结构红框内的&quot;&gt;示例结构（红框内的）&lt;/h2&gt;
&lt;p&gt;工厂模式（Factory Pattern）是 Java
中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;/p&gt;
&lt;p&gt;作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过
new
就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工程模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>单点登录解决方案</title>
    <link href="http://yoursite.com/2023/04/20/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2023/04/20/单点登录解决方案/</id>
    <published>2023-04-20T01:59:13.000Z</published>
    <updated>2023-04-20T11:12:27.167Z</updated>
    
    <content type="html"><![CDATA[<p>单点登录 (SSO)是一种身份验证过程，在该过程中，用户仅使用一组登录凭据即可访问多个应用程序或网站，这避免了用户分别登录不同应用程序需要输入不同验证信息的麻烦。用户凭据和其他识别信息由称为身份提供者(IdP)的集中式系统存储和管理。身份提供者是一个受信任的系统，可以提供对其他网站和应用程序的访问。基于单点登录(SSO)的身份验证系统通常用于员工需要访问其组织的多个应用程序的企业环境中。</p><a id="more"></a><h1 id="单点登录sso的好处">单点登录SSO的好处</h1><ol type="1"><li>由于 SSO允许用户使用他们自己的登录系统进行身份验证，因此它还允许管理员管理用户帐户并使员工能够在公司使用的多个应用程序中使用它。</li><li>SSO 允许管理员立即控制对所有应用程序的访问，而不是登录 100个不同的用户管理门户来更改用户权限。</li><li>重要的是，SSO还有助于提高安全性。由于只有一个系统保存所有员工信息，因此保护一个地方比保护数百个不同的帐户容易得多，后者可能成为可能的“泄漏”。</li></ol><h1 id="单点登录验证过程示例图">单点登录验证过程示例图</h1><img src="/2023/04/20/单点登录解决方案/sso-for-login.png"><p><br></p><h1 id="saml-2.0-oauth-2.0-openid-connect的对比">SAML 2.0、 OAuth 2.0、OpenID Connect的对比</h1><table><colgroup><col style="width: 25%"><col style="width: 23%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th></th><th>SAML</th><th>OAuth</th><th>OpenID Connect</th></tr></thead><tbody><tr class="odd"><td>Description</td><td>Open standard for authorization and authentication</td><td>Open standard for authorization</td><td>Open standard for authentication</td></tr><tr class="even"><td>Primary user case</td><td>SSO for enterprise applications</td><td>API authorization</td><td>SSO for consumer applications</td></tr><tr class="odd"><td>Data format</td><td>XML</td><td>JSON</td><td>JSON</td></tr></tbody></table><p><br></p><h1 id="saml-2.0-协议">SAML 2.0 协议</h1><p>SAML是唯一同时支持身份验证和授权的标准。SAML通过支持服务提供商和身份提供商端的数据签名和加密，为公司提供更多控制，以保持其SSO登录更安全。因此，如果需要，可以对整个过程的数据进行加密，并且攻击无法对其进行解密，除非他们已经可以访问服务和身份提供者的私钥。</p><img src="/2023/04/20/单点登录解决方案/saml.png"><p><br></p><p>该过程进行如下：</p><ol type="1"><li>用户向服务提供商请求启动 SSO。</li><li>服务提供商创建 base64编码的身份验证请求并将其发送给身份提供商。</li><li>身份提供者接收身份验证请求，对其进行验证，并请求用户进行身份验证（登录）。</li><li>身份提供者发送带有 base64 编码 SAML 响应的用户 XHTML 表单。</li><li>用户向服务提供商发送 SAML 响应。</li><li>服务提供商验证 SAML 响应并将用户重定向到目标资源。</li></ol><h1 id="实施单点登录">实施单点登录</h1><p>大多数情况下，身份验证请求是使用 HTTP-Redirect 或 HTTP-Post绑定发送的，因为数据负载很小。但是，由于 SAML 响应通常太大而无法放入url，因此通常的做法是使用 HTTP-Post 绑定来传输 SAML 响应数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单点登录 (SSO)
是一种身份验证过程，在该过程中，用户仅使用一组登录凭据即可访问多个应用程序或网站，这避免了用户分别登录不同应用程序需要输入不同验证信息的麻烦。用户凭据和其他识别信息由称为身份提供者(IdP)的集中式系统存储和管理。身份提供者是一个受信任的系统，可以提供对其他网站和应用程序的访问。基于单点登录
(SSO)
的身份验证系统通常用于员工需要访问其组织的多个应用程序的企业环境中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="SSO" scheme="http://yoursite.com/tags/SSO/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList去重方式总结</title>
    <link href="http://yoursite.com/2023/04/17/ArrayList%E5%8E%BB%E9%87%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2023/04/17/ArrayList去重方式总结/</id>
    <published>2023-04-17T11:37:05.000Z</published>
    <updated>2023-04-18T10:26:55.375Z</updated>
    
    <content type="html"><![CDATA[<p>我在日常工作中常用Stream方式去重，满足了工作上业务的需求即可，并没有深入了解和尝试其他方式的去重操作，这对于个人的成长是很有局限性的，遂借此机会整理ArrayList的去重方法。</p><a id="more"></a><h2 id="使用迭代器遍历去重">1.使用迭代器遍历去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to remove duplicates from an ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">removeDuplicates</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new ArrayList</span></span><br><span class="line">ArrayList&lt;T&gt; newList = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse through the first list</span></span><br><span class="line"><span class="keyword">for</span> (T element : list) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this element is not present in newList</span></span><br><span class="line"><span class="comment">// then add it</span></span><br><span class="line"><span class="keyword">if</span> (!newList.contains(element)) &#123;</span><br><span class="line"></span><br><span class="line">newList.add(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the new list</span></span><br><span class="line"><span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the ArrayList with duplicate values</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays</span><br><span class="line">.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove duplicates</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">newList = removeDuplicates(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 3, 10, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h2 id="使用linkedhashset">2.使用LinkedHashSet</h2><p>可以将ArrayList转换成不允许值重复的Set集合，因此LinkedHashSet是最好的选择，因为它不允许重复.</p><blockquote><p>HashSet也能实现同样的去重效果，但是HashSet与LinkedHashSet的不同之处在于，LinkedHashSet同时保留了插入顺序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to remove duplicates from an ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">removeDuplicates</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new LinkedHashSet</span></span><br><span class="line">Set&lt;T&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the elements to set</span></span><br><span class="line">set.addAll(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the list</span></span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the elements of set</span></span><br><span class="line"><span class="comment">// with no duplicates to the list</span></span><br><span class="line">list.addAll(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the list</span></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the ArrayList with duplicate values</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays</span><br><span class="line">.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove duplicates</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">newList = removeDuplicates(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 10, 3, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><blockquote><p>更简单的方法可以这样写 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(yourList);</span><br><span class="line">yourList.clear();</span><br><span class="line">yourList.addAll(set);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用java-8版本中的stream.distinct方法">3.使用Java8版本中的Stream.distinct()方法</h2><p>distinct()方法根据equals()方法返回的结果返回一个没有重复元素的新Stream，可用于进一步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program to remove duplicates from a List in Java 8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// input list with duplicates</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct a new list from the set constucted from elements</span></span><br><span class="line"><span class="comment">// of the original list</span></span><br><span class="line">List&lt;Integer&gt; newList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 10, 3, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在日常工作中常用Stream方式去重，满足了工作上业务的需求即可，并没有深入了解和尝试其他方式的去重操作，这对于个人的成长是很有局限性的，遂借此机会整理ArrayList的去重方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>总结学习HashMap和HashTable</title>
    <link href="http://yoursite.com/2023/04/14/%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0HashMap%E5%92%8CHashTable/"/>
    <id>http://yoursite.com/2023/04/14/总结学习HashMap和HashTable/</id>
    <published>2023-04-14T06:20:08.000Z</published>
    <updated>2023-04-17T11:21:34.105Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 和 Hashtable都用于以键和值的形式存储数据。两者都使用散列技术来存储唯一密钥。但是HashMap和Hashtable类之间也是有许多区别。</p><a id="more"></a><h2 id="hashmap是不同步的即非线程安全hashtable是同步的即线程安全">1.HashMap是不同步的，即非线程安全；Hashtable是同步的，即线程安全。</h2><p>HashMap部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="keyword">this</span>.getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="keyword">this</span>.removeNode(hash(key), key, (Object)<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? </span><br><span class="line">    <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>HashTable部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Hashtable.Entry e = tab[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Hashtable.Entry entry = tab[index]; entry != <span class="keyword">null</span>; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.hash == hash &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line">    Hashtable.Entry&lt;K, V&gt; e = tab[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Hashtable.Entry prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++<span class="keyword">this</span>.modCount;</span><br><span class="line">            --<span class="keyword">this</span>.count;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="hashmap可以通过collections.synchronizedmapmapk-v-m实现同步hashtable不能实现非同步">2.HashMap可以通过Collections.synchronizedMap(Map&lt;K,V&gt; m)实现同步；Hashtable不能实现非同步。</h2><blockquote><p>虽然HashMap不是线程安全的，但是我们可以通过<code>Collections.synchronizedMap(Map&lt;K, V&gt; m)</code>实现线程安全.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(m);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">//调用execute()方法创建线程</span></span><br><span class="line">            threadPool.execute(() -&gt; map.put(atomicInteger.incrementAndGet(), </span><br><span class="line">            (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>))</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadPool.awaitTermination(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap允许一个空键和多个空值hashtable不允许任何空键和空值">3.HashMap允许一个空键和多个空值；HashTable不允许任何空键和空值</h2><p>从HashTable的源码可以看到，如果key或value是null，会抛出<code>NullPointerException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the</span></span><br><span class="line"><span class="comment"> * value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      key     the hashtable key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      value   the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     the previous value of the specified key in this hashtable,</span></span><br><span class="line"><span class="comment"> *             or &lt;code&gt;null&lt;/code&gt; if it did not have one</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  NullPointerException  if the key or value is</span></span><br><span class="line"><span class="comment"> *               &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #get(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap是jdk-1.2中引入的新类.-hashtable是jdk-1.0中的类">4.HashMap是JDK1.2中引入的新类. Hashtable是JDK 1.0中的类</h2><h2 id="hashmap比hashtable更快.">5.HashMap比Hashtable更快.</h2><h2 id="hashmap由iterator实现遍历.-hashtable由enumerator和iterator实现遍历.">6.HashMap由Iterator实现遍历.Hashtable由Enumerator和Iterator实现遍历.</h2><h2 id="hashmap中的迭代器是快速失败机制.-hashtable是安全失败机制.">7.HashMap中的迭代器是快速失败机制.Hashtable是安全失败机制.</h2><p>HashMap不是线程安全的，在遍历HashMap的内容时，如果有其他线程修改了HashMap的内容，那么将抛出<code>ConcurrentModificationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modCount用于记录修改次数，对HashMap的修改都将增加这个值，在迭代器初始化过程中会将modCount传递给expectedModCount。在迭代中就是根据<code>modCount != expectedModCount</code>判断Map是否已被其他线程修改。</p><p>Hashtable是<a href="https://blog.csdn.net/striner/article/details/86375684" target="_blank" rel="noopener">fail-safe安全失败</a>机制</p><p>fail-safe:这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历。java.util.concurrent包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModification Exception。</p><p>缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h2 id="hashmap继承abstractmap类hashtable继承dictionary类.">8.HashMap继承AbstractMap类；Hashtable继承Dictionary类.</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap 和 Hashtable
都用于以键和值的形式存储数据。两者都使用散列技术来存储唯一密钥。但是HashMap和Hashtable
类之间也是有许多区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="Hashtable" scheme="http://yoursite.com/tags/Hashtable/"/>
    
  </entry>
  
  <entry>
    <title>程序猿三部曲之白银时代</title>
    <link href="http://yoursite.com/2023/04/04/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E7%99%BD%E9%93%B6%E6%97%B6%E4%BB%A3/"/>
    <id>http://yoursite.com/2023/04/04/程序猿三部曲之白银时代/</id>
    <published>2023-04-04T07:22:38.000Z</published>
    <updated>2023-04-17T01:50:44.979Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某篇<a href="https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ" target="_blank" rel="noopener">公众号文章</a>中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。</p><p>曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。</p><a id="more"></a><h1 id="hashmap和concurrenthashmap有什么区别">1HashMap和ConcurrentHashMap有什么区别？</h1><p>HashMap是传统集合下的类，ConcurrentHashMap是并发集合下的类。除此之外，它们之间还有各种不同之处：</p><ul><li>HashMap本质上是非同步的，即HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</li><li>HashMap性能比较高，因为它是非同步的，任意数量的线程都可以同时访问它。而ConcurrentHashMap性能比较低，因为有时候线程需要在ConcurrentHashMap上等待请求。</li><li>当一个线程正在迭代HashMap时，如果有另外一个线程试图对这个HashMap的元素进行新增或者修改，我们将得到运行时异常ConcurrentModificationException。然而，我们在迭代ConcurrentHashMap时执行任何修改都不会出现任何异常。</li><li>HashMap的key和value可以为null，ConcurrentHashMap不允许，否则会报运行时异常NullPointerException.</li><li>HashMap 是在 JDK 1.2 中引入的，而 ConcurrentHashMap 是由 SUNMicrosystem 在 JDK 1.5 中引入的</li></ul><h1 id="synchronized关键字">2 synchronized关键字</h1><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ol type="1"><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。</li><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li></ol><p>资料：<a href="https://www.cnblogs.com/weibanggang/p/9470718.html" target="_blank" rel="noopener">Java中Synchronized的用法（简单介绍）</a></p><h1 id="volatile关键字">3 volatile关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><h2 id="volatile原理">3.1 volatile原理</h2><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><img src="/2023/04/04/程序猿三部曲之白银时代/cpu_read_memory.png"><p>当对非 volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache 中。</p><p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPUcache 这一步。</p><h2 id="当一个变量定义为volatile之后将具备两种特性">3.2当一个变量定义为volatile之后，将具备两种特性</h2><ol type="1"><li>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。</li><li>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“loadaddl $0x0,(%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</li></ol><h2 id="volatile-性能">3.3 volatile 性能：</h2><p>volatile的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><p>资料：<a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><h1 id="堆和栈的区别堆中存放的是什么栈中存放的是什么">4堆和栈的区别，堆中存放的是什么，栈中存放的是什么？</h1><h2 id="堆空间">4.1 堆空间</h2><p>Java堆空间被Java运行时用来为对象和JRE类分配内存。每当我们创建一个对象时，它总是创建在Heap空间中。垃圾收集在堆内存上运行，以释放没有任何引用的对象所使用的内存。在堆空间中创建的任何对象都具有全局访问权，并且可以从应用程序的任何地方引用。</p><h2 id="栈内存">4.2 栈内存</h2><p>JavaStack内存用于线程的执行。它们包含特定于方法的值，这些值存在时间很短，并引用从该方法引用的堆中其他对象。堆栈内存总是按照后进先出(LIFO)的顺序引用。每当调用一个方法时，就会在堆栈内存中为该方法创建一个新的块，用于保存本地原语值并引用该方法中的其他对象。方法一结束，该块就变为未使用的，并可用于下一个方法。与堆内存相比，堆栈内存大小要小得多。</p><h2 id="栈和堆申请空间后系统的响应">4.3 栈和堆申请空间后系统的响应</h2><ul><li>栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：操作系统有一个记录空间内存地址的链表，当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆节点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序。对于大多数操作系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的对节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入到链表中。</li></ul><h2 id="java-程序中的堆和栈内存">4.4 Java 程序中的堆和栈内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">&#125; <span class="comment">// Line 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; <span class="comment">// Line 8</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图显示了程序运行中堆空间和堆内存的引用，以及它们如何用于存储基元、对象和引用变量。</p><img src="/2023/04/04/程序猿三部曲之白银时代/Java-Heap-Stack-Memory.png"><ol type="1"><li>当我们运行该程序，系统会将所有运行时类加载到堆空间中。当在第一步执行main()方法时，JavaRuntime会创建栈内存以供main()方法线程使用。</li><li>Line 2定义局部变量，它会被创建并存储到main()方法的栈内存中。</li><li>Line 3new了一个Object对象，Object对象会在堆空间创建，而栈内存保存对象的引用obj，同理，Line4也是一样的过程。</li><li>当我们在Line5调用foo()方法时，栈内存会在顶部创建一个块以供foo()方法使用。</li><li>由于Java是按值传递的，因此在Line6处的栈内存块中创建了对Object的新引用。</li><li>在Line7创建一个字符串，它进入堆空间中的字符串池，并在foo()堆空间中为它创建一个引用。</li><li>foo()方法在Line 8终止，此时分配给foo()的堆栈内存块变为空闲。</li><li>在Line9，main()方法终止，为main()方法创建的堆栈内存被销毁。此外，程序在此行结束，因此JavaRuntime释放所有内存并结束程序的执行。</li></ol><h2 id="java堆空间和栈内存的区别">4.5 Java堆空间和栈内存的区别</h2><p>基于上面的解释，我们可以很容易的得出以下Heap和Stack内存的区别。</p><ol type="1"><li>栈内存仅能被一个线程执行，堆空间可以被程序中所有部分使用；</li><li>每当创建一个对象时，它总是存储在堆空间中，栈内存包含对它的引用。栈内存只包含本地原始变量和堆空间中对象的引用变量；</li><li>存储在堆中的对象是全局可访问的，而堆栈内存不能被其他线程访问；</li><li>Memory management in stack is done in LIFO manner whereas it’s morecomplex in Heap memory because it’s used globally. Heap memory isdivided into Young-Generation, Old-Generation etc, more details at <a href="https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">JavaGarbage Collection</a>；</li><li>堆栈内存是短暂的，而堆内存从应用程序执行开始到结束都存在；</li><li>我们可以使用JVM的<code>-Xms</code>和<code>-Xmx</code>选项来定义堆内存的启动内存和最大内存。我们可以使用<code>-Xss</code>来定义栈内存大小；</li><li>当堆栈内存已满时，Java 运行时会抛出java.lang.StackOverFlowError，而如果堆内存已满，则会抛出java.lang.OutOfMemoryError: Java Heap Space 错误;</li><li>与堆内存相比，堆栈内存非常小。由于内存分配(LIFO)的简单性，与堆内存相比，堆栈内存非常快。</li></ol><p>资料：<a href="https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">JavaHeap Space vs Stack - Memory Allocation in Java</a></p><h1 id="字符串池">5 字符串池</h1><p>顾名思义，java中的String Pool就是一个存储在Java HeapMemory中的Strings池。我们知道 String 是 java中的一个特殊类，我们可以使用 new 运算符创建 String对象，也可以在双引号中提供值。</p><h2 id="java中的字符串池">5.1 Java中的字符串池</h2><p>下面这张图很清楚的解释了StringPool在java堆空间中是如何维护的，以及当我们使用不同的方式创建String时会发生什么</p><img src="/2023/04/04/程序猿三部曲之白银时代/String-Pool-Java.png"><p>当我们使用双引号创建一个字符串时，它首先在字符串池中寻找具有相同值的字符串，如果找到则返回引用，否则在池中创建一个新的字符串，然后返回引用。但是使用new运算符，我们强制String类在堆空间中创建一个新的String对象。我们可以使用intern() 方法将其放入池中，或者从字符串池中引用另一个具有相同值的 String对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 == s2 :true</span><br><span class="line">s1 == s3 :false</span><br></pre></td></tr></table></figure><h2 id="在字符串池中创建了多少字符串对象">5.2在字符串池中创建了多少字符串对象？</h2><p>有时候在java面试中，你会被问到一个关于Stringpool的问题。例如，在下面的语句中创建了多少个字符串对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>首先在堆空间创建一个“Cat”对象，在栈内存创建str，并指向堆空间的“Cat”对象;然后检查堆空间中的字符串池中查看是否存在“Cat”对象，如果存在，则将new出来的“Cat”对象与字符串池中的“Cat”对象联系起来。若不存在，则在字符串池中创建“Cat”对象，并将堆中的“Cat”对象与之关联起来。</p><p>资料：<a href="https://www.digitalocean.com/community/tutorials/what-is-java-string-pool" target="_blank" rel="noopener">Whatis Java String Pool?</a></p><hr><p>未完，待续...</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在某篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公众号文章&lt;/a&gt;中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。&lt;/p&gt;
&lt;p&gt;曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>程序猿三部曲之青铜时代</title>
    <link href="http://yoursite.com/2023/03/14/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9D%92%E9%93%9C%E6%97%B6%E4%BB%A3/"/>
    <id>http://yoursite.com/2023/03/14/程序猿三部曲之青铜时代/</id>
    <published>2023-03-14T07:49:34.000Z</published>
    <updated>2023-04-18T10:14:59.465Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某篇<a href="https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ" target="_blank" rel="noopener">公众号文章</a>中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。</p><p>曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。</p><a id="more"></a><h1 id="接口和抽象类的关系和区别">1 接口和抽象类的关系和区别</h1><h2 id="理解接口和抽象类">1.1 理解接口和抽象类</h2><p>这个问题之前有了解过，也看过一些文章，但是好长时间不复习，也总是会忘记。因为工作中其实也不会很严谨的按照规则去使用接口和抽象类，总是按照controller、interface、mapper这样的通用格式，实现功能。借此机会，再次学习一下。</p><p>接口关心的是对象可以做什么，抽象类主要是描述对象是什么。定义一个狗狗的抽象类，这个类可以被藏獒继承、也可以被哈士奇、柯基继承，但是不能被人类继承。一个活动的接口，定义一个奔跑的方法，这个接口就不局限于藏獒和人类了，只要对象具有奔跑的能力，就可以实现这个接口，拥有奔跑的能力（方法）。所以在java中，类的单继承多实现就很好理解了。在应用场景中，抽象类用于同类事物，而接口多是可以横跨很多个类。</p><h2 id="接口和抽象类的区别">1.2 接口和抽象类的区别</h2><ol type="1"><li>抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 publicstatic final 类型的，并且必须赋值，否则通不过编译。</li><li>接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li><li>接口里不能包含初始化块，但抽象类里完全可以包含初始化块。</li><li>就是我们所说的单继承多实现了。</li></ol><h2 id="什么时候应该使用接口而不用抽象类">1.3什么时候应该使用接口而不用抽象类</h2><ol type="1"><li>需要实现多态</li><li>要实现的方法(功能)不是当前类族的必要(属性).</li><li>要为不同类族的多个类实现同样的方法(功能).</li></ol><p>参考资料：<a href="https://cloud.tencent.com/developer/article/1677833" target="_blank" rel="noopener">搞了这么多年终于知道接口和抽象类的应用场景了</a></p><h1 id="反射机制和动态代理">2 反射机制和动态代理</h1><h2 id="反射机制">2.1 反射机制</h2><p>反射(Reflection)是Java程序开发语言的特征之一它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射机制，可以在运行时访问Java对象的属性，方法，构造方法等。</p><h3 id="反射的应用场景">2.1.1 反射的应用场景</h3><p>反射的主要应用场景有：</p><ol type="1"><li>开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li>动态代理 -在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li>注解 -注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li>可扩展性功能 -应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ol><h3 id="反射的缺点">2.1.2 反射的缺点</h3><ol type="1"><li>性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li>破坏封装性 -反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>内部曝光 -由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ol><h2 id="动态代理">2.2 动态代理</h2><p>代理模式是为了提供额外或不同的操作，而插入的用来替代“实际”对象的对象，这些操作涉及到与“实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的策略。</p><p>学习Spring的时候，我们知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，它利用的是反射机制，依赖注入就不用多说了，而对于Spring的核心AOP来说，使用了动态代理，其实底层也是反射。我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。</p><p>参考资料： <a href="https://zhuanlan.zhihu.com/p/60805342" target="_blank" rel="noopener">深入理解Java反射和动态代理</a><a href="https://www.cnblogs.com/aspirant/p/9036805.html" target="_blank" rel="noopener">深入理解Java反射+动态代理</a></p><h1 id="项目中事务的使用">3 项目中事务的使用</h1><p>事务的四个特征：原子性、一致性、隔离性、持久性</p><h2 id="事务传播属性">3.1 事务传播属性</h2><ol type="1"><li>Propagation.REQUIRED:支持当前事务,如果当前没有事务,则新建一个事务,默认使用这种,也是最常见的.</li><li>Propagation.SUPPORTS:支持当前事务,如果没有事务,就以非事务的方式执行.</li><li>Propagation.MANDATORY:支持当前事务,如果没有事务,就抛出异常.</li><li>Propagation.REQUIRES_NEW:新建事务,如果当前存在事务,就把当前事务挂起.</li><li>Propagation.NOT_SUPPORTED:以非事务的方式执行操作,如果当前存在事务,就把当前事务挂起.</li><li>Propagation.NEVER:以非事务的方式执行,如果当前存在事务,则会抛出异常.</li><li>Propagation.NESTED:如果当前事务存在，则执行嵌套事务，否则执行类似REQUIRED的操作.</li></ol><p>SpringBoot注解@Transactional实现事务</p><blockquote><p>一个事务内部，没有隔离的概念的。打个比方：在同一个事务里，先对一条记录执行更新操作，然后再执行查询操作，整个事务没有完全的执行完毕，那么在执行查询的时候，虽然事务还没结束，但是查询的仍然是最新的更新的值，如果是另外一个事务查询这条记录，因为第一个事务并没有完全结束，所以查询到的就是老值。</p></blockquote><h2 id="transactional事务不生效的场景">3.2 <span class="citation" data-cites="Transactional事务不生效的场景">@Transactional事务不生效的场景</span></h2><p>spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效。</p><ol type="1"><li><p>private、final、static方法，事务不生效，入口方法必须是public,spring的AOP特性决定的，spring认为private自己用的方法应该自己控制，不应该用事务切进去</p></li><li><p>Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚（至于为什么spring要这么设计：因为spring认为Checked的异常属于业务的，coder需要给出解决方案而不应该直接扔该框架）</p></li><li><p>同类调用不生效（service方法中调用本类中的另一个方法，事务没有生效）：</p></li><li><p>如果使用的是rollbakfor的默认，已检查的异常（所有派生自Error和RuntimeException的类,都是未检查异常.其余的是已检查异常，比如nullPointException是未检查的，IllegalAccessException是已检查的）不回滚,可设为rollbackFor={Exception.class}</p></li><li><p>最好不要把@Trasaction注解到接口上：在接口上使用 <span class="citation" data-cites="Transactional">@Transactional</span>注解，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</p></li><li><p>确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效）。</p></li><li><p>确保你的业务和事务入口在同一个线程里，否则事务也是不生效的。</p></li></ol><p>参考资料： <a href="https://juejin.cn/post/6844904186870497287" target="_blank" rel="noopener">《java开发事务篇】之一分钟搞懂事务、使用方式和特定场景》</a></p><h1 id="spring-ioc和aop">4 Spring IoC和AOP</h1><h2 id="ioc-控制反转">4.1 IoC 控制反转</h2><p>IoC 是 Inversion of Control的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。Spring通过 IoC容器来管理所有Java对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java对象没有任何区别。</p><p>在传统的 Java应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 newObject()的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。</p><p>但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC容器手里的，其大致步骤如下。</p><ol type="1"><li>开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java对象进行定义，例如在 XML 配置文件中使用 &lt;bean&gt; 标签、在 Java类上使用 <span class="citation" data-cites="Component">@Component</span>注解等。</li><li>Spring 启动时，IoC容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC容器创建并管理的对象被称为 Spring Bean。</li><li>当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 newObejct() 的方式）创建。</li></ol><p><em>IoC带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在Spring 应用中，IoC容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC容器创建它所需要的对象（Bean）。</em></p><p>这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。</p><blockquote><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004年在对“控制反转”进行解释时提出的。Martin Fowler认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。控制反转核心思想就是由Spring负责对象的创建。在对象创建过程中，Spring会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p><p>依赖注入本质上是 Spring Bean属性注入的一种，只不过这个属性是一个对象属性而已。</p></blockquote><p>参考资料：<a href="http://c.biancheng.net/spring/inversion-control.html" target="_blank" rel="noopener">SpringIoC（控制反转）</a></p><h2 id="aop-面向切面编程">4.2 AOP 面向切面编程</h2><p>AOP保证在不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。</p><h1 id="在实际工作中怎样对sql进行调优">5在实际工作中怎样对SQL进行调优</h1><h2 id="防止索引失效">5.1 防止索引失效</h2><p>索引会提升数据的查询效率，但是会降低“增删改”的效率。尽管如此，索引还是很划算的，因为我们大多数的操作就是查询，查询对于程序的性能影响是很大的。索引分为单值索引、唯一索引、复合索引。</p><ul><li>在MySQL中不建议使用leftjoin，即使on过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差；</li><li>使用 <code>!=</code> 或者<code>&lt;&gt;</code>会导致索引失效，进而会全表搜索，所以如果数据量大的话，谨慎使用；</li><li>类型不一致也将导致索引失效，比如age的类型是varchar类型，那么查询的时候如果where条件设置age=12，那么索引就会失效，但是有一种情况不会使索引失效，如果age的类型是int，查询条件age传的是varchar类型的值，是可以走索引的，因为MySQL内部做了隐式类型转换。</li><li>索引列作为函数的入参，会导致索引失效；</li><li>如果索引对列进行了四则运算（+，-，*，/，!)，都会使索引失效；</li><li>OR导致索引失效，例如where user = 'zhangsan' or age =11。但是也不是所有的OR都使索引失效，如果OR连接的是同一个字段，那么索引不会失效；</li><li>模糊查询导致索引失效；</li><li>NOT IN、 NOT EXISTS这两种用法都不走索引，但是IN还是走索引的；</li><li>IS NULL不走索引，IS NOT NULL走索引。</li></ul><blockquote><p>在设计字段时，如果字段没有要求‘没有值的情况下一定要设置为NULL’，那么建议设置为空字符串。</p></blockquote><h2 id="select检查">5.2 SELECT检查</h2><ul><li>尽量不使用<code>select *</code>，需要什么字段就取什么字段；</li><li>SQL语句的SELECT后面使用自定义函数，那么SQL查询结果返回多少行，那么UDF函数就会被调用多少次，非常影响性能；</li><li>如果SELECT出现text类型的字段，就会消耗大量的网络和IO宽带，由于返回的内容过大，超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用。</li><li><code>gorup_concat</code>是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。</li><li>在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。</li></ul><h2 id="limit">5.3 LIMIT</h2><ul><li>当查询我们知道只会有一条结果或者我们只需要一条结果的时候，加上limit1可以增加性能，因为mysql数据库引擎会在找到一条数据后停止检索，而不是往后查找下一条符合条件的数据。</li><li>慎用LIMITm,n分页查询，越往后面翻页，即m值越大的情况下SQL的耗时会越长。</li></ul><h1 id="redis是如何实现高可用的">6 Redis是如何实现高可用的？</h1><p>Redis实现高可用的手段主要有以下四种：</p><ol type="1"><li>数据持久化：保证了数据不丢失；</li><li>Redis主从同步：让Redis从单机变成了多机。它有两种模式：主从模式和从从模式，但当主节点出现问题时，需要人工手动恢复系统；</li><li>Redis哨兵模式：用来监控 Redis主从模式，并提供了自动容灾恢复的功能。</li><li>Redis集群：除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了Redis 的并发处理能力。</li></ol><h2 id="数据持久化">6.1 数据持久化</h2><p>数据持久化保证了系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；</p><p>在 Redis 4.0之前数据持久化方式有两种：<code>AOF</code>方式和<code>RDB</code>方式，在Redis 4.0 推出了<code>混合持久化</code>的功能。</p><ul><li><p>RDB（RedisDataBase，快照恢复）是将某一个时刻的内存数据，以二进制的方式写入磁盘。RDB默认的保存文件为dump.rdb，优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑，并且与AOF 相比，RDB 具备更快的重启恢复能力，但有数据丢失的风险。</p></li><li><p>AOF（Append-OnlyFile，只追加文件）是指将所有的操作命令，以文本的形式追加到文件中。AOF默认的保存文件为appendonly.aof，它的优点是存储频率更高，因此丢失数据的风险就越低，并且AOF并不是以二进制存储的，所以可读性更高。缺点是占用空间大，重启之后的数据恢复速度比较慢。</p></li><li><p>Redis 混合持久化的存储模式指的是 Redis 可以使用 RDB + AOF两种格式来进行数据持久化，开始的数据以 RDB的格式进行存储，因此只会占用少量的空间，之后的命令会以 AOF的方式进行数据追加，这样就可以减低数据丢失的风险，同时可以提高数据恢复的速度这样就可以做到扬长避短物尽其用了。</p></li></ul><p>可以使用<code>config get aof-use-rdb-preamble</code>的命令来查询Redis 混合持久化的功能是否开启</p><h2 id="redis主从同步">6.2 Redis主从同步</h2><p>主从同步是 Redis多机运行中最基础的功能，有一主节点和多个从节点，多个节点组成一个 Redis集群，在这个集群主节点用来进行数据的操作，其他从节点用于同步主节点的内容，并且提供给客户端进行数据查询。</p><p>Redis 主从同步分为：主从模式和从从模式。</p><ul><li>主从模式是一个主节点和多个一级从节点</li><li>从从模式是在主从模式的基础上，一级从节点下面还可以拥有更多的从节点</li></ul><p>使用主从模式就可以实现数据的读写分离，把写操作的请求分发到主节点上，把其他的读操作请求分发到从节点上，这样就减轻了Redis 主节点的运行压力，并且提高了 Redis的整体运行速度。不但如此使用主从模式还实现了 Redis的高可用，当主服务器宕机之后，可以很迅速的把从节点提升为主节点，为 Redis服务器的宕机恢复节省了宝贵的时间。并且主从复制还降低了数据丢失的风险，因为数据是完整拷贝在多台服务器上的，当一个服务器磁盘坏掉之后，可以从其他服务器拿到完整的备份数据。</p><h2 id="哨兵模式">6.3 哨兵模式</h2><p>Redis 主从同步有那么多的优点，但是有一个致命的缺点，就是当 Redis的主节点宕机之后，必须人工介入手动恢复，如果半夜突然发生主节点宕机的问题，此时如果等待人工去处理就会很慢，这个时候我们就需要用到Redis 的哨兵模式了。</p><p>Redis 哨兵模式就是用来监视 Redis 主从服务器的，当 Redis的主从服务器发生故障之后，Redis 哨兵提供了自动容灾修复的功能。</p><p>Redis哨兵模块存储在Redis应用根目录下的 src/redis-sentinel目录下，我们可以使用命令<code>./src/redis-sentinel sentinel.conf</code>来启动哨兵功能。</p><p>工作原理:</p><p>哨兵的工作原理是每个哨兵会以每秒钟 1次的频率，向已知的主服务器和从服务器，发送一个 PING命令。如果最后一次有效回复 PING命令的时间，超过了配置的最大下线时间（Down-After-Milliseconds）时，默认是30s，那么这个实例会被哨兵标记为主观下线。如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有哨兵节点，要以每秒1 次的频率确认主服务器是否进入了主观下线的状态。如果有足够数量（quorum配置值）的哨兵证实该主服务器为主观下线，那么这个主服务器被标记为客观下线。此时所有的哨兵会按照规则（协商）自动选出新的主节点服务器，并自动完成主服务器的自动切换功能，而整个过程都是无须人工干预的。</p><h2 id="redis-集群">6.4 Redis 集群</h2><p>Redis集群也就是 Redis Cluster，它是 Redis 3.0 版本推出的 Redis集群方案，有多个主节点同时每个主节点有多个从节点，将数据分布在不同的主服务器上，以此来降低系统对单主节点的依赖，并且可以大大提高Redis 服务的读写性能。Redis 集群除了拥有主从模式 +哨兵模式的所有功能之外，还提供了多个主从节点的集群功能，实现了真正意义上的分布式集群服务。</p><p>Redis 集群可以实现数据分片服务，也就是说在 Redis 集群中有 16384个槽位用来存储所有的数据，当我们有 N 个主节点时，可以把 16384个槽位平均分配到 N 台主服务器上。当有键值存储时，Redis 会使用 crc16算法进行 hash 得到一个整数值，然后用这个整数值对 16384进行取模来得到具体槽位，再把此键值存储在对应的服务器上，读取操作也是同样的道理，这样我们就实现了数据分片的功能。</p><p>参考资料：<a href="https://www.cnblogs.com/liaowenhui/p/14618144.html" target="_blank" rel="noopener">Redis是如何实现高可用的？</a></p><h1 id="利用jdk不依赖外部工具实现一个简单的缓存机制">7利用JDK，不依赖外部工具，实现一个简单的缓存机制</h1><h2 id="存储集合的选择">7.1 存储集合的选择</h2><p>实现本地缓存，存储容器肯定是 key/value 形式的数据结构，在 Java中，也就是我们常用的 Map 集合。Map 中有HashMap、Hashtable、ConcurrentHashMap几种供我们选择，如果不考虑高并发情况下数据安全问题，我们可以选择HashMap，如果考虑高并发情况下数据安全问题，我们可以选择Hashtable、ConcurrentHashMap 中的一种集合，但是我们优先选择ConcurrentHashMap，因为 ConcurrentHashMap 的性能比 Hashtable 要好。</p><h2 id="过期缓存处理">7.2 过期缓存处理</h2><p>因为缓存直接存储在内存中，如果我们不处理过期缓存，内存将被大量无效缓存占用，这不是我们想要的，所以我们需要清理这些失效的缓存。过期缓存处理可以参考Redis 的策略来实现，Redis 采用的是定期删除 + 懒惰淘汰策略。</p><h3 id="定期删除策略">7.2.1 定期删除策略</h3><p>定期删除策略是每隔一段时间检测已过期的缓存，并且降之删除。这个策略的优点是能够确保过期的缓存都会被删除。同时也存在着缺点，过期的缓存不一定能够及时的被删除，这跟我们设置的定时频率有关系，另一个缺点是如果缓存数据较多时，每次检测也会给cup 带来不小的压力。</p><h3 id="懒惰淘汰策略">7.2.2 懒惰淘汰策略</h3><p>懒惰淘汰策略是在使用缓存时，先判断缓存是否过期，如果过期将它删除，并且返回空。这个策略的优点是只有在查找的时候，才判断是否过期，对CUP影响较。同时这种策略有致命的缺点，当存入了大量的缓存，这些缓存都没有被使用并且已过期，都将成为无效缓存，这些无效的缓存将占用你大量的内存空间，最后导致服务器内存溢出。</p><p>我们简单的了解了一下 Redis的两种过期缓存处理策略，每种策略都存在自己的优缺点。所以我们在使用过程中，可以将两种策略组合起来，结合效果还是非常理想的。</p><h2 id="缓存淘汰策略">7.3 缓存淘汰策略</h2><p>缓存淘汰跟过期缓存处理要区别开来，缓存淘汰是指当我们的缓存个数达到我们指定的缓存个数时，毕竟我们的内存不是无限的。如果我们需要继续添加缓存的话，我们就需要在现有的缓存中根据某种策略淘汰一些缓存，给新添加的缓存腾出位置，下面一起来认识几种常用的缓存淘汰策略。</p><h3 id="先进先出策略">7.3.1 先进先出策略</h3><p>最先进入缓存的数据在缓存空间不够的情况下会被优先被清除掉，以腾出新的空间接受新的数据。该策略主要比较缓存元素的创建时间。在一些对数据实效性要求比较高的场景下，可考虑选择该类策略，优先保障最新数据可用。</p><h3 id="最少使用策略">7.3.2 最少使用策略</h3><p>无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略主要比较元素的hitCount（命中次数），在保证高频数据有效性场景下，可选择这类策略。</p><h3 id="最近最少使用策略">7.3.3 最近最少使用策略</h3><p>无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。该策略主要比较缓存最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p><h3 id="随机淘汰策略">7.3.4 随机淘汰策略</h3><p>无论是否过期，随机淘汰某个缓存，如果对缓存数据没有任何要求，可以考虑使用该策略。</p><h3 id="不淘汰策略">7.3.5 不淘汰策略</h3><p>当缓存达到指定值之后，不淘汰任何缓存，而是不能新增缓存，直到有缓存淘汰时，才能继续添加缓存。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/82074159" target="_blank" rel="noopener">实现 Java本地缓存，该从这几点开始</a></p><h1 id="exception和error的区别">8 Exception和Error的区别</h1><p>Exception和Error都继承了Throwable类。</p><p>Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理；Error是指在正常情况下，不大可能出现的情况，绝大部分的 Error都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态</p><img src="/2023/03/14/程序猿三部曲之青铜时代/ErrorVsException.png"><p>Exception 又分为cheked exception（检查异常） 和 uncheckedexception（不检查异常）。</p><p>checked exception 指的是在源代码里必须处理的异常。例如：</p><ul><li>IOException</li></ul><p>unchecked exception指的是不用在源代码里处理，为运行时异常。例如：</p><ul><li>NullPointerException</li><li>ClassCastException</li></ul><p>绝大数的Error会导致程序处于非正常状态。例如：</p><ul><li>NoClassDefFoundError</li><li>OutOfMemoryError</li><li>StackOverflowError</li></ul><p>参考资料： <a href="https://cloud.tencent.com/developer/article/1851847" target="_blank" rel="noopener">《谈谈你对Exception和 Error的理解》</a> <a href="https://cloud.tencent.com/developer/article/2177926" target="_blank" rel="noopener">《Exception和Error有什么区别吗》</a></p><h1 id="设计模式">9 设计模式</h1><p>23种经典设计模式，设计模式的具逻辑和实现，可移步<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>了解。</p><h2 id="创建型模式">9.1 创建型模式</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><h2 id="结构型模式">9.2 结构型模式</h2><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><h2 id="行为型模式">9.3 行为型模式</h2><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul><h2 id="j2ee-模式">9.4 J2EE 模式</h2><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p><ul><li>MVC 模式（MVC Pattern）</li><li>业务代表模式（Business Delegate Pattern）</li><li>组合实体模式（Composite Entity Pattern）</li><li>数据访问对象模式（Data Access Object Pattern）</li><li>前端控制器模式（Front Controller Pattern）</li><li>拦截过滤器模式（Intercepting Filter Pattern）</li><li>服务定位器模式（Service Locator Pattern）</li><li>传输对象模式（Transfer Object Pattern）</li></ul><h1 id="一个线程调用两次start方法会发生什么简单谈谈线程的几种状态">10一个线程调用两次start()方法会发生什么？简单谈谈线程的几种状态</h1><h2 id="调用两次start">10.1 调用两次start()</h2><p>Java的线程是不允许启动两次的，第二次调用必然会抛岀<code>IllegalThreadStateEXception</code>，这是一种运行时异常，多次调用start 被认为是编程错误。</p><h2 id="线程的生命周期线程状态">10.2 线程的生命周期（线程状态）</h2><ul><li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li><li>就绪（RUNNABLE），表示该线程已经在WM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它cpu片段，在就绪队列里面排队。</li><li>运行（Running）在其他一些分析中，会额外区分一种状态 RUNNING，但是从Java API的角度，并不能表示出来。</li><li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitorlock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li><li>等待（WAITING），表示正在等待其他线程釆取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。</li><li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> wait（<span class="keyword">long</span> timeout） <span class="keyword">throws</span> InterruptedException；</span><br></pre></td></tr></table></figure><ul><li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</li></ul><img src="/2023/03/14/程序猿三部曲之青铜时代/thread_status.png"><p>参考资料：<a href="https://cloud.tencent.com/developer/article/1625433" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1625433</a></p><h1 id="rocketmq">11 RocketMQ</h1><p>RocketMQ是一个纯Java、分布式队列模型的消息中间件，具有高可用、高可靠、高实时、低延迟的特点。</p><h2 id="消息中间件的通用功能">11.1 消息中间件的通用功能</h2><ol type="1"><li>业务解耦：这也是发布订阅的消息模型。生产者发送指令到MQ中，然后下游订阅这类指令的消费者会收到这个指令执行相应的逻辑，整个过程与具体业务无关，抽象成了一个发送指令，存储指令，消费指令的过程。</li><li>前端削峰：前端发起的请求在短时间内太多后端无法处理，可以堆积在MQ中，后端按照一定的顺序处理，秒杀系统就是这么实现的。</li></ol><h2 id="rocketmq的特点">11.2 RocketMQ的特点</h2><ol type="1"><li>亿级消息的堆积能力：单个队列中的百万级消息的累积容量。</li><li>高可用性</li><li>高可靠性</li><li>支持分布式事务消息</li><li>支持顺序消息：消息在Broker中是采用队列的FIFO模式存储的，也就是发送是顺序的，只要保证消费的顺序性即可。</li><li>支持消息过滤：建议采用消费者业务端的tag过滤。</li><li>支持定时消息和延迟消息</li></ol><h2 id="rocketmq消息模型">11.3 RocketMQ消息模型</h2><h3 id="message">Message</h3><p>就是要传输的消息，一个消息必须有一个主题，一条消息也可以有一个可选的Tag（标签）和额外的键值对，可以用来设置一个业务的key，便于开发中在broker服务端查找消息。</p><h3 id="topic">Topic</h3><p>主题，是消息的第一级类型，每条消息都有一个主题，就像信件邮寄的地址一样。主题就是我们具体的业务，比如一个电商系统可以有订单消息，商品消息，采购消息，交易消息等。Topic和生产者和消费者的关系非常松散，生产者和Topic可以是1对多，多对1或者多对多，消费者也是这样。</p><h3 id="tag">Tag</h3><p>标签，是消息的第二级类型，可以作为某一类业务下面的二级业务区分，它的主要用途是在消费端的消息过滤。比如采购消息分为采购创建消息，采购审核消息，采购推送消息，采购入库消息，采购作废消息等，这些消息是同一Topic和不同的Tag，当消费端只需要采购入库消息时就可以用Tag来实现过滤，不是采购入库消息的tag就不处理。</p><h3 id="group">Group</h3><p>组，可分为ProducerGroup生产者组合ConsumerGroup消费者组，一个组可以订阅多个Topic。一般来说，某一类相同业务的生产者和消费者放在一个组里。</p><h3 id="message-queue">Message Queue</h3><p>消息队列，一个Topic可以划分成多个消息队列。Topic只是个逻辑上的概念，消息队列是消息的物理管理单位，当发送消息的时候，Broker会轮询包含该Topic的所有消息队列，然后将消息发出去。有了消息队列，可以使得消息的存储可以分布式集群化，具有了水平的扩展能力。</p><h3 id="offset">offset</h3><p>是指消息队列中的offset，可以认为就是下标，消息队列可看做数组。offset是javalong，64位，理论上100年不会溢出，所以可以认为消息队列是一个长度无限的数据结构。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/521109575" target="_blank" rel="noopener">RocketMq面试题精选</a></p><h1 id="rocketmq和其他消息中间件的区别">12RocketMQ和其他消息中间件的区别</h1><img src="/2023/03/14/程序猿三部曲之青铜时代/diff_mq.png"><h1 id="序列化和反序列化">13 序列化和反序列化</h1><h2 id="什么是序列化和反序列化">13.1 什么是序列化和反序列化？</h2><p>序列化：就是将对象转化成字节序列的过程。</p><p>反序列化：就是将字节序列转化成对象的过程。</p><p>对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。</p><h2 id="为什么要序列化和反序列化">13.2 为什么要序列化和反序列化？</h2><ol type="1"><li>持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。</li><li>网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。</li></ol><h2 id="实现序列化和反序列化的方法">13.3 实现序列化和反序列化的方法</h2><p>Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。</p><ol type="1"><li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口。</li><li>实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化。</li></ol><h2 id="serialversionuid的作用">13.4 serialVersionUID的作用</h2><p>先讲述下序列化的过程：在进行序列化时，会把当前类的serialVersionUID写入到字节序列中（也会写入序列化的文件中），在反序列化时会将字节流中的serialVersionUID同本地对象中的serialVersionUID进行对比，一直的话进行反序列化，不一致则失败报错（报InvalidCastException异常）</p><p>serialVersionUID的生成有三种方式（private static final longserialVersionUID= XXXL ）：</p><ol type="1"><li>显式声明：默认的1L</li><li>显式声明：根据包名、类名、继承关系、非私有的方法和属性以及参数、返回值等诸多因素计算出的64位的hash值</li><li>隐式声明：未显式的声明serialVersionUID时java序列化机制会根据Class自动生成一个serialVersionUID（最好不要这样，因为如果Class发生变化，自动生成的serialVersionUID可能会随之发生变化，导致匹配不上）</li></ol><blockquote><p>序列化类增加属性时，最好不要修改serialVersionUID，避免反序列化失败</p></blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/316200445" target="_blank" rel="noopener">一文搞懂序列化与反序列化</a></p><h1 id="dubbo和springcloud核心组件feignribbinhystrix对比">14Dubbo和SpringCloud核心组件Feign、Ribbin、Hystrix对比</h1><h2 id="协议">14.1 协议</h2><p>Dubbo：支持多传输协议：Dubbo、Rmi、http，可灵活配置。</p><p>Feign：基于http传输协议，短连接，性能比Dubbo低。</p><h2 id="与springcloud集成">14.2 与SpringCloud集成</h2><p>Dubbo：在早期Dubbo是与Spring Cloud 集成有一些脱落,但是在Spring CloudAlibaba 出现后，spring-cloud-starter-dubbo 与Spring Cloud完美集成</p><p>Feign：Spring Cloud 最早支持的RPC框架，兼容性好</p><h2 id="负载均衡">14.3 负载均衡</h2><p>Dubbo内置了如下负载均衡算法，用户可直接配置使用：</p><table><colgroup><col style="width: 29%"><col style="width: 22%"><col style="width: 47%"></colgroup><thead><tr class="header"><th>算法</th><th>特性</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>RandomLandBalance</td><td>加权随机</td><td>默认算法，默认权重相同</td></tr><tr class="even"><td>RoundRobinLoadBalance</td><td>加权轮询</td><td>借鉴与Nginx的平滑加权轮询算法，默认权重相同</td></tr><tr class="odd"><td>LeastActiveLoadBalance</td><td>最少活跃优先+加权随机</td><td>背后是能者多劳的思想</td></tr><tr class="even"><td>ShortestResponseLoadBalance</td><td>最短响应优先+加权随机</td><td>更加关注响应速度</td></tr><tr class="odd"><td>ConsistentHashLoadBalance</td><td>一致性Hash</td><td>确定的入参，确定的提供者，适用于有状态的请求</td></tr></tbody></table><p>同时支持服务端负载均衡和客户端负载均衡配置，灵活度非常高</p><p>Fegin自身是没有负载均衡能力的，之前默认使用Ribbon作为负载均衡的组件，但是Netfix已经不再维护。新版本的SpringCloud已经将Ribbon替换成Spring Cloud LoadBalancer,Ribbon是客户端级别的负载均衡，不像dubbo支持客户端和服务端双向配置</p><h2 id="容错机制">14.4 容错机制</h2><h3 id="dubbo支持多种容错策略">Dubbo支持多种容错策略：</h3><ol type="1"><li>FailoverCluste：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过retries="2" 来设置重试次数(不含第一次)。默认容错机制</li><li>FailfastCluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>FailsafeCluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>ForkingCluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks="2" 来设置最大并行数。</li><li>BroadcastCluster：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ol><h3 id="feign">Feign</h3><p>Feign默认使用NetfixHystrix作为服务熔断的组件。Hystix提供了服务降级，服务熔断，依赖隔离，监控（HystrixDashboard）等功能。 目前 Hystrix已经处于维护（maintenance）状态，不再继续开发，这个消息是Netfix在2018年对外宣布的。HystrixGitHub页面上也说明了该项目目前处于维护模式</p><blockquote><p>在使用dubbo后续的熔断降级也还可以使用Alibaba Sentinel</p></blockquote><h2 id="迁移">14.5 迁移</h2><h3 id="dubbo">Dubbo</h3><p>dubbo为了提供对RestTemplate和OpenFeign客户端端的支持，在Dubbo SpringCloud提供了@DubboTransported注解，使客户端无需额外处理即可兼容RestTemplate和OpenFeign的调用，换而言之在不调整Feign 接口以及 RestTemplate URL 的前提下，可以实现无缝迁移比如在客户端使用OpenFeign调用duboo服务，只需要添加如下注解如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"order"</span>)</span><br><span class="line"><span class="meta">@DubboTransported</span>(protocol = <span class="string">"dubbo"</span>)</span><br></pre></td></tr></table></figure><p>使用RestTemplate或OpenFeign调用Dubbo服务会经历以下过程：</p><ol type="1"><li>根据服务名得到注册中心的Dubbo服务DubboMetadataService。</li><li>使用DubboMetadataService里提供的getServiceRestMetadata方法获取要使用的Dubbo服务和对应的Rest元数据。</li><li>基于Dubbo服务和Rest元数据构造GenericService。</li><li>服务调用过程中使用GenericService发起泛化调用。</li></ol><h3 id="feign-1">Feign</h3><p>没有提供对dubbo无缝迁移的支持</p><p>参考资料：<a href="https://juejin.cn/post/7042686801877663752" target="_blank" rel="noopener">SpringCloud RPC(Feign VS Dubbo)多维度对比选型</a></p><h1 id="线程的创建方式">15 线程的创建方式</h1><h2 id="继承thread类">15.1 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadObject().start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadObject</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"current thread name is :"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现runnable接口">15.2 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableObject());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableObject</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"current thread name is :"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现callable接口">15.3 实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行Callable方式，需要FutureTask实现，用于接收运算结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> CallableObject());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取线程执行完毕后的返回值</span></span><br><span class="line">            Integer sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"sum is :"</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Callable泛型定义返回值的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableObject</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Integer sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于线程池创建">15.4 基于线程池创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">//调用execute()方法创建线程</span></span><br><span class="line">            <span class="comment">//采用匿名内部类的方法，创建Runnable对象，并重写run()方法</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>未完，待续...</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在某篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公众号文章&lt;/a&gt;中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。&lt;/p&gt;
&lt;p&gt;曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Ioc和AOP" scheme="http://yoursite.com/tags/Ioc%E5%92%8CAOP/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="序列化" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList.retainAll()方法解析</title>
    <link href="http://yoursite.com/2023/03/09/ArrayList-retainAll-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2023/03/09/ArrayList-retainAll-方法解析/</id>
    <published>2023-03-09T05:57:09.000Z</published>
    <updated>2023-03-10T08:40:08.263Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中，用java.util.ArrayList.retainAll(Collection&lt;?&gt;)方法判断两个list集合是否有交集（两个list是否有相同的元素）。如果两个集合有相同元素，那么retainAll返回true。但是如果两个集合的元素完全相同，返回的结果却是false,而如果两个list集合的元素都不一样，retainAll却返回true。这是怎么回事呢？</p><a id="more"></a><p>先来看看<code>ArrayList.retainAll(Collection&lt;?&gt;)</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retains only the elements in this list that are contained in the</span></span><br><span class="line"><span class="comment"> * specified collection.  In other words, removes from this list all</span></span><br><span class="line"><span class="comment"> * of its elements that are not contained in the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be retained in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment"> *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment"> *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment"> *         or if the specified collection is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retainAll注释的第一句已经基本交代了方法的功能</p><blockquote><p>Retains only the elements in this list that are contained in thespecified collection. In other words, removes from this list all of itselements that are not contained in the specified collection.</p><p>仅保留此列表中包含在指定集合中的元素。换句话说，从此列表中删除未包含在指定集合中的所有元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line"><span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">elementData[w++] = elementData[r];</span><br></pre></td></tr></table></figure><p>遍历此列表 <code>elementData</code> 中的元素，判断是否与<code>c</code>集合有相同元素，把相同的元素覆盖在此列表的第一个地址上，以此类推。以<code>w</code>记录相同元素的个数。</p><p>回到刚开始的问题上，为什么两个集合的元素都一样，结果返回 false，两个集合元素都不一样，结果返回 true 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    modCount += size - w;</span><br><span class="line">    size = w;</span><br><span class="line">    modified = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个集合的元素完全一样，<code>w == size</code>，这样会跳过判断，直接返回modified 的初始值 false;如果两个集合的元素都不一样，<code>w != size</code>满足条件，modified被赋值为true，返回结果即为true。</p><p>所以单纯用ArrayList.retainAll()方法，根据返回值true/false,判断两个集合是否有相同元素，是不准确的。</p><p>可以使用另一个方法<code>java.util.Collections.disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code>，两个指定collection中没有相同的元素，则返回true。如果其中一个集合为null，则抛出NullPointerException。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the two specified collections have no</span></span><br><span class="line"><span class="comment"> * elements in common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Care must be exercised if this method is used on collections that</span></span><br><span class="line"><span class="comment"> * do not comply with the general contract for &#123;<span class="doctag">@code</span> Collection&#125;.</span></span><br><span class="line"><span class="comment"> * Implementations may elect to iterate over either collection and test</span></span><br><span class="line"><span class="comment"> * for containment in the other collection (or to perform any equivalent</span></span><br><span class="line"><span class="comment"> * computation).  If either collection uses a nonstandard equality test</span></span><br><span class="line"><span class="comment"> * (as does a &#123;<span class="doctag">@link</span> SortedSet&#125; whose ordering is not &lt;em&gt;compatible with</span></span><br><span class="line"><span class="comment"> * equals&lt;/em&gt;, or the key set of an &#123;<span class="doctag">@link</span> IdentityHashMap&#125;), both</span></span><br><span class="line"><span class="comment"> * collections must use the same nonstandard equality test, or the</span></span><br><span class="line"><span class="comment"> * result of this method is undefined.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Care must also be exercised when using collections that have</span></span><br><span class="line"><span class="comment"> * restrictions on the elements that they may contain. Collection</span></span><br><span class="line"><span class="comment"> * implementations are allowed to throw exceptions for any operation</span></span><br><span class="line"><span class="comment"> * involving elements they deem ineligible. For absolute safety the</span></span><br><span class="line"><span class="comment"> * specified collections should contain only elements which are</span></span><br><span class="line"><span class="comment"> * eligible elements for both collections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that it is permissible to pass the same collection in both</span></span><br><span class="line"><span class="comment"> * parameters, in which case the method will return &#123;<span class="doctag">@code</span> true&#125; if and</span></span><br><span class="line"><span class="comment"> * only if the collection is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c1 a collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c2 a collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the two specified collections have no</span></span><br><span class="line"><span class="comment"> * elements in common.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if either collection is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if one collection contains a &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * element and &#123;<span class="doctag">@code</span> null&#125; is not an eligible element for the other collection.</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if one collection contains an element that is</span></span><br><span class="line"><span class="comment"> * of a type which is ineligible for the other collection.</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The collection to be used for contains(). Preference is given to</span></span><br><span class="line">    <span class="comment">// the collection who's contains() has lower O() complexity.</span></span><br><span class="line">    Collection&lt;?&gt; contains = c2;</span><br><span class="line">    <span class="comment">// The collection to be iterated. If the collections' contains() impl</span></span><br><span class="line">    <span class="comment">// are of different O() complexity, the collection with slower</span></span><br><span class="line">    <span class="comment">// contains() will be used for iteration. For collections who's</span></span><br><span class="line">    <span class="comment">// contains() are of the same complexity then best performance is</span></span><br><span class="line">    <span class="comment">// achieved by iterating the smaller collection.</span></span><br><span class="line">    Collection&lt;?&gt; iterate = c1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Performance optimization cases. The heuristics:</span></span><br><span class="line">    <span class="comment">//   1. Generally iterate over c1.</span></span><br><span class="line">    <span class="comment">//   2. If c1 is a Set then iterate over c2.</span></span><br><span class="line">    <span class="comment">//   3. If either collection is empty then result is always true.</span></span><br><span class="line">    <span class="comment">//   4. Iterate over the smaller Collection.</span></span><br><span class="line">    <span class="keyword">if</span> (c1 <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">        <span class="comment">// Use c1 for contains as a Set's contains() is expected to perform</span></span><br><span class="line">        <span class="comment">// better than O(N/2)</span></span><br><span class="line">        iterate = c2;</span><br><span class="line">        contains = c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(c2 <span class="keyword">instanceof</span> Set)) &#123;</span><br><span class="line">        <span class="comment">// Both are mere Collections. Iterate over smaller collection.</span></span><br><span class="line">        <span class="comment">// Example: If c1 contains 3 elements and c2 contains 50 elements and</span></span><br><span class="line">        <span class="comment">// assuming contains() requires ceiling(N/2) comparisons then</span></span><br><span class="line">        <span class="comment">// checking for all c1 elements in c2 would require 75 comparisons</span></span><br><span class="line">        <span class="comment">// (3 * ceiling(50/2)) vs. checking all c2 elements in c1 requiring</span></span><br><span class="line">        <span class="comment">// 100 comparisons (50 * ceiling(3/2)).</span></span><br><span class="line">        <span class="keyword">int</span> c1size = c1.size();</span><br><span class="line">        <span class="keyword">int</span> c2size = c2.size();</span><br><span class="line">        <span class="keyword">if</span> (c1size == <span class="number">0</span> || c2size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// At least one collection is empty. Nothing will match.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c1size &gt; c2size) &#123;</span><br><span class="line">            iterate = c2;</span><br><span class="line">            contains = c1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object e : iterate) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains.contains(e)) &#123;</span><br><span class="line">           <span class="comment">// Found a common element. Collections are not disjoint.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No common elements were found.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中，用java.util.ArrayList.retainAll(Collection&amp;lt;?&amp;gt;)方法判断两个list集合是否有交集（两个list是否有相同的元素）。如果两个集合有相同元素，那么retainAll返回true。但是如果两个集合的元素完全相同，返回的结果却是false,而如果两个list集合的元素都不一样，retainAll却返回true。
这是怎么回事呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
      <category term="retainAll()" scheme="http://yoursite.com/tags/retainAll/"/>
    
  </entry>
  
  <entry>
    <title>浅析Field-injection-is-not-recommended</title>
    <link href="http://yoursite.com/2023/02/22/%E6%B5%85%E6%9E%90Field-injection-is-not-recommended/"/>
    <id>http://yoursite.com/2023/02/22/浅析Field-injection-is-not-recommended/</id>
    <published>2023-02-22T09:36:46.000Z</published>
    <updated>2023-02-27T03:32:43.642Z</updated>
    
    <content type="html"><![CDATA[<p>IDEA运行SpringBoot项目，遇到以下有关 <span class="citation" data-cites="Autowired">@Autowired</span> 注解的警告：Field injection isnot recommended .这篇文章浅析这个问题，为什么会有这样的提示？为什么字段注入的方式不推荐？</p><a id="more"></a><p>当前的 spring framework (5.0.3) 文档仅定义了两种主要的注入类型<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><blockquote><p>DI exists in two major variants: Constructor-based dependencyinjection and Setter-based dependency injection.</p></blockquote><p>基于构造函数的依赖注入:在基于构造函数的依赖注入中，类构造函数被注释@Autowired并包含可变数量的参数以及要注入的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于构造函数的注入的主要优点是您可以将注入的字段声明为final，因为它们将在类实例化期间启动。这对于所需的依赖项很方便。</p><p>基于Setter的依赖注入:在基于 setter 的依赖注入中，setter方法用@Autowired. 一旦使用无参数构造函数或无参数静态工厂方法实例化Bean，Spring 容器将调用这些 setter 方法以注入 Bean 的依赖项。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但实际上还有第三种，也是被广泛应用的</p><p>基于字段的依赖注入:在基于字段的依赖注入中，字段/属性用@Autowired.实例化类后，Spring 容器将设置这些字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorBasedInjection</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InjectedBean injectedBean;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是注入依赖项的最简洁的方法，因为它避免了添加样板代码，并且无需为类声明构造函数。代码看起来不错，简洁明了，但正如代码检查员已经提示我们的那样，这种方法有一些缺点。</p><p>那么为什么不推荐使用基于字段的依赖注入？</p><h2 id="基于字段的依赖注入缺点2">基于字段的依赖注入缺点<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h2><h3 id="不允许不可变字段声明">不允许不可变字段声明</h3><p>基于字段的依赖注入不适用于声明为 final/immutable的字段，因为这些字段必须在类实例化时实例化。声明不可变依赖项的唯一方法是使用基于构造函数的依赖项注入。</p><h3 id="违反了单一责任原则">违反了单一责任原则</h3><p>如您所知，在面向对象的计算机编程中，<a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">SOLID</a><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>首字母缩略词定义了五个设计原则，这些原则将使您的代码易于理解、灵活和可维护。SOLID中的S代表单一职责原则，这意味着一个类应该只负责软件应用程序功能的单个部分，并且它的所有服务都应该与该职责严格对齐。</p><p>使用基于字段的依赖注入，很容易在你的类中有很多依赖，一切看起来都很好。如果改为使用基于构造函数的依赖注入，随着更多的依赖项被添加到你的类中，构造函数变得越来越大。拥有一个包含十个以上参数的构造函数是一个明显的标志，表明该类有太多协作者，这可能是开始将类拆分为更小且更易于维护的部分的好时机。</p><blockquote><p>这里要说明：基于构造函数依赖注入，并不说能够解决类里面的过多依赖的问题。而是说能够直观的提示我们：这个类被注入了太多的依赖，你该停下来，优化并拆分你的业务逻辑了！</p></blockquote><p>因此，尽管字段注入并不直接导致打破单一责任原则，但它肯定有助于隐藏信号，否则这些信号会非常明显。</p><h3 id="与依赖注入容器紧密耦合">与依赖注入容器紧密耦合</h3><p>使用基于字段的注入的主要原因是避免getter和setter的样板代码或为您的类创建构造函数。最后，这意味着可以设置这些字段的唯一方法是通过Spring容器实例化类并使用反射注入它们，否则字段将保持为null 并且您的类将被破坏/无用。</p><p>依赖注入设计模式将类依赖的创建与类本身分开，将此责任转移到类注入器，允许程序设计松散耦合并遵循单一职责和依赖倒置原则（再次是SOLID）。因此，最终通过自动装配其字段实现的类解耦会因再次与类注入器（在本例中为Spring）耦合而丢失，从而使该类在 Spring 容器之外无用。</p><p>这意味着如果你想在应用程序容器之外使用你的类，例如用于单元测试，你必须使用Spring容器来实例化你的类，因为没有其他可能的方法（除了反射）来设置自动装配的字段。</p><h3 id="隐藏的依赖">隐藏的依赖</h3><p>使用依赖注入模式时，受影响的类应该使用公共接口清楚地公开这些依赖关系，方法是在构造函数中公开所需的依赖关系，或者使用方法（setter）公开可选的依赖关系。当使用基于字段的依赖注入时，该类本质上将这些依赖隐藏到外部世界。</p><h3 id="结论">结论</h3><p>我们已经看到应该尽可能避免基于字段的注入，因为它有许多缺点，无论它看起来多么优雅。推荐的方法是使用基于构造函数和基于设置器的依赖注入。对于必需的依赖项，建议使用基于构造函数的注入，以允许它们不可变并防止它们为空。对于可选的依赖项，建议使用基于Setter 的注入。</p><hr><p>补充 2023-02-27</p><ol type="1"><li>构造器依赖注入，如果要注入的属性太多，构造方法会很臃肿，可以在类上加<code>@RequiredArgsConstructor</code>注解，这个注解会把final修饰的（或者@NonNull注解的）属性构建默认的构造方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MovieFinder movieFinder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>从Spring Framework4.3开始，如果目标bean只定义了一个构造函数，则不再需要在这样的构造函数上使用@Autowired注释。但是，如果有几个可用的构造函数，至少必须用@Autowired注释其中一个，以便指示容器使用哪个构造函数<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</li></ol><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators" target="_blank" rel="noopener">《SpringFramework Documentation 1.4.1. Dependency Injection》</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://blog.marcnuri.com/field-injection-is-not-recommended#eases-single-responsibility-principle-violation" target="_blank" rel="noopener">《Fieldinjection is not recommended – Spring IOC》</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://en.wikipedia.org/wiki/SOLID" target="_blank" rel="noopener">《WikiSOLID》</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p><a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/spring-framework-reference/core.html#beans-autowired-annotation" target="_blank" rel="noopener">《CoreTechnology:1.9.2. Using <span class="citation" data-cites="Autowired">@Autowired</span>》</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;IDEA运行SpringBoot项目，遇到以下有关 &lt;span class=&quot;citation&quot; data-cites=&quot;Autowired&quot;&gt;@Autowired&lt;/span&gt; 注解的警告：Field injection is
not recommended .
这篇文章浅析这个问题，为什么会有这样的提示？为什么字段注入的方式不推荐？&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="field injection" scheme="http://yoursite.com/tags/field-injection/"/>
    
  </entry>
  
  <entry>
    <title>日常工作中Java.Stream流操作汇总</title>
    <link href="http://yoursite.com/2023/02/08/%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E4%B8%ADJava-Stream%E6%B5%81%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2023/02/08/日常工作中Java-Stream流操作汇总/</id>
    <published>2023-02-08T02:29:31.000Z</published>
    <updated>2023-03-24T02:43:27.639Z</updated>
    
    <content type="html"><![CDATA[<p>Java 8API添加了一个新的抽象称为流Stream，以一种声明的方式处理数据。Stream使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java集合运算和表达的高阶抽象。StreamAPI可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流，流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选，排序，聚合等。元素流在管道中经过中间操作（intermediateoperation）的处理，最后由最终操作(terminaloperation)得到前面处理的结果。</p><p>————《菜鸟教程》</p><p>本片文章记录了工作中常用的Stream流操作，方便之后回顾。</p><a id="more"></a><h2 id="对list集合取user中的一个元素形成新的list集合">1.对List<user>集合，取User中的一个元素，形成新的List<string>集合</string></user></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;User&gt; userList;</span></span><br><span class="line">List&lt;String&gt; userNameList = userList.stream.map(User::getUserName).collect(Collectors.toList);</span><br></pre></td></tr></table></figure><h2 id="去重">2.去重</h2><p>对集合 List<user> userList 内的对象去重（实体类User 使用Lombok插件的@Data 注解，自动覆写 equals 和 hashCode 方法） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;User&gt; userList;</span></span><br><span class="line">List&lt;User&gt; newUserList = userList.stream().distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></user></p><h2 id="过滤">3.过滤</h2><p>过滤集合 List&lt;SysOptionData&gt; optionDataList 对象label为"zhangsan" 的数据 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SysOptionData&gt; resultList = optionDataList.stream().filter(</span><br><span class="line">optionData -&gt; <span class="string">"zhangsan"</span>.equals(optionData.getOptionLabel())</span><br><span class="line">).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回过滤后的集合第一条数据</span></span><br><span class="line">List&lt;SysOptionData&gt; resultList = optionDataList.stream().filter(</span><br><span class="line">optionData -&gt; <span class="string">"zhangsan"</span>.equals(optionData.getOptionLabel())</span><br><span class="line">).findFirst();</span><br></pre></td></tr></table></figure></p><h2 id="list集合转string字符串">4.List集合转String字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;User&gt; 包含User实体的集合，只提取username拼成一个字符串，以“，”隔开</span></span><br><span class="line">String username = userList.stream().map(User::getUsername()).collect(Collectors.joining(<span class="string">","</span>));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// List&lt;String&gt; usernameList</span></span><br><span class="line">String username = usernameList.stream().collect(Collectors.joining(<span class="string">","</span>));</span><br></pre></td></tr></table></figure><h2 id="匹配两个list集合返回新的list集合">5.匹配两个List集合，返回新的List集合</h2><p>比如有两个集合，List&lt;User&gt;、 List&lt;Address&gt;</p><p>List&lt;User&gt; 集合的数据</p><table><thead><tr class="header"><th>name</th><th>age</th><th>address</th></tr></thead><tbody><tr class="odd"><td>zhangsan</td><td>15</td><td>null</td></tr><tr class="even"><td>tom</td><td>16</td><td>null</td></tr><tr class="odd"><td>jom</td><td>20</td><td>null</td></tr></tbody></table><p>List&lt;Address&gt; 集合的数据</p><table><thead><tr class="header"><th>name</th><th>address</th></tr></thead><tbody><tr class="odd"><td>zhangsan</td><td>China</td></tr><tr class="even"><td>tom</td><td>USA</td></tr><tr class="odd"><td>jary</td><td>Japan</td></tr></tbody></table><p>对比着两个集合，以List&lt;User&gt;为主体，按照name字段匹配List&lt;Address&gt;集合，把匹配到的Address对象的address字段的值设置到User对象的address字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userList.stream()</span><br><span class="line">.map(u -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> addrList.stream()</span><br><span class="line">.filter(a -&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> a.getName().equals(u.getName());</span><br><span class="line">&#125;).map(a -&gt; &#123;</span><br><span class="line">u.setAddress(a.getAddress());</span><br><span class="line"><span class="keyword">return</span> u;</span><br><span class="line">&#125;).collect(Collectors.toList());</span><br><span class="line">&#125;)</span><br><span class="line">.flatMap(List::stream)</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span> (User user : list) &#123;</span><br><span class="line">System.out.println(user.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User [name=zhangsan, age=15, address=China]</span><br><span class="line">User [name=tom, age=16, address=USA]</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，结果只会返回匹配到的数据</p></blockquote><h2 id="stream-map和flatmap的区别">6.Stream map和flatMap的区别</h2><h3 id="stream.map">6.1 stream.map</h3><p><em>Returns a stream consisting of the results of applying thegivenfunction to the elements of this stream.</em></p><p>返回一个流，由将给定函数应用于该流的元素的结果组成。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = Stream.of(<span class="string">"ZhangSan"</span>, <span class="string">"Tom"</span>).collect(Collectors.toList());</span><br><span class="line">nameList.stream().map(n -&gt; n + <span class="string">", welcome"</span>).forEach(e -&gt; System.out.println(e));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZhangSan, welcome</span><br><span class="line">Tom, welcome</span><br></pre></td></tr></table></figure><p>请注意另一种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = Stream.of(<span class="string">"ZhangSan"</span>, <span class="string">"Tom"</span>).collect(Collectors.toList());</span><br><span class="line">List&lt;String[]&gt; list = nameList.stream().map(n -&gt; n.split(<span class="string">""</span>)).collect(Collectors.toList());</span><br><span class="line"><span class="keyword">for</span> (String[] strings : list) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">System.out.print(strings[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z  h  a  n  g  S  a  n  </span><br><span class="line">T  o  m</span><br></pre></td></tr></table></figure><blockquote><p>map操作就是把一种操作运算，映射到一个序列的每一个元素上。以每个元素为一个单位，运算的结果也是相互独立的，所以返回的是List&lt;String[]&gt;，而不是List&lt;String&gt;</p></blockquote><h3 id="stream.flatmap">6.2 stream.flatMap</h3><p><em>Returns a stream consisting of the results of replacing eachelement ofthis stream with the contents of a mapped stream produced byapplyingthe provided mapping function to each element. Each mappedstream is closed after its contentshave been placed into this stream.(If a mapped stream is nullan empty stream is used, instead.)</em></p><p>返回一个流，由将提供的映射函数应用到每个元素所产生的映射流的内容替换此流中的每个元素的结果组成。每个映射的流在其内容被放入该流后将被关闭。(如果映射流为null，则使用空流。)</p><p><em>The flatMap() operation has the effect of applying aone-to-manytransformation to the elements of the stream, and thenflattening theresulting elements into a new stream.</em></p><p>flatMap()操作的效果是对流的元素应用一对多的转换，然后将产生的元素平铺成一个新的流。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; nameList = Stream.of(<span class="string">"ZhangSan"</span>, <span class="string">"Tom"</span>).collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; list = nameList.stream()</span><br><span class="line">.map(n -&gt; n.split(<span class="string">""</span>))</span><br><span class="line">.flatMap(e -&gt; Arrays.stream(e))</span><br><span class="line">.collect(Collectors.toList());</span><br><span class="line">System.out.println(list.toString());</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Z, h, a, n, g, S, a, n, T, o, m]</span><br></pre></td></tr></table></figure><h2 id="list集合转map">7.List集合转Map</h2><p>List&lt;User&gt; 集合，设置 User.name作为Map的key，User对象作为value，转换为Map集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, User&gt; userMap = userList.stream()</span><br><span class="line">.collect(Collectors.toMap(User::getName, Function.identity()));</span><br></pre></td></tr></table></figure><h2 id="针对list列表按照指定元素分组生成新的map集合">8.针对List列表，按照指定元素分组，生成新的Map集合</h2><p>例如对下面List列表的数据做分组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new User(&quot;zhangsan&quot;, 12, &quot;Guangzhou&quot;);</span><br><span class="line">new User(&quot;lisi&quot;, 13, &quot;Shenzhen&quot;);</span><br><span class="line">new User(&quot;tom&quot;, 12, &quot;Beijing&quot;);</span><br></pre></td></tr></table></figure><p>分组操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;User&gt;&gt; map = userList.stream().collect(Collectors.groupingBy(User::getAge));</span><br></pre></td></tr></table></figure><p>分组结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">12=[</span><br><span class="line">User [name=zhangsan, age=12, address=Guangzhou], </span><br><span class="line">User [name=tom, age=12, address=Beijing]</span><br><span class="line">], </span><br><span class="line">13=[</span><br><span class="line">User [name=lisi, age=13, address=Shenzhen]</span><br><span class="line">]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据指定元素去重">9.根据指定元素去重</h2><p>第1部分已经介绍了<code>distinct</code>去重方法，但是这种方法只能针对整个对象去重，如果想只根据对象中的某几个元素去重，可以通过下面的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User(name=zhangsan, sex=man, ages=1)</span><br><span class="line">User(name=zhangsan, sex=man, ages=2)</span><br><span class="line">User(name=lisi, sex=woman, ages=3)</span><br><span class="line">User(name=wanger, sex=man, ages=4)</span><br></pre></td></tr></table></figure><p>如果只根据name和sex去重</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().collect(</span><br><span class="line">    Collectors.collectingAndThen(</span><br><span class="line">        Collectors.toCollection(() -&gt; <span class="keyword">new</span> TreeSet&lt;&gt;(</span><br><span class="line">        Comparator.comparing(p -&gt; p.getName()+<span class="string">";"</span>+p.getSex()))</span><br><span class="line">        ) , ArrayList::<span class="keyword">new</span>)</span><br><span class="line">).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">User(name=lisi, sex=woman, ages=3)</span><br><span class="line">User(name=wanger, sex=man, ages=4)</span><br><span class="line">User(name=zhangsan, sex=man, ages=1)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 8
API添加了一个新的抽象称为流Stream，以一种声明的方式处理数据。Stream
使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java
集合运算和表达的高阶抽象。Stream
API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。这种风格将要处理的元素集合看作一种流，
流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选，
排序，聚合等。元素流在管道中经过中间操作（intermediate
operation）的处理，最后由最终操作(terminal
operation)得到前面处理的结果。&lt;/p&gt;
&lt;p&gt;————《菜鸟教程》&lt;/p&gt;
&lt;p&gt;本片文章记录了工作中常用的Stream流操作，方便之后回顾。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Stream" scheme="http://yoursite.com/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>处理SpringCloudConfig客户端启动无法读取到配置参数</title>
    <link href="http://yoursite.com/2023/02/01/%E5%A4%84%E7%90%86SpringCloudConfig%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%90%AF%E5%8A%A8%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E5%88%B0%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/2023/02/01/处理SpringCloudConfig客户端启动无法读取到配置参数/</id>
    <published>2023-02-01T09:42:28.000Z</published>
    <updated>2023-02-02T01:39:41.198Z</updated>
    
    <content type="html"><![CDATA[<p>自己部署了一个Spring Cloud微服务项目，实践Spring CloudConfig分布式配置组件，按照Spring Cloud Config 资料<a href="http://c.biancheng.net/springcloud/config.html" target="_blank" rel="noopener">Config：SpringCloud分布式配置组件</a> 先后创建了Eureka注册中心服务、 Spring CloudConfig Server服务、 Spring Cloud Config Client客户端，在最后启动 SpringClient Config Client 客户端时，客户端始终无法访问 ConfigServer服务，读取上传在Gitee上的配置文件的内容。</p><p>在Baidu、Google搜索了大量资料，问题是最终解决了，但是这其中的原因，还需要继续探讨。</p><a id="more"></a><p>Eureka注册中心和Spring Cloud ConfigServer的配置内容就不多讲，可参考<a href="http://c.biancheng.net/springcloud/eureka.html" target="_blank" rel="noopener">Eureka：SpringCloud服务注册与发现组件</a> 和<a href="http://c.biancheng.net/springcloud/config.html" target="_blank" rel="noopener">Config：SpringCloud分布式配置组件</a>，启动了 Config Server服务，并用浏览器访问，上传在Gitee上的参数文件的内容是可以正常获取到的</p><img src="/2023/02/01/处理SpringCloudConfig客户端启动无法读取到配置参数/微信截图_20230201175150.png"><p>我们重点说一下Spring Cloud Config Client的配置，yml文件配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 3355 #端口号</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: spring-cloud-config-client #服务名</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      label: master #分支名称</span><br><span class="line">      name: application  #配置文件名称，application-dev.yml 中的 config</span><br><span class="line">      profile: dev  #环境名  application-dev.yml 中的 dev</span><br><span class="line">      #这里不要忘记添加 http:// 否则无法读取</span><br><span class="line">      uri: http://localhost:3344 #Spring Cloud Config 服务端（配置中心）地址</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  client: #将客户端注册到 eureka 服务列表内</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://localhost:9900/eureka</span><br></pre></td></tr></table></figure><p>新增Controller类，用于测试配置文件内容的读取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/config/client&quot;)</span><br><span class="line">public class ConfigClientController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">    private String serverPort;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.info&#125;&quot;)</span><br><span class="line">    private String configInfo;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;config.version&#125;&quot;)</span><br><span class="line">    private String configVersion;</span><br><span class="line"></span><br><span class="line">    @GetMapping(value = &quot;/getConfig&quot;)</span><br><span class="line">    public String getConfig() &#123;</span><br><span class="line">        return &quot;info：&quot; + configInfo + &quot;&lt;br/&gt;version：&quot; </span><br><span class="line">        + configVersion + &quot;&lt;br/&gt;port：&quot; + serverPort;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Cloud Config Client客户端在启动的时候控制台报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Could not resolve placeholder &apos;config.info&apos; in value &quot;$&#123;config.info&#125;&quot;</span><br><span class="line">at org.springframework.util.PropertyPlaceholderHelper.parseStringValue(PropertyPlaceholderHelper.java:180) ~[spring-core-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.util.PropertyPlaceholderHelper.replacePlaceholders(PropertyPlaceholderHelper.java:126) ~[spring-core-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.core.env.AbstractPropertyResolver.doResolvePlaceholders(AbstractPropertyResolver.java:239) ~[spring-core-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.core.env.AbstractPropertyResolver.resolveRequiredPlaceholders(AbstractPropertyResolver.java:210) ~[spring-core-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.context.support.PropertySourcesPlaceholderConfigurer.lambda$processProperties$0(PropertySourcesPlaceholderConfigurer.java:191) ~[spring-context-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.resolveEmbeddedValue(AbstractBeanFactory.java:936) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1332) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1311) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:656) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:639) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:119) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:399) ~[spring-beans-5.3.23.jar:5.3.23]</span><br><span class="line">... 16 common frames omitted</span><br><span class="line"></span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:54601&apos;, transport: &apos;socket&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>遂检查配置文件，对照资料教程看是不是自己写错了。在检查 Config Client模块的配置文件时发现，资料上创建的配置文件名称是<code>bootstrap.yml</code> 而非 <code>application.yml</code></p><p>遂把配置文件名改为 bootstrap.yml，重新启动，发现没有报之前的错误了。但是服务也没有正常运行起来，而是直接停止了，控制台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2023-02-01 20:42:52.002  INFO 15096 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30</span><br><span class="line">2023-02-01 20:42:52.005  INFO 15096 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-02-01 20:42:52.012  INFO 15096 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1675255372011 with initial instances count: 2</span><br><span class="line">2023-02-01 20:42:52.015  INFO 15096 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application SPRING-CLOUD-CONFIG-CLIENT with eureka with status UP</span><br><span class="line">2023-02-01 20:42:52.016  INFO 15096 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1675255372016, current=UP, previous=STARTING]</span><br><span class="line">2023-02-01 20:42:52.018  INFO 15096 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355: registering service...</span><br><span class="line">2023-02-01 20:42:52.033  INFO 15096 --- [           main] c.s.c.ConfigClientApplication            : Started ConfigClientApplication in 10.224 seconds (JVM running for 10.92)</span><br><span class="line">2023-02-01 20:42:52.040  INFO 15096 --- [ionShutdownHook] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application SPRING-CLOUD-CONFIG-CLIENT with eureka with status DOWN</span><br><span class="line">2023-02-01 20:42:52.040  INFO 15096 --- [ionShutdownHook] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1675255372040, current=DOWN, previous=UP]</span><br><span class="line">2023-02-01 20:42:52.042  INFO 15096 --- [ionShutdownHook] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...</span><br><span class="line">2023-02-01 20:42:52.076  INFO 15096 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355 - registration status: 204</span><br><span class="line">2023-02-01 20:42:52.077  INFO 15096 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355: registering service...</span><br><span class="line">2023-02-01 20:42:52.080  INFO 15096 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355 - registration status: 204</span><br><span class="line">2023-02-01 20:42:52.081  INFO 15096 --- [ionShutdownHook] com.netflix.discovery.DiscoveryClient    : Unregistering ...</span><br><span class="line">2023-02-01 20:42:52.085  INFO 15096 --- [ionShutdownHook] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355 - deregister  status: 200</span><br><span class="line">2023-02-01 20:42:52.091  INFO 15096 --- [ionShutdownHook] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient</span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:58233&apos;, transport: &apos;socket&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>其中有一句<code>Registering application SPRING-CLOUD-CONFIG-CLIENT with eureka with status UP</code>，</p><p>查询资料，在这篇文章<a href="https://blog.csdn.net/m0_57545353/article/details/125411539" target="_blank" rel="noopener">SpringCloud中Client向Eureka注册中心注册服务成功后不久就Unregistering（Unregisteringapplication 服务名 with eureka with）</a>中有提出解决办法</p><blockquote><p>虽然 Config Client子模块依赖的父模块中，pom文件已经引入了spring-boot-web依赖，但是依旧要在 Config Client 子模块的pom文件上加上 spring-boot-web依赖 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &lt;dependency&gt;</span><br><span class="line">&gt;   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&gt;   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&gt; &lt;/dependency&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><p>再次启动，服务启动成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">23-02-01 20:51:37.092  INFO 16848 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-02-01 20:51:37.098  INFO 16848 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1675255897097 with initial instances count: 1</span><br><span class="line">2023-02-01 20:51:37.100  INFO 16848 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application SPRING-CLOUD-CONFIG-CLIENT with eureka with status UP</span><br><span class="line">2023-02-01 20:51:37.100  INFO 16848 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw local status change event StatusChangeEvent [timestamp=1675255897100, current=UP, previous=STARTING]</span><br><span class="line">2023-02-01 20:51:37.103  INFO 16848 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355: registering service...</span><br><span class="line">2023-02-01 20:51:37.138  INFO 16848 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 3355 (http) with context path &apos;&apos;</span><br><span class="line">2023-02-01 20:51:37.139  INFO 16848 --- [           main] .s.c.n.e.s.EurekaAutoServiceRegistration : Updating port to 3355</span><br><span class="line">2023-02-01 20:51:37.164  INFO 16848 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_SPRING-CLOUD-CONFIG-CLIENT/DESKTOP-A5PHDVG:spring-cloud-config-client:3355 - registration status: 204</span><br><span class="line">2023-02-01 20:51:38.241  INFO 16848 --- [           main] c.s.c.ConfigClientApplication            : Started ConfigClientApplication in 12.417 seconds (JVM running for 13.157)</span><br></pre></td></tr></table></figure><p>Eureka注册中心</p><img src="/2023/02/01/处理SpringCloudConfig客户端启动无法读取到配置参数/微信截图_20230201205231.png"><p>浏览器调用接口</p><img src="/2023/02/01/处理SpringCloudConfig客户端启动无法读取到配置参数/微信截图_20230201205330.png"><p>那么，为什么Spring Cloud Config Client 的配置文件为什么要用bootstrap.yml， 而不是 application ？ 这里有一篇文章有说明<a href="https://www.cnblogs.com/frankcui/p/15256664.html" target="_blank" rel="noopener">SpringCloudConfig - client连接server的设置写在application.yml,导致属性无法解析</a></p><p>Bootstrap.yml (bootstrap.properties) 是在application.yml(application.properties)之前加载的。它通常用于“使用SpringCloud ConfigServer时，应在bootstrap.yml中指定spring.application.name和spring.cloud.config.server.git.uri”以及一些加密/解密信息。</p><p>SpringCloud会创建一个<code>Bootstrap Context</code>（由bootstrap.yml加载），作为Spring应用的<code>Application Context</code>（由application.yml加载）的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。<code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。</p><p>例如，当使用SpringCloudConfig时，通常从服务器加载“真正的”配置数据。为了获取URL（和其他连接配置，如密码等），您需要一个较早的或“bootstrap”配置。因此，您将配置服务器属性放在bootstrap.yml中，该属性用于加载实际配置数据（通常覆盖application.yml[如果存在]中的内容）。</p><hr><p>补充：</p><p>在刚开始启动Spring Cloud Config Client 时，控制台提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Description:</span><br><span class="line"></span><br><span class="line">No spring.config.import property has been defined</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Add a spring.config.import=configserver: property to your configuration.</span><br><span class="line">If configuration is not required add spring.config.import=optional:configserver: instead.</span><br><span class="line">To disable this check, set spring.cloud.config.enabled=false or </span><br><span class="line">spring.cloud.config.import-check.enabled=false.</span><br><span class="line"></span><br><span class="line">Disconnected from the target VM, address: &apos;127.0.0.1:58966&apos;, transport: &apos;socket&apos;</span><br><span class="line"></span><br><span class="line">Process finished with exit code 1</span><br></pre></td></tr></table></figure><p>stackoverflow上有篇文章<a href="https://stackoverflow.com/questions/67507452/no-spring-config-import-property-has-been-defined" target="_blank" rel="noopener">Nospring.config.import property has beendefined</a>中给出解决办法，在pom文件中加上依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己部署了一个Spring Cloud微服务项目，实践Spring Cloud
Config分布式配置组件，按照Spring Cloud Config 资料&lt;a href=&quot;http://c.biancheng.net/springcloud/config.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Config：Spring
Cloud分布式配置组件&lt;/a&gt; 先后创建了Eureka注册中心服务、 Spring Cloud
Config Server服务、 Spring Cloud Config Client客户端，在最后启动 Spring
Client Config Client 客户端时，客户端始终无法访问 Config
Server服务，读取上传在Gitee上的配置文件的内容。&lt;/p&gt;
&lt;p&gt;在Baidu、
Google搜索了大量资料，问题是最终解决了，但是这其中的原因，还需要继续探讨。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Spring Cloud Config" scheme="http://yoursite.com/tags/Spring-Cloud-Config/"/>
    
  </entry>
  
  <entry>
    <title>Arrays.asList()生成的对象不能执行add()的操作</title>
    <link href="http://yoursite.com/2023/01/12/Arrays-asList-%E7%94%9F%E6%88%90%E7%9A%84%E5%AF%B9%E8%B1%A1%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8Cadd-%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2023/01/12/Arrays-asList-生成的对象不能执行add-的操作/</id>
    <published>2023-01-12T08:20:11.000Z</published>
    <updated>2023-01-13T01:43:04.478Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目上，有使用 Arrays.asList()创建一个List集合，并在后续的操作中使用之前创建的List集合继续 add()添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">list.add(<span class="string">"five"</span>);</span><br></pre></td></tr></table></figure><p>运行项目却在 list.add("five"); 处报错： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:148)</span><br><span class="line">at java.util.AbstractList.add(AbstractList.java:108)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>网上搜索资料得知， Arrays.asList() 生成的 ArrayList 对象是 Arrays自己的内部类对象</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a fixed-size list backed by the specified array.  (Changes to</span></span><br><span class="line"><span class="comment"> * the returned list "write through" to the array.)  This method acts</span></span><br><span class="line"><span class="comment"> * as bridge between array-based and collection-based APIs, in</span></span><br><span class="line"><span class="comment"> * combination with &#123;<span class="doctag">@link</span> Collection#toArray&#125;.  The returned list is</span></span><br><span class="line"><span class="comment"> * serializable and implements &#123;<span class="doctag">@link</span> RandomAccess&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method also provides a convenient way to create a fixed-size</span></span><br><span class="line"><span class="comment"> * list initialized to contain several elements:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the class of the objects in the array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array by which the list will be backed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list view of the specified array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> a.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = size();</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(<span class="keyword">this</span>.a, size,</span><br><span class="line">                                 (Class&lt;? extends T[]&gt;) a.getClass());</span><br><span class="line">        System.arraycopy(<span class="keyword">this</span>.a, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        E oldValue = a[index];</span><br><span class="line">        a[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (a[i] == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(a[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliterator(a, Spliterator.ORDERED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (E e : a) &#123;</span><br><span class="line">            action.accept(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(operator);</span><br><span class="line">        E[] a = <span class="keyword">this</span>.a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = operator.apply(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(a, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayList 继承自 AbstractList，而 AbstractList 的 add() 方法抛出UnsupportedOperationException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException            &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException          &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException      &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException     &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当然，AbstractList 的 remove() 方法也是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This implementation always throws an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException     &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以可以使用其他方式创建List集合对象</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br></pre></td></tr></table></figure><p>方法2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(<span class="string">"str1"</span>, <span class="string">"str2"</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前项目上，有使用 Arrays.asList()
创建一个List集合，并在后续的操作中使用之前创建的List集合继续 add()
添加元素。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;one&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;two&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;three&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list.add(&lt;span class=&quot;string&quot;&gt;&quot;five&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行项目却在 list.add(&quot;five&quot;); 处报错： &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.UnsupportedOperationException&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.AbstractList.add(AbstractList.java:148)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	at java.util.AbstractList.add(AbstractList.java:108)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;网上搜索资料得知， Arrays.asList() 生成的 ArrayList 对象是 Arrays
自己的内部类对象&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Arrays.asList" scheme="http://yoursite.com/tags/Arrays-asList/"/>
    
  </entry>
  
  <entry>
    <title>关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题</title>
    <link href="http://yoursite.com/2022/11/03/%E5%85%B3%E4%BA%8E%E3%80%8A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B%E7%AC%AC5%E7%89%88%E3%80%8BUML%E6%9E%84%E4%BB%B6%E5%9B%BE%E4%B8%A4%E7%B1%BB%E6%8E%A5%E5%8F%A3%E6%8F%8F%E8%BF%B0%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/</id>
    <published>2022-11-03T03:47:00.000Z</published>
    <updated>2022-11-03T03:48:14.347Z</updated>
    
    <content type="html"><![CDATA[<img src="/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103111026.png"><p>如图所示，在备考软件设计师时，有遇到关于 构件图 的题目，官方给的<code>-（</code> 是供接口，<code>O-</code>是需接口，就像官方教程上展示的这样。但是发现有其他人说 <code>-（</code>是需接口，<code>O-</code>是供接口。这就很懵圈了，然后我搜索国内的资料，也都是说：<code>-（</code> 是需接口，<code>O-</code> 是供接口</p><a id="more"></a><p><a href="https://www.cnblogs.com/zhanchenjin/p/16658561.html" target="_blank" rel="noopener">#UML设计图10-构件图</a></p><img src="/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103112133.png"><p><a href="https://www.baidu.com/link?url=GdYQRWlkvBCkHJ-YIEsibtDFzoS-PUpXa_-qZ4noYZMLMZ4zYYrYA01ishPu7yYqOn-22Bo9KlUI1dyPcuaYa_&amp;wd=&amp;eqid=993235b0000028d70000000663633490" target="_blank" rel="noopener">#【UML简明教程】接口 - Tim的资源站</a></p><img src="/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103112530.png"><p>我也去外网上搜索了一下，搜索到的资料也都显示的是： <code>-（</code>是需接口，<code>O-</code> 是供接口</p><p><a href="https://ducmanhphan.github.io/2020-01-27-The-different-types-of-Interfaces-in-UML-diagrams/" target="_blank" rel="noopener">#The different types of interfaces in UML diagram</a></p><img src="/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103112821.png"><p><a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-component-diagram/" target="_blank" rel="noopener">#What is Component Diagram? </a></p><img src="/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103112956.png"><blockquote><p>从互联网上多数资料来看，正确的应该是 <code>-（</code>是需接口，<code>O-</code> 是供接口</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/2022/11/03/关于《软件设计师教程第5版》UML构件图两类接口描述错误的问题/微信截图_20221103111026.png&quot;&gt;
&lt;p&gt;如图所示，在备考软件设计师时，有遇到关于 构件图 的题目，官方给的
&lt;code&gt;-（&lt;/code&gt; 是供接口，&lt;code&gt;O-&lt;/code&gt;
是需接口，就像官方教程上展示的这样。但是发现有其他人说 &lt;code&gt;-（&lt;/code&gt;
是需接口，&lt;code&gt;O-&lt;/code&gt;
是供接口。这就很懵圈了，然后我搜索国内的资料，也都是说：
&lt;code&gt;-（&lt;/code&gt; 是需接口，&lt;code&gt;O-&lt;/code&gt; 是供接口&lt;/p&gt;
    
    </summary>
    
    
      <category term="升级之路" scheme="http://yoursite.com/categories/%E5%8D%87%E7%BA%A7%E4%B9%8B%E8%B7%AF/"/>
    
    
      <category term="软件设计" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
      <category term="构件图" scheme="http://yoursite.com/tags/%E6%9E%84%E4%BB%B6%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>根据JetBrains Fleet文档创建maven项目失败的解决办法</title>
    <link href="http://yoursite.com/2022/10/26/%E6%A0%B9%E6%8D%AEJetBrains-Fleet%E6%96%87%E6%A1%A3%E5%88%9B%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/</id>
    <published>2022-10-26T08:46:26.000Z</published>
    <updated>2022-10-26T09:24:04.204Z</updated>
    
    <content type="html"><![CDATA[<p>打算尝试一下Fleet编辑器，根据<a href="https://www.jetbrains.com/help/fleet/getting-started-with-java-in-fleet.html#open-workspace" target="_blank" rel="noopener">JetBrainsFleet文档</a>创建maven项目.</p><p>首选确认本地机器上已经安装并配置了maven</p><p>按照文档提示，通过<code>CTRL+ALT+T</code> 打开 terminal窗口，在编辑器的下方</p><p>粘贴并执行<code>mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false</code></p><p>创建失败，提下如下</p><img src="/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/QQ截图20221026170547.png"><a id="more"></a><p>然后google之，在stackoverflow上发现了这篇文章 <a href="https://stackoverflow.com/questions/16348459/error-the-goal-you-specified-requires-a-project-to-execute-but-there-is-no-pom" target="_blank" rel="noopener">https://stackoverflow.com/questions/16348459/error-the-goal-you-specified-requires-a-project-to-execute-but-there-is-no-pom</a></p><img src="/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/QQ截图20221026170831.png"><img src="/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/UFqqh.png"><p>简而言之：<em>必须用引号括起所有参数</em></p><p>于是重新修改了mvn命令并重新执行</p><p><code>mvn archetype:generate "-DgroupId=com.mycompany.app" "-DartifactId=my-app" "-DarchetypeArtifactId=maven-archetype-quickstart" "-DarchetypeVersion=1.4" "-DinteractiveMode=false"</code></p><p>于是maven项目创建成功</p><img src="/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/QQ截图20221026171206.png"><img src="/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/QQ截图20221026171222.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打算尝试一下Fleet编辑器，根据&lt;a href=&quot;https://www.jetbrains.com/help/fleet/getting-started-with-java-in-fleet.html#open-workspace&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JetBrains
Fleet文档&lt;/a&gt;创建maven项目.&lt;/p&gt;
&lt;p&gt;首选确认本地机器上已经安装并配置了maven&lt;/p&gt;
&lt;p&gt;按照文档提示，通过&lt;code&gt;CTRL+ALT+T&lt;/code&gt; 打开 terminal
窗口，在编辑器的下方&lt;/p&gt;
&lt;p&gt;粘贴并执行
&lt;code&gt;mvn archetype:generate -DgroupId=com.mycompany.app -DartifactId=my-app -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;创建失败，提下如下&lt;/p&gt;
&lt;img src=&quot;/2022/10/26/根据JetBrains-Fleet文档创建maven项目失败的解决办法/QQ截图20221026170547.png&quot;&gt;
    
    </summary>
    
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="根据JetBrains" scheme="http://yoursite.com/tags/%E6%A0%B9%E6%8D%AEJetBrains/"/>
    
      <category term="Fleet" scheme="http://yoursite.com/tags/Fleet/"/>
    
      <category term="maven" scheme="http://yoursite.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>MySQL根据出生日期计算当前年龄</title>
    <link href="http://yoursite.com/2022/10/21/MySQL%E6%A0%B9%E6%8D%AE%E5%87%BA%E7%94%9F%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97%E5%BD%93%E5%89%8D%E5%B9%B4%E9%BE%84/"/>
    <id>http://yoursite.com/2022/10/21/MySQL根据出生日期计算当前年龄/</id>
    <published>2022-10-21T06:03:18.000Z</published>
    <updated>2022-10-21T06:05:57.880Z</updated>
    
    <content type="html"><![CDATA[<p>假如人员的出生日期为 <code>1994-10-01</code>，首先用 MySQL 的<code>now()</code>函数获取当前系统日期，然后利用<code>DATE_FORMAT()</code>函数计算出当前年龄。</p><a id="more"></a><blockquote><p>注意：<code>DATE_FORMAT()</code> 方法后面要加<code>0</code></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">DATE_FORMAT</span>(<span class="keyword">FROM_DAYS</span>(<span class="keyword">DATEDIFF</span>(<span class="keyword">now</span>(), <span class="string">'1994-10-01'</span>)), <span class="string">'%Y'</span>)+<span class="number">0</span> <span class="keyword">as</span> age</span><br></pre></td></tr></table></figure><p>实践一下，当前系统时间为 2022-08-29 10:50:54</p><img src="/2022/10/21/MySQL根据出生日期计算当前年龄/1.png"><ul><li><code>DATEDIFF()</code> 函数返回两个日期之间的天数。</li><li><code>FROM_DAYS()</code>函数：给定一个天数N，并返回一个日期值。</li><li><code>DATE_FORMAT()</code>函数用于以不同的格式显示日期/时间数据。</li></ul><blockquote><p>使用FROM_DAYS()谨慎旧日期，它不打算使用与之前的公历(1582年)的到来值。</p></blockquote><hr><p>参考资料：</p><p><a href="https://www.tutorialspoint.com/calculate-age-based-on-date-of-birth-in-mysql" target="_blank" rel="noopener">https://www.tutorialspoint.com/calculate-age-based-on-date-of-birth-in-mysql</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如人员的出生日期为 &lt;code&gt;1994-10-01&lt;/code&gt;，首先用 MySQL 的
&lt;code&gt;now()&lt;/code&gt;
函数获取当前系统日期，然后利用&lt;code&gt;DATE_FORMAT()&lt;/code&gt;
函数计算出当前年龄。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>处理MySQL使用concat()函数时遇到null值的问题</title>
    <link href="http://yoursite.com/2022/10/21/%E5%A4%84%E7%90%86MySQL%E4%BD%BF%E7%94%A8concat-%E5%87%BD%E6%95%B0%E6%97%B6%E9%81%87%E5%88%B0null%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/</id>
    <published>2022-10-21T05:43:23.000Z</published>
    <updated>2023-02-21T07:19:13.550Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题描述">问题描述</h4><p>使用<code>CONCAT()</code>拼接结果是，当<code>CONCAT()</code>函数中的一个参数为<code>null</code>，那么不管其他字符串是否有值，最后返回的拼接结果总是<code>null</code>，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">address,</span><br><span class="line">nationality,</span><br><span class="line"><span class="keyword">CONCAT</span>(<span class="string">'my name is '</span>, <span class="keyword">name</span>, <span class="string">', to live in '</span>, address, <span class="string">', and i am from '</span>, nationality) <span class="keyword">as</span> <span class="keyword">str</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user2`</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><img src="/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/1.png"><p>MySQL 官方文档有句话</p><img src="/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/2.png"><h4 id="解决办法">解决办法</h4><ol type="1"><li>使用 <code>COALESCE()</code> 函数转换null值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">address,</span><br><span class="line">nationality,</span><br><span class="line"><span class="keyword">CONCAT</span>(<span class="string">'my name is '</span>, <span class="keyword">COALESCE</span>(<span class="keyword">name</span>, <span class="string">''</span>), <span class="string">', to live in '</span>, <span class="keyword">COALESCE</span>(address, <span class="string">''</span>), <span class="string">', and i am from '</span>, <span class="keyword">COALESCE</span>(nationality, <span class="string">''</span>)) <span class="keyword">as</span> <span class="keyword">str</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user2`</span></span><br></pre></td></tr></table></figure><img src="/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/3.png"><ol start="2" type="1"><li>使用<code>IFNULL()</code> 函数转换null值 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">address,</span><br><span class="line">nationality,</span><br><span class="line"><span class="keyword">CONCAT</span>(<span class="string">'my name is '</span>, <span class="keyword">ifnull</span>(<span class="keyword">name</span>, <span class="string">''</span>), <span class="string">', to live in '</span>, <span class="keyword">ifnull</span>(address, <span class="string">''</span>), <span class="string">', and i am from '</span>, <span class="keyword">ifnull</span>(nationality, <span class="string">''</span>)) <span class="keyword">as</span> <span class="keyword">str</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user2`</span></span><br></pre></td></tr></table></figure></li></ol><img src="/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/4.png"><ol start="3" type="1"><li>尝试使用<code>CONCAT_WS()</code> 函数拼接字符串 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">name</span>,</span><br><span class="line">address,</span><br><span class="line">nationality,</span><br><span class="line"><span class="keyword">CONCAT_WS</span>(<span class="string">','</span>,<span class="keyword">name</span>,address,nationality) <span class="keyword">as</span> <span class="keyword">str</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="string">`user2`</span></span><br></pre></td></tr></table></figure></li></ol><img src="/2022/10/21/处理MySQL使用concat-函数时遇到null值的问题/5.png"><hr><p>参考资料：</p><ol type="1"><li><p><a href="https://stackoverflow.com/questions/15741314/mysql-concat-returns-null-if-any-field-contain-null" target="_blank" rel="noopener">https://stackoverflow.com/questions/15741314/mysql-concat-returns-null-if-any-field-contain-null</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat" target="_blank" rel="noopener">12.8String Functions and Operators</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/flow-control-functions.html#function_ifnull" target="_blank" rel="noopener">12.5Flow Control Functions</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;问题描述&quot;&gt;问题描述&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;CONCAT()&lt;/code&gt;拼接结果是，当&lt;code&gt;CONCAT()&lt;/code&gt;函数中的一个参数为&lt;code&gt;null&lt;/code&gt;，那么不管其他字符串是否有值，最后返回的拼接结果总是&lt;code&gt;null&lt;/code&gt;，如下所示：
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	address,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	nationality,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;CONCAT&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;my name is &#39;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;, to live in &#39;&lt;/span&gt;, address, &lt;span class=&quot;string&quot;&gt;&#39;, and i am from &#39;&lt;/span&gt;, nationality) &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;str&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`user2`&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>货币的发行</title>
    <link href="http://yoursite.com/2022/07/25/%E8%B4%A7%E5%B8%81%E7%9A%84%E5%8F%91%E8%A1%8C/"/>
    <id>http://yoursite.com/2022/07/25/货币的发行/</id>
    <published>2022-07-25T07:06:15.000Z</published>
    <updated>2022-07-29T07:04:22.046Z</updated>
    
    <content type="html"><![CDATA[<p>中国共产党的货币实践有一个特点，就是货币本位十分灵活（当然也有革命条件艰苦缺乏贵金属的因素），从革命战争年代到改革开放以前长期实行的是一种“物资本位”。下面以长征时期的货币发行实践举例，题主大概可以见微知著，了解“物资本位”货币的发行、流通与回收</p><a id="more"></a><p>1935年1月7日，红军攻占遵义城。遵义是贵州省内仅次于贵阳的第二大城市，一向为黔北中心，各种土产集散地，汉、苗等族商旅云集之所，市场十分繁华，是红军长征以来所经过的第一座繁华的中等城市。</p><p>红军大部队进城时，群众已发动起来，“各种商店都已开门营业，百货日用品、食品到处都是，街上行人也很多，有赶街市的，有看热闹的，有做宣传的，还有高声叫卖麻糖的”。久困大山、长期作战的红军指战员，得到这么一个难得的休整机会，来到这么一个有大量东西可买的地方，也急需用经费购买生活、医疗等用品，以利今后的行军打仗。</p><p>但由于红军指战员随身携带的经费一部分或全部是苏维埃国家银行在中央苏区发行的苏维埃纸币，它们在白区无法流通，得不到当地百姓的认可。另一方面，当年遵义作为国民党政府的一个行署，管辖十来个县，自是军阀、官僚、地主、奸商相互勾结的地方，贵州军阀王家烈便在这里称雄一方。他在遵义开有烟馆、盐行，囤积了价值几十万元的食盐和大量烟土。当地缺盐，他一手操纵市场，以高价出售。其时猪肉才两角钱一斤，盐巴倒要四角钱一斤。许多老百姓因为买不起盐而患大脖子病。</p><p>苏维埃国家银行对上述情况进行了充分的估量，认为这种一面到处是商机、商业活动，一面群众严重缺盐而军阀囤积居奇的局面，有利于发行苏维埃钞票，主导市场，满足群众需要。他们把没收来的大量食盐和其他稀缺物资以低价卖给群众，规定只收苏维埃钞票，不收其他货币。而且一元苏维埃钞票可到兑换点换取一元二角现洋，或两元国民党的钞票。由于国家银行有充足的现金(银圆、金条等)和物资保证，发行的苏维埃钞票完全可以兑现，遵义城及附近驻有红军部队的城镇的群众和商家都乐于接纳、使用苏维埃钞票，红军指战员得以用手中的苏维埃币购买必要的物资。苏维埃钞票信誉盛极一时，市面也空前繁荣。为此，国家银行的工作人员在遵义度过了最为忙碌的10天。</p><p>由于无法在遵义建立稳固的根据地，红军决定撤离遵义。在红军撤离遵义前，为避免百姓蒙受损失或招来报复，苏维埃国家银行连夜组织回笼苏维埃币。这样，短短的十几天里，苏维埃国家银行完成了苏维埃币的发行、流通与回收，创造了一个奇迹。</p><p>国家银行在遵义发行、回笼苏维埃钞票的做法，既活跃了市场，保障了红军的供给，又维护了苏维埃钞票的信誉，维护了群众的利益，因而在当地留下了很好的影响，树立了共产党和红军的良好形象。对于当年少数还流散在群众手中的苏维埃钞票，1955年国家发行新的人民币时，还以1∶1的比价兑回了。</p><p>-- 以上来自 <a href="https://www.zhihu.com/question/25049553/answer/32176501" target="_blank" rel="noopener">知乎方亮</a></p><hr><p>关于货币发行的问题，可能大多数人是不清楚的，但是不了解货币发行的原理，对于各种经济学现象就不能真正的理解。关于中国目前货币是如何发行的，这样发行的道理又是什么，本人做了以下研究和思考。</p><p>首先国内货币的发行，离不开中国人民银行（简称央行，是中华人民共和国的中央银行）。本人理解央行和现代企业运行的基本规则是相似的。企业的主要职责是赚取利润，而央行的主要职责就是通过控制市场中货币的数量，来实现物价稳定（即通货膨胀指标）、经济发展、充分就业、国际收支平衡（汇率指标）等目标。央行对外提供借款，需要设定利率和借款期限，到期收回借款，央行可以对外支付对价购买外汇、债券等资产，这些都是和企业的运行规则是相似的。</p><p>央行控制市场中货币数量的方法主要包括向商业银行购买外汇和提供贷款。其中提供贷款又可细分为MLF、PSL等公开市场操作投放和再贷款、再贴现投放。</p><p>首先要说明的央行向商业银行购买外汇。目前国际贸易中主要是以美元结算，因为美国的超级大国的国际地位，让美元成为类似于黄金的硬通货。正是因为美元作为国际结算的主要货币，所以国家需要储备美元资产。国内的对外贸易公司通过向国外出售商品赚取到了美元，将一部分需要兑换成人民币的美元出售给中国银行（国内一般都是出售给中国银行），央行再向商业银行购买这部分外汇。央行购买的外汇向国外换为其他资产，如下图所示。</p><img src="/2022/07/25/货币的发行/v2-7f38fbd86bb35d1fdc96a381a7e63765_720w.jpg"><p>央行购买外汇支付的是债券（即人民币），这里债券相当于借条，只不过因为央行的地位，这张借条有了在市场流通的价值，可以在市场中购买资产，所以也就不需要用这张借条向央行要求还资产了。（在这里要说明的是，央行对外支付的货币可以是纸质也可以是账户里的余额，两者是等价的。在现实生活中，纸质货币能满足大家的一些使用需求，所以央行需要投放和更换市场中的纸质货币，满足大家对纸质货币的使用需求。但市场中的货币，现金（M0)只占其中一小部分，货币大部分以银行存款的余额和其他形式存在，这里不做过多解释。）央行和商业银行的资产负债表如下图所示。</p><img src="/2022/07/25/货币的发行/v2-82204188854ed918b280b4e7556b6a0a_720w.jpg"><p>央行从商业银行手中买入资产，通过增加商业银行在央行账户的存款准备金为支付手段。商业银行可以在超出央行规定的存款准备金比例之外的资金支取，用于银行的对外贷款等业务，从而增加了货币在市场中的数量。</p><img src="/2022/07/25/货币的发行/v2-0068f48a4d91a8e0dcee4a9510e52b36_720w.jpeg"><p>央行在向商业银行提供贷款中，央行增加债权资产和商业银行存款负债，商业银行增加负债和央行存款。央行向商业银行提供贷款同样增加了市场中货币的数量。</p><p>增加的货币数量，通过货币乘数，转化为真正的货币增量。（具体原理：假设甲有1000元的现金，存在商业银行A活期存款帐户。银行按照中央银行的要求，把其中10%（100元）交纳法定准备金，存入中央银行。剩下的900元可以全部贷出去，贷给乙。乙把这些钱再存入乙在B银行的帐户，B银行再交给中国人民银行90元，剩下的再贷出去。周而复始，理论上可以产生10000（1000/10%）元的活期存款。那么这个货币乘数就是10。10000元为真正增加的货币数量）</p><p>以上是央行控制市场中货币数量的方法，央行会根据市场是否缺少流动性，来调整其以上方法的使用力度，达到其想要实施的货币政策。</p><p>市场中货币数量的增加，在总商品数量不变的情况下，会引起商品价格的上升，货币总是追逐相对有些的商品引起价格的上升。因此当货币发行的速度，大于GDP的增长速度，那么就会带来通货膨胀。在通货膨胀的过程中，谁会受益呢？应该是能从价格上升中得到益处的人。通过努力，在这个过程中拥有较多具有保值功能的资产的人会受益。还有谁会受益呢，能够利用流动性宽裕的人，通过其良好的运作，可以在其中获益。</p><p>-- 以上来自 <a href="https://zhuanlan.zhihu.com/p/89363149" target="_blank" rel="noopener">知乎大峰哥</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;中国共产党的货币实践有一个特点，就是货币本位十分灵活（当然也有革命条件艰苦缺乏贵金属的因素），从革命战争年代到改革开放以前长期实行的是一种“物资本位”。下面以长征时期的货币发行实践举例，题主大概可以见微知著，了解“物资本位”货币的发行、流通与回收&lt;/p&gt;
    
    </summary>
    
    
      <category term="兴趣使然" scheme="http://yoursite.com/categories/%E5%85%B4%E8%B6%A3%E4%BD%BF%E7%84%B6/"/>
    
    
      <category term="货币" scheme="http://yoursite.com/tags/%E8%B4%A7%E5%B8%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="http://yoursite.com/2020/04/26/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/04/26/MySQL事务/</id>
    <published>2020-04-26T02:38:32.000Z</published>
    <updated>2022-07-25T06:26:34.838Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库事务是一组原子性的SQL单元，事务内的语句要么全部执行成功，要么全部执行失败。</p><h3 id="事务的四个特性">事务的四个特性</h3><ul><li>原子性（Atomicity）事务必须是原子工作单元，事务中的操作要么全部执行成功，要么全部执行失败，不能只执行部分操作。</li><li>一致性事务开始之前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如，在银行转账中，用户可以定义转账前后两个账户金额之和保持不变。</li><li>隔离性通常来说一个事务在修改时但还未提交，对其他事务是不可见的。</li><li>持久性-一旦事务提交，则其所做的修改就会永久保存在数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li></ul><a id="more"></a><h3 id="事务的脏读不可重复读幻读">事务的脏读、不可重复读、幻读</h3><ul><li>脏读：事务 A 读取了事务 B 更新后的数据，但是事务 B没有提交，然后事务 B 执行回滚操作，那么事务 A读到的数据就是脏数据。</li><li>不可重复读：事务 A 进行多次读取操作，事务 B 在事务 A多次读取的过程中执行更新操作并提交，提交后事务 A 读到的数据不一致。</li><li>幻读：事务 A 将数据库中所有学生的成绩由 A -&gt; B，此时事务 B手动插入了一条成绩为 A 的记录，在事务 A更改完毕后，发现还有一条记录没有修改，那么这种情况就叫做出现了幻读。</li></ul><h3 id="事务的隔离级别">事务的隔离级别</h3><p>读未提交(read uncommitted)、读已提交(readcommitted)、可重复读(repetable read) 和 串行化(serializable)。</p><ul><li><p>读未提交：读未提交指的是一个事务在提交之前，它所做的修改就能够被其他事务所看到。</p></li><li><p>读已提交：读已提交指的是一个事务在提交之后，它所做的变更才能够让其他事务看到。</p></li><li><p>可重复读：可重复读指的是一个事务在执行的过程中，看到的数据是和启动时看到的数据是一致的。未提交的变更对其他事务不可见。</p></li><li><p>串行化：顾名思义是对于同一行记录，写会加写锁，读会加读锁。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</p></li></ul><img src="/2020/04/26/MySQL事务/640.png"><p>隔离级别由低到高是：读未提交 &lt; 读已提交 &lt; 可重复读 &lt;串行化</p><h3 id="mysql-常见存储引擎的区别">MySQL 常见存储引擎的区别</h3><p>通过SQL语句 <code>SHOW ENGINES</code>查看存储引擎</p><img src="/2020/04/26/MySQL事务/641.png"><p>可以看到，InnoDB 是 MySQL默认支持的存储引擎，支持事务、行级锁定和外键。</p><h4 id="myisam-存储引擎的特点">MyISAM 存储引擎的特点</h4><p>在 5.1 版本之前，MyISAM 是 MySQL 的默认存储引擎，MyISAM并发性比较差，使用的场景比较少，主要特点是</p><ul><li><p>不支持事务操作，ACID的特性也就不存在了，这一设计是为了性能和效率考虑的。</p></li><li><p>不支持外键操作，如果强行增加外键，MySQL不会报错，只不过外键不起作用。</p></li><li><p>MyISAM默认的锁粒度是表级锁，所以并发性能比较差，加锁比较快，锁冲突比较少，不太容易发生死锁的情况。</p></li><li><p>MyISAM 会在磁盘上存储三个文件，文件名和表名相同，扩展名分别是.frm(存储表定义)、.MYD(MYData,存储数据)、MYI(MyIndex,存储索引)。这里需要特别注意的是MyISAM 只缓存索引文件，并不缓存数据文件。</p></li><li><p>MyISAM 支持的索引类型有 全局索引(Full-Text)、B-Tree 索引、R-Tree索引 Full-Text索引：它的出现是为了解决针对文本的模糊查询效率较低的问题。 B-Tree索引：所有的索引节点都按照平衡树的数据结构来存储，所有的索引数据节点都在叶节点R-Tree索引：它的存储方式和 B-Tree索引有一些区别，主要设计用于存储空间和多维数据的字段做索引,目前的 MySQL版本仅支持 geometry 类型的字段作索引，相对于 BTREE，RTREE的优势在于范围查找。</p></li><li><p>数据库所在主机如果宕机，MyISAM的数据文件容易损坏，而且难以恢复。</p></li><li><p>增删改查性能方面：SELECT 性能较高，适用于查询较多的情况</p></li></ul><h4 id="innodb-存储引擎的特点">InnoDB 存储引擎的特点</h4><p>自从 MySQL 5.1 之后，默认的存储引擎变成了 InnoDB 存储引擎，相对于MyISAM，InnoDB 存储引擎有了较大的改变，它的主要特点是</p><ul><li><p>支持事务操作，具有事务 ACID隔离特性，默认的隔离级别是可重复读(repetable-read)、通过MVCC（并发版本控制）来实现的。能够解决脏读和不可重复读的问题。</p></li><li><p>InnoDB 支持外键操作。</p></li><li><p>InnoDB默认的锁粒度行级锁，并发性能比较好，会发生死锁的情况。</p></li><li><p>和 MyISAM 一样的是，InnoDB 存储引擎也有 .frm文件存储表结构定义，但是不同的是，InnoDB 的表数据与索引数据是存储在一起的，都位于 B+数的叶子节点上，而 MyISAM 的表数据和索引数据是分开的。</p></li><li><p>InnoDB有安全的日志文件，这个日志文件用于恢复因数据库崩溃或其他情况导致的数据丢失问题，保证数据的一致性。</p></li><li><p>InnoDB 和 MyISAM支持的索引类型相同，但具体实现因为文件结构的不同有很大差异。</p></li><li><p>增删改查性能方面，如果执行大量的增删改操作，推荐使用 InnoDB存储引擎，它在删除操作时是对行删除，不会重建表。</p></li></ul><h4 id="myisam-和-innodb-存储引擎的对比">MyISAM 和 InnoDB存储引擎的对比</h4><ul><li><p>锁粒度方面：由于锁粒度不同，InnoDB 比 MyISAM支持更高的并发；InnoDB 的锁粒度为行锁、MyISAM的锁粒度为表锁、行锁需要对每一行进行加锁，所以锁的开销更大，但是能解决脏读和不可重复读的问题，相对来说也更容易发生死锁</p></li><li><p>可恢复性上：由于 InnoDB是有事务日志的，所以在产生由于数据库崩溃等条件后，可以根据日志文件进行恢复。而MyISAM 则没有事务日志。</p></li><li><p>查询性能上：MyISAM 要优于 InnoDB，因为 InnoDB在查询过程中，是需要维护数据缓存，而且查询过程是先定位到行所在的数据块，然后在从数据块中定位到要查找的行；而MyISAM 可以直接定位到数据所在的内存地址，可以直接找到数据。</p></li><li><p>表结构文件上：MyISAM的表结构文件包括：.frm(表结构定义),.MYI(索引),.MYD(数据)；而 InnoDB的表数据文件为:.ibd和.frm(表结构定义)；</p></li></ul><p>文章来自<a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&amp;mid=2247486267&amp;idx=1&amp;sn=b96d38b39c34d400c9985c54899e126b&amp;chksm=fc45f6c8cb327fdecabac01cb7d6fe0d75c8c212fb341cf3dc7e481b53d5fe8915160b2059e8&amp;mpshare=1&amp;scene=24&amp;srcid=0514ROWD2lIjFItWOKlBYXL7&amp;sharer_sharetime=1589434711640&amp;sharer_shareid=50e38dcd7776348278a128de8ad8d396&amp;key=8d915c155b1ceb9625a9dda450e6bf03db464ddba9fffe454cf51960477f186591696584f72a61f96c942a2e9bf698615ae2bec9e397ec4b765aab5f5874b8272c427f9aed42e3c9fc5fc7dfc1bbd1c7&amp;ascene=14&amp;uin=OTQ3NzYxMTM2&amp;devicetype=Windows+10+x64&amp;version=62090070&amp;lang=zh_CN&amp;exportkey=AzZJkfttIkfe4EOendMMvhg%3D&amp;pass_ticket=Ca7nWpSV1zN1yKOGQoK6bpsW%2BmahyJBCE2FC9DYbOLGCDSxdtOi15zeY3wsLQ%2Bdd" target="_blank" rel="noopener">Java建设者</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MySQL数据库事务是一组原子性的SQL单元，事务内的语句要么全部执行成功，要么全部执行失败。&lt;/p&gt;
&lt;h3 id=&quot;事务的四个特性&quot;&gt;事务的四个特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原子性（Atomicity）
事务必须是原子工作单元，事务中的操作要么全部执行成功，要么全部执行失败，不能只执行部分操作。&lt;/li&gt;
&lt;li&gt;一致性
事务开始之前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态。数据库一致性的定义是由用户负责的。例如，在银行转账中，用户可以定义转账前后两个账户金额之和保持不变。&lt;/li&gt;
&lt;li&gt;隔离性
通常来说一个事务在修改时但还未提交，对其他事务是不可见的。&lt;/li&gt;
&lt;li&gt;持久性
-一旦事务提交，则其所做的修改就会永久保存在数据库中。此时即使系统崩溃，修改的数据也不会丢失。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="事务" scheme="http://yoursite.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="http://yoursite.com/2020/04/14/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/14/Java多线程/</id>
    <published>2020-04-14T05:18:42.000Z</published>
    <updated>2022-10-21T06:11:28.136Z</updated>
    
    <content type="html"><![CDATA[<p>Java 给多线程编程提供了内置的支持。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p><p>这里定义和线程相关的另一个术语 -进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</p><p>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><a id="more"></a><h3 id="线程和进程的区别">线程和进程的区别</h3><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存来存储本地数据。</p><h3 id="创建线程有哪几种方式分别有什么优缺点">创建线程有哪几种方式？分别有什么优缺点？</h3><h4 id="创建线程">创建线程</h4><ul><li>继承Thread类，重写run()方法；</li><li>实现Runnable接口，实现run()方法，并将该实现类作为参数传入Thread构造器。</li><li>实现Callable接口，重写call()方法，并包装成FutureTask对象，再作为参数传入Thread构造器。</li></ul><h4 id="继承thread类优缺点">继承Thread类优缺点</h4><p>优点是编码简单，缺点是不能再继承其他的类，功能单一。</p><h4 id="实现runnable接口优缺点">实现Runnable接口优缺点</h4><p>优点是可以继承其他类，避免单继承的局限性；适合多个相同程序代码的线程共享一个资源，实现解耦操作，代码和线程独立。缺点是实现相对复杂。</p><h4 id="实现callable接口优缺点">实现Callable接口优缺点</h4><p>优点是相比方式二可以获取返回值，缺点是实现复杂。</p><h3 id="线程的状态">线程的状态</h3><ul><li><p>new（新建）：线程刚刚被创建，但是并未启动，还没有调用start方法。</p></li><li><p>Runnable（可运行）：线程可以在Java虚拟机中执行的状态，但是这个“执行”，不一定是真的运行，也可能是在等待CPU资源。所以在网上，有人把这个状态区分为READY和RUNNING两个，一个表示的start了，资源一到位随时可以执行，另一个表示真正的执行中。</p></li><li><p>Blocked（锁阻塞）：当一个线程试图获取一个锁对象，而该对象被其他的线程持有，则该线程进入Blocked状态；比较经典的就是synchronized关键字，这个关键字修饰的代码块或者方法，均需要获取到对应的锁，在未获取之前，其线程的状态就一直为BLOCKED，当该线程持有锁时，该线程将变成Runnable状态。如果线程长时间处于这种状态下，我们就要当心，看看是否出现死锁的问题了。</p></li><li><p>Waiting（无限等待）：一个线程在等待另一个线程执行动作是，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。</p></li><li><p>TimedWaiting（计时等待）：同waiting状态，有几个方法有超时参数，调用他们将进入TimedWaiting状态。如：</p></li><li><p>Object.wait()</p></li><li><p>Thread.join()</p></li><li><p>Thread.sleep</p></li><li><p>LockSupport.park()</p></li></ul><p>这一状态将一直保持到超时期满或者收到唤醒通知。</p><ul><li>THRMINATED（死亡状态）：因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</li></ul><img src="/2020/04/14/Java多线程/314e251f95cad1c8532ac9ecc4c16d0fcb3d5169.png"><h3 id="volatile关键字">volatile关键字</h3><ul><li>保证被修饰的变量对所有线程可见，在一个线程修改一个变量的值后，新值对其他线程是可以立即获取的。</li><li>禁止指令重排序，被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取<code>volatile</code>修饰的变量时总是会返回最新写入的值。</li><li>不会执行加锁操作，不会导致线程阻塞，主要适用于一个变量被多个线程共享，多个线程均可对这个变量执行赋值或读取的操作，</li><li><code>volatile</code>可以严格保证变量的单次读写操作的原子性，但不能保证像<code>i++</code>这种操作的原子性，因为<code>i++</code> 在本质上是读、写两次操作。</li></ul><h3 id="synchronized关键字">synchronized关键字</h3><ul><li>用于为Java对象、方法、代码块提供线程安全的操作，属于排它的悲观锁，也属于可重入锁。</li><li>被<code>synchronzied</code>修饰的方法和代码块在同一时刻只能有一个线程访问，其他线程只能等待当前线程释放资源后才能访问。</li><li>Java中的每个对象都有一个<code>monitor</code>监视器对象，加锁就是在竞争<code>monitor</code>，对代码块加锁是通过在前后分别加上<code>monitorenter</code>和<code>monitorexit</code>指令实现的，对方是否加锁是通过一个标记位来判断的。</li></ul><h3 id="线程池是什么为什么需要线程池">线程池是什么？为什么需要线程池？</h3><ul><li>在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。</li><li>线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。</li><li>线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟的任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。</li></ul><h3 id="创建线程池时threadpoolexecutor构造器中都有哪些参数以及各自的含义">创建线程池时，ThreadPoolExecutor构造器中都有哪些参数以及各自的含义</h3><ul><li>corePoolSize：线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。</li><li>maximumPoolSize：线程池最大大小，表示可同时活动的线程数量的上限。</li><li>keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。</li><li>unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量：NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。</li><li>workQueue： 线程池所使用的阻塞队列。</li><li>threadfactory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。</li><li>handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。</li></ul><h3 id="创建线程池的方法有哪些">创建线程池的方法有哪些？</h3><h4 id="可以通过executors的静态工厂方法创建线程池内部通过重载threadexecutorpool不同的构造器创建线程池">可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。</h4><ul><li>newFixedThreadPool，创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的异常而结束，那么线程池会补充一个新的线程)。将线程池的核心大小和最大大小都设置为参数中指定的值，创建的线程不会超时，使用LinkedBlockingQueue。</li><li>newCachedThreadPool，创建一个可缓存的线程池，如果线程池的当前规模超过了处理器需求，那么将回收空闲的线程，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。将线程池的最大大小设置为Integer.MAX_VALUE，而将核心大小设置为0，并将超时设为1分钟，使用SynchronousQueue，这种方法创建出的线程池可被无限扩展，并当需求降低时自动收缩。</li><li>newSingleThreadExecutor，一个单线程的Executor，创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。确保依照任务在队列中的顺序来串行执行。将核心线程和最大线程数都设置为1，使用LinkedBlockingQueue。</li><li>newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer，使用DelayedWorkQueue。</li></ul><h3 id="线程池的工作原理">线程池的工作原理</h3><ul><li>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。即使队列里面有任务，线程池也不会马上执行它们。</li><li>通过 execute(Runnable command)方法被添加到线程池，任务就是一个Runnable类型的对象，任务的执行方法就是Runnable类型对象的run()方法。</li><li>如果workerCount小于corePoolSize，那么创建并启动一个线程执行新提交的任务。如果workerCount大于等于corePoolSize，且线程池内的阻塞队列未满，那么将这个任务放入队列。如果workerCount大于等于corePoolSize，且阻塞队列已满，若满足workerCount小于maximumPoolSize,那么还是要创建并启动一个线程执行新提交的任务。若阻塞队列已满，并且workerCount大于等于maximumPoolSize，则根据handler所指定的策略来处理此任务，默认的处理方式直接抛出异常。也就是处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。</li><li>当一个线程完成任务时，它会从队列中取下一个任务来执行。</li><li>当一个线程没有任务可执行，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize时，那么这个线程会被停用掉，所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</li></ul><h3 id="start和run方法的区别">start和run方法的区别</h3><ul><li>start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。</li><li>run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。</li></ul><h3 id="references">References</h3><p><a href="https://blog.csdn.net/qq_41112238/article/details/105074636" target="_blank" rel="noopener">https://blog.csdn.net/qq_41112238/article/details/105074636</a></p><p><a href="https://baijiahao.baidu.com/s?id=1655501582187466001&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">https://baijiahao.baidu.com/s?id=1655501582187466001&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://www.jianshu.com/p/ec94ed32895f" target="_blank" rel="noopener">https://www.jianshu.com/p/ec94ed32895f</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 给多线程编程提供了内置的支持。
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;p&gt;多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。&lt;/p&gt;
&lt;p&gt;这里定义和线程相关的另一个术语 -
进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。&lt;/p&gt;
&lt;p&gt;多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程语言" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>面试官邪魅一笑：MySQL千万级别大表，你要如何优化？</title>
    <link href="http://yoursite.com/2020/04/09/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%82%AA%E9%AD%85%E4%B8%80%E7%AC%91%EF%BC%9AMySQL%E5%8D%83%E4%B8%87%E7%BA%A7%E5%88%AB%E5%A4%A7%E8%A1%A8%EF%BC%8C%E4%BD%A0%E8%A6%81%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/</id>
    <published>2020-04-09T01:13:07.000Z</published>
    <updated>2022-10-21T05:58:07.480Z</updated>
    
    <content type="html"><![CDATA[<p>当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：</p><a id="more"></a><h3 id="单表优化">单表优化</h3><p>除非单表数据未来会一直不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维的各种复杂度，一般以整型值为主的表在千万级以下，字符串为主的表在五百万以下是没有太大问题的。而事实上很多时候MySQL单表的性能依然有不少优化空间，甚至能正常支撑千万级以上的数据量：</p><h4 id="字段">字段</h4><ul><li>尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED</li><li>VARCHAR的长度只分配真正需要的空间</li><li>使用枚举或整数代替字符串类型</li><li>尽量使用TIMESTAMP而非DATETIME，</li><li>单表不要有太多字段，建议在20以内</li><li>避免使用NULL字段，很难查询优化且占用额外索引空间</li><li>用整型来存IP</li></ul><h4 id="索引">索引</h4><ul><li>索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDERBY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描</li><li>应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描</li><li>值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段</li><li>字符字段只建前缀索引</li><li>字符字段最好不要做主键</li><li>不用外键，由程序保证约束</li><li>尽量不用UNIQUE，由程序保证约束</li><li>使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引</li></ul><h4 id="查询sql">查询SQL</h4><ul><li>可通过开启慢查询日志来找出较慢的SQL</li><li>不做列运算：SELECT id WHERE age + 1 =10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边</li><li>sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库</li><li>不用`SELECT *``</li><li>OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内</li><li>不用函数和触发器，在应用程序实现</li><li>避免%xxx式查询</li><li>少用JOIN</li><li>使用同类型进行比较，比如用'123'和'123'比，123和123比</li><li>尽量避免在WHERE子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</li><li>对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN1 AND 5</li><li>列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大</li></ul><h3 id="引擎">引擎</h3><p>目前广泛使用的是MyISAM和InnoDB两种引擎：</p><h4 id="myisam">MyISAM</h4><p>MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：</p><ul><li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li><li>不支持事务</li><li>不支持外键</li><li>不支持崩溃后的安全恢复</li><li>在表有读取查询的同时，支持往表中插入新纪录</li><li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li><li>支持延迟更新索引，极大提升写入性能</li><li>对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用</li></ul><h4 id="innodb">InnoDB</h4><ul><li>InnoDB在MySQL 5.5后成为默认索引，它的特点是：</li><li>支持行锁，采用MVCC来支持高并发</li><li>支持事务</li><li>支持外键</li><li>支持崩溃后的安全恢复</li><li>不支持全文索引</li></ul><p>总体来讲，MyISAM适合SELECT密集型的表，而InnoDB适合INSERT和UPDATE密集型的表</p><h3 id="系统调优参数">系统调优参数</h3><p>可以使用下面几个工具来做基准测试：</p><ul><li>sysbench：一个模块化，跨平台以及多线程的性能测试工具</li><li>iibench-mysql：基于 Java 的 MySQL/Percona/MariaDB索引进行插入性能测试工具</li><li>tpcc-mysql：Percona开发的TPC-C测试工具</li></ul><p>具体的调优参数内容较多，具体可参考官方文档，这里介绍一些比较重要的参数：</p><ul><li>back_log：back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。也就是说，如果MySql的连接数据达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。可以从默认的50升至500</li><li>wait_timeout：数据库连接闲置时间，闲置连接会占用内存资源。可以从默认的8小时减到半小时</li><li>max_user_connection:最大连接数，默认为0无上限，最好设一个合理上限</li><li>thread_concurrency：并发线程数，设为CPU核数的两倍</li><li>skip_name_resolve：禁止对外部连接进行DNS解析，消除DNS解析时间，但需要所有远程主机用IP访问</li><li>key_buffer_size：索引块的缓存大小，增加会提升索引处理速度，对MyISAM表性能影响最大。对于内存4G左右，可设为256M或384M，通过查询showstatus like 'key_read%'，保证key_reads /key_read_requests在0.1%以下最好</li><li>innodb_buffer_pool_size：缓存数据块和索引块，对InnoDB表性能影响最大。通过查询showstatus like'Innodb_buffer_pool_read%'，保证(Innodb_buffer_pool_read_requests –Innodb_buffer_pool_reads) /Innodb_buffer_pool_read_requests越高越好</li><li>innodb_additional_mem_pool_size：InnoDB存储引擎用来存放数据字典信息以及一些内部数据结构的内存空间大小，当数据库对象非常多的时候，适当调整该参数的大小以确保所有数据都能存放在内存中提高访问效率，当过小的时候，MySQL会记录Warning信息到数据库的错误日志中，这时就需要该调整这个参数大小</li><li>innodb_log_buffer_size：InnoDB存储引擎的事务日志所使用的缓冲区，一般来说不建议超过32MB</li><li>query_cache_size：缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。当某个表的数据有任何任何变化，都会导致所有引用了该表的select语句在QueryCache中的缓存数据失效。所以，当我们的数据变化非常频繁的情况下，使用QueryCache可能会得不偿失。根据命中率(Qcache_hits/(Qcache_hits+Qcache_inserts)*100))进行调整，一般不建议太大，256MB可能已经差不多了，大型的配置型静态数据可适当调大.可以通过命令show status like 'Qcache_%'查看目前系统Querycatch使用大小</li><li>read_buffer_size：MySql读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区。如果对表的顺序扫描请求非常频繁，可以通过增加该变量值以及内存缓冲区大小提高其性能</li><li>sort_buffer_size：MySql执行排序使用的缓冲大小。如果想要增加ORDERBY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。如果不能，可以尝试增加sort_buffer_size变量的大小</li><li>read_rnd_buffer_size：MySql的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大。</li><li>record_buffer：每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，可能想要增加该值</li><li>thread_cache_size：保存当前没有与连接关联但是准备为后面新的连接服务的线程，可以快速响应连接的线程请求而无需创建新的</li><li>table_cache：类似于thread_cache_size，但用来缓存表文件，对InnoDB效果不大，主要用于MyISAM</li></ul><h3 id="升级硬件">升级硬件</h3><p>Scaleup，这个不多说了，根据MySQL是CPU密集型还是I/O密集型，通过提升CPU和内存、使用SSD，都能显著提升MySQL性能</p><h3 id="读写分离">读写分离</h3><p>也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离</p><h3 id="缓存">缓存</h3><p>缓存可以发生在这些层次：</p><ul><li>MySQL内部：在系统调优参数介绍了相关设置</li><li>数据访问层：比如MyBatis针对SQL语句做缓存，而Hibernate可以精确到单个记录，这里缓存的对象主要是持久化对象PersistenceObject</li><li>应用服务层：这里可以通过编程手段对缓存做到更精准的控制和更多的实现策略，这里缓存的对象是数据传输对象DataTransfer Object</li><li>Web层：针对web页面做缓存</li><li>浏览器客户端：用户端的缓存</li></ul><p>可以根据实际情况在一个层次或多个层次结合加入缓存。这里重点介绍下服务层的缓存实现，目前主要有两种方式：</p><ul><li>直写式（WriteThrough）：在数据写入数据库后，同时更新缓存，维持数据库与缓存的一致性。这也是当前大多数应用缓存框架如SpringCache的工作方式。这种实现非常简单，同步好，但效率一般。</li><li>回写式（WriteBack）：当有数据要写入数据库时，只会更新缓存，然后异步批量的将缓存数据同步到数据库上。这种实现比较复杂，需要较多的应用逻辑，同时可能会产生数据库与缓存的不同步，但效率非常高。</li></ul><h3 id="表分区">表分区</h3><p>MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码。</p><p>对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引。</p><p>用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAINPARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，如下图5条记录落在两个分区上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain partitions select count(1) from user_partition where id in (1,2,3,4,5);</span><br><span class="line">+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line">| id | select_type | table          | partitions | type  | possible_keys | key     | key_len | ref  | rows | Extra                    |</span><br><span class="line">+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | user_partition | p1,p4      | range | PRIMARY       | PRIMARY | 8       | NULL |    5 | Using where; Using index |</span><br><span class="line">+----+-------------+----------------+------------+-------+---------------+---------+---------+------+------+--------------------------+</span><br><span class="line">1row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>分区的好处是：</p><ul><li>可以让单表存储更多的数据</li><li>分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作</li><li>部分查询能够从查询条件确定只落在少数分区上，速度会很快</li><li>分区表的数据还可以分布在不同的物理设备上，从而搞笑利用多个硬件设备</li><li>可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争</li><li>可以备份和恢复单个分区</li></ul><p>分区的限制和缺点：</p><ul><li>一个表最多只能有1024个分区</li><li>如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来</li><li>分区表无法使用外键约束</li><li>NULL值会使分区过滤无效</li><li>所有分区必须使用相同的存储引擎</li></ul><p>分区的类型：</p><ul><li>RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区</li><li>LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择</li><li>HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式</li><li>KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值</li></ul><p>分区适合的场景有：</p><ul><li>最适合的场景数据的时间序列性比较强，则可以按时间来分区，如下所示：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members (</span><br><span class="line">    firstname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    lastname <span class="built_in">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    email <span class="built_in">VARCHAR</span>(<span class="number">35</span>),</span><br><span class="line">    joined <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>( <span class="keyword">YEAR</span>(joined) ) (</span><br><span class="line">    <span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1960</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1970</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1980</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> (<span class="number">1990</span>),</span><br><span class="line">    <span class="keyword">PARTITION</span> p4 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查询时加上时间范围条件效率会非常高，同时对于不需要的历史数据能很容的批量删除。</p><ul><li>如果数据有明显的热点，而且除了这部分数据，其他数据很少被访问到，那么可以将热点数据单独放在一个分区，让这个分区的数据能够有机会都缓存在内存中，查询时只访问一个很小的分区表，能够有效使用索引和缓存</li></ul><p>另外MySQL有一种早期的简单的分区实现 - 合并表（mergetable），限制较多且缺乏优化，不建议使用，应该用新的分区机制来替代</p><h3 id="垂直拆分">垂直拆分</h3><p>垂直分库是根据数据库里面的数据表的相关性进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联</p><p>比如原始的用户表是：</p><img src="/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/640.webp"><p>垂直拆分后是：</p><img src="/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/641.webp"><p>垂直拆分的优点是：</p><ul><li>可以使得行数据变小，一个数据块(Block)就能存放更多的数据，在查询时就会减少I/O次数(每次查询时读取的Block就少)</li><li>可以达到最大化利用Cache的目的，具体在垂直拆分的时候可以将不常变的字段放一起，将经常改变的放一起</li><li>数据维护简单</li></ul><p>缺点是：</p><ul><li>主键出现冗余，需要管理冗余列</li><li>会引起表连接JOIN操作（增加CPU开销）可以通过在业务服务器上进行join来减少数据库压力</li><li>依然存在单表数据量过大的问题（需要水平拆分）</li><li>事务处理复杂</li></ul><h3 id="水平拆分">水平拆分</h3><h4 id="概述">概述</h4><p>水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决</p><p>前面垂直拆分的用户表如果进行水平拆分，结果是：</p><img src="/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/642.webp"><p>实际情况中往往会是垂直拆分和水平拆分的结合，即将Users_A_M和Users_N_Z再拆成Users和UserExtras，这样一共四张表</p><p>水平拆分的优点是:</p><ul><li>不存在单库大数据和高并发的性能瓶颈</li><li>应用端改造较少</li><li>提高了系统的稳定性和负载能力</li></ul><p>缺点是：</p><ul><li>分片事务一致性难以解决</li><li>跨节点Join性能差，逻辑复杂</li><li>数据多次扩展难度跟维护量极大</li></ul><p>分片原则</p><ul><li>能不分就不分，参考单表优化</li><li>分片数量尽量少，分片尽量均匀分布在多个数据结点上，因为一个查询SQL跨分片越多，则总体性能越差，虽然要好于所有数据在一个分片的结果，只在必要的时候进行扩容，增加分片数量</li><li>分片规则需要慎重选择做好提前规划，分片规则的选择，需要考虑数据的增长模式，数据的访问模式，分片关联性问题，以及分片扩容问题，最近的分片策略为范围分片，枚举分片，一致性Hash分片，这几种分片都有利于扩容</li><li>尽量不要在一个事务中的SQL跨越多个分片，分布式事务一直是个不好处理的问题</li><li>查询条件尽量优化，尽量避免Select *的方式，大量数据结果集下，会消耗大量带宽和CPU资源，查询尽量避免返回大量结果集，并且尽量为频繁使用的查询语句建立索引。</li><li>通过数据冗余和表分区赖降低跨库Join的可能</li></ul><p>这里特别强调一下分片规则的选择问题，如果某个表的数据有明显的时间特征，比如订单、交易记录等，则他们通常比较合适用时间范围分片，因为具有时效性的数据，我们往往关注其近期的数据，查询条件中往往带有时间字段进行过滤，比较好的方案是，当前活跃的数据，采用跨度比较短的时间段进行分片，而历史性的数据，则采用比较长的跨度存储。</p><p>总体上来说，分片的选择是取决于最频繁的查询SQL的条件，因为不带任何Where语句的查询SQL，会遍历所有的分片，性能相对最差，因此这种SQL越多，对系统的影响越大，所以我们要尽量避免这种SQL的产生。</p><h3 id="解决方案">解决方案</h3><p>由于水平拆分牵涉的逻辑比较复杂，当前也有了不少比较成熟的解决方案。这些方案分为两大类：客户端架构和代理架构。</p><h4 id="客户端架构">客户端架构</h4><p>通过修改数据访问层，如JDBC、DataSource、MyBatis，通过配置来管理多个数据源，直连数据库，并在模块内完成数据的分片整合，一般以Jar包的方式呈现这是一个客户端架构的例子：</p><img src="/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/643.webp"><p>可以看到分片的实现是和应用服务器在一起的，通过修改SpringJDBC层来实现</p><p>客户端架构的优点是：</p><ul><li>应用直连数据库，降低外围系统依赖所带来的宕机风险</li><li>集成成本低，无需额外运维的组件</li></ul><p>缺点是：</p><ul><li>限于只能在数据库访问层上做文章，扩展性一般，对于比较复杂的系统可能会力不从心</li><li>将分片逻辑的压力放在应用服务器上，造成额外风险</li></ul><h4 id="代理架构">代理架构</h4><p>通过独立的中间件来统一管理所有数据源和数据分片整合，后端数据库集群对前端应用程序透明，需要独立部署和运维代理组件</p><p>这是一个代理架构的例子：</p><img src="/2020/04/09/面试官邪魅一笑：MySQL千万级别大表，你要如何优化？/644.webp"><p>代理组件为了分流和防止单点，一般以集群形式存在，同时可能需要Zookeeper之类的服务组件来管理</p><p>代理架构的优点是：</p><ul><li>能够处理非常复杂的需求，不受数据库访问层原来实现的限制，扩展性强</li><li>对于应用服务器透明且没有增加任何额外负载</li></ul><p>缺点是：</p><ul><li>需部署和运维独立的代理中间件，成本高</li><li>应用需经过代理来连接数据库，网络上多了一跳，性能有损失且有额外风险。</li></ul><blockquote><p>文章转自 <a href="https://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&amp;mid=2247485433&amp;idx=1&amp;sn=a59fd55f75da2c7d85485f9e14ea3146&amp;chksm=fd54d77fca235e69cc26e4ca0470a5d9645ad68749dbd7cd48114ddb7ef3746da2a66abc619a&amp;scene=0&amp;xtrack=1&amp;key=93cf6330e2c3895d7798fbfcc50115f3ce9cc2124f2a02da453a73811d7dc2191eb51b1aef02bd9db9f6af5da064a538f2f01ee8a1a55bacd47fc0d1ce9de5a25ce4d190c43fb4ed63355a692b270176&amp;ascene=14&amp;uin=OTQ3NzYxMTM2&amp;devicetype=Windows+10&amp;version=62090045&amp;lang=zh_CN&amp;exportkey=A2qPhmUra1QLj8SqVzT%2BH%2BA%3D&amp;pass_ticket=68s9wHa3wq3PpjIOxEIv9R1ixVdAGKQSLEGXMCjvnr8f1ToROQg%2FiZUTnu1yKfs%2F" target="_blank" rel="noopener">小哈学Java</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当MySQL单表记录数过大时，增删改查性能都会急剧下降，可以参考以下步骤来优化：&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>vsftpd配置文件详解</title>
    <link href="http://yoursite.com/2020/04/02/vsftpd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/04/02/vsftpd配置文件详解/</id>
    <published>2020-04-02T01:31:10.000Z</published>
    <updated>2022-10-21T06:09:06.229Z</updated>
    
    <content type="html"><![CDATA[<p>yum安装的vsftpd配置文件如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd.conf</span><br></pre></td></tr></table></figure></p><p>1）以“#”字符开始的行是注释行。每一行为一个选项设置，格式为“option=value”，注意“=”号两边不能留空白符。2）除了这个主配置文件外，还可以给特定用户设定个人配置文件</p><a id="more"></a><h3 id="与建立ftp链接相关的选项">1.与建立FTP链接相关的选项</h3><h4 id="监听地址与控制端口">1.1.监听地址与控制端口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listen_address=[IP]        # 提供ftp服务的主机IP，单IP主机，不需要使用，多IP主机默认监听所有IP地址。在VSFTPD使用单独(standalone)模式下有效。</span><br><span class="line">listen_port=[port]         # 提供ftp服务的控制端口号，默认值为21。此选项在standalone模式下生效。</span><br><span class="line">port_enable=YES            # 是否启用ftp主动模式，默认为YES。如果要在数据连接时取消PORT主动模式时，改为NO</span><br><span class="line">connetc_from_port_20=NO    # 以port主动模式进行数据传输时是否使用20端口，默认为NO不使用。但RHEL自带的vsftpd.conf文件中此参数设为YES。</span><br><span class="line">ftp_data_port=[port]       # 指定ftp数据传输端口值，默认为20。此参数用于主动模式。</span><br><span class="line">port_promiscuous=NO        # 取消PORT安全检查，默认为NO不取消检查。该检查确保外出的数据只能连接到客户端上。不建议打开</span><br><span class="line">pasv_enable=YES            # 允许数据传输时使用PASV被动模式。默认为YES允许被动模式</span><br><span class="line">pasv_min_port=[minport]</span><br><span class="line">pasv_max_port=[maxport]    # 设定在PASV被动模式下，建立数据传输所可以使用port范围的下界和上界，默认为0不限制。</span><br><span class="line">　　　　　　　　　　　　　　   # 把端口范围设在比较高的一段范围内，比如50000-60000，将有助于安全性的提高。</span><br><span class="line">pasv_promiscuous=NO        # 是否关闭PASV模式的安全检查，默认值为NO不关闭。该检查确保数据连接和控制连接是来自同一个IP地址。不建议打开，此选项唯一合理的用法是存在于由安全隧道方案构成的组织中。</span><br><span class="line">pasv_address=[IP]          # 此选项为一个数字IP地址，作为PASV命令的响应。默认值为none，即地址是从呼入的连接套接字(incomingconnectdsocket)中获取。</span><br></pre></td></tr></table></figure><h4 id="关于ftp服务的ascii模式">1.2.关于ftp服务的ASCII模式</h4><p>默认情况下，VSFTPD使用二进制传输数据，禁止使用ASCII传输模式。如果FTP客户端使用ascii命令，指明要使用ASCII模式，VSFTPD表面上接受了ascii命令，但在实际传输文件时，还是使用二进制方式，就会出现乱码文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ascii_upload_enable=NO     #控制是否允许使用ascii模式上传文件，默认为NO不允许。</span><br><span class="line">ascii_download_enable=NO   # 控制是否允许使用ascii模式下载文件，默认为NO不允许。</span><br></pre></td></tr></table></figure></p><h3 id="关于性能与负载控制">2.关于性能与负载控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">idle_session_timeout=60      # 设置用户会话的空闲中断时间，单位为秒，默认值为300。</span><br><span class="line">data_connection_timeout=120  # 设置空闲的数据连接的中断时间。默认值为300秒。</span><br><span class="line">accept_timeout=60            # 接受建立联机的超时设定，单位为秒。默认值为60。</span><br><span class="line">connect_timeout=60           # 响应PORT方式的数据联机的超时设定，单位为秒。默认值为60。</span><br><span class="line">　　　　　　　　　　　　　　　　　# 以上两个选项针对客户端的，将使客户端空闲1分钟后自动中断连接，并在中断1分钟后自动激活连接。</span><br><span class="line">max_clients=200              # 指明服务器总的客户并发连接数为200，默认值为0，表示不限最大连接数。此参数在使用standalone模式下有效</span><br><span class="line">max_per_ip=3                 # 指明每个IP地址的并发连接数，默认值为0不限制。该设置会影响到象网际快车这类的多进程下载软件。此参数在使用standalone模式下有效</span><br><span class="line">local_max_rate=50000         # 设置本地用户的最大传输速率限制（50kbytes/sec），以Bytes/s为单位。默认0不限制。此选项可以为指定用户单独设置</span><br><span class="line">anon_max_rate=30000          # 设定匿名用户的最大数据传输速度value，以Bytes/s为单位。默认0不限制</span><br><span class="line">pasv_min_port=50000          # 设置被动模式客户端连接时的端口范围，默认为0不限制</span><br><span class="line">pasv_max_port=60000</span><br></pre></td></tr></table></figure><h3 id="用户选项">3.用户选项</h3><p>VSFTPD的用户分为三类：匿名用户、本地用户（localuser）以及虚拟用户</p><h4 id="匿名用户">3.1.匿名用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">anonymous_enable=YES|NO      # 控制是否允许匿名用户登录，默认值为YES允许匿名用户登录。</span><br><span class="line">ftp_username=                # 匿名用户所使用的系统用户名。默认此参数在配置文件中不出现，值为ftp。</span><br><span class="line">no_anon_password=NO          # 控制匿名用户登入时是否需要密码，默认值为NO需要密码。</span><br><span class="line">deny_email_enable=NO         # 拒绝在banned_email_file指定的文件中所列出的email地址进行登录的匿名用户。默认值为NO关闭。这对于阻击某些Dos攻击有效。如果开启需要追加以下配置</span><br><span class="line">banned_email_file=/etc/banned_emails.conf    # 当匿名用户使用banned_email_file文件中所列出的e-mail进行登录时，被拒绝</span><br><span class="line">指定包含被拒绝的e-mail地址的文件，默认文件为/etc/vsftpd.banned_emails。</span><br><span class="line">anon_root=                   # 匿名用户的根目录，默认为/var/ftp/，主配置文件中默认无此项。</span><br><span class="line">anon_world_readable_only=YES # 默认值为YES只允许匿名用户下载可阅读的文件。NO允许匿名用户浏览整个服务器的文件</span><br><span class="line">anon_upload_enable=NO        # 是否允许匿名用户上传文件，默认NO不允许。</span><br></pre></td></tr></table></figure><p>除了anon_upload_enable这个参数外，匿名用户要能上传文件，还需要两个条件：</p><p>1）write_enable参数为YES;2）在文件系统上，FTP匿名用户对某个目录有写权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">anon_mkdir_write_enable=NO   # 是否允许匿名用户创建新目录，默认为NO不允许，同时FTP匿名用户必需对新目录的上层目录拥有写权限。</span><br><span class="line">anon_other_write_enable=NO   # 匿名用户是否拥有除了上传和新建目录之外的其他权限，如删除、更名等。默认为NO不拥有</span><br><span class="line">chown_uploads=NO             # 是否修改匿名用户所上传文件的所有权。默认值为NO不修改。如果改为YES匿名用户所上传的文件的所有权将改为另外一个不同的用户所有</span><br><span class="line">chown_username=whoever       # 指定拥有匿名用户上传文件所有权的用户。此参数与chown_uploads联用。不推荐使用root用户。</span><br></pre></td></tr></table></figure><h4 id="本地用户">3.2.本地用户</h4><p>在使用FTP服务的用户中，除了匿名用户外，还有一类在FTP服务器所属主机上拥有账号的用户。VSFTPD中称此类用户为本地用户（localuser），等同于其他FTP服务器中的real用户。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_enable=YES             # 本地系统用户是否可以登陆，默认值为YES。</span><br><span class="line">local_root=                  # 定义所有本地用户的根目录。默认为空，本地用户登录到自己的宿主目录</span><br><span class="line">user_config_dir=/etc/vsftpd/user.d    # 定义用户个人配置文件所在的目录，配置文件名为用户名，配置格式与vsftpd.conf相同。默认为无不单独设置用户权限，虚拟用户也用这个</span><br></pre></td></tr></table></figure></p><h4 id="虚拟用户">3.3.虚拟用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">guest_enable=NO        　　　 # 若是启动这项功能，所有的非匿名登入者都视为guest，默认值为NO关闭。如果要使用ftp虚拟用户需要启用</span><br><span class="line">guest_username=        　　　 # 定义VSFTPD的guest用户在系统中的用户名。默认值为ftp，在使用ftp虚拟用户时建议自定义，例如ftpvuser</span><br></pre></td></tr></table></figure><h3 id="安全措施">4.安全措施</h3><h4 id="用户登录控制">4.1.用户登录控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/vsftpd/ftpusers         # 改配置文件中的用户禁止登录FTP服务器。这个机制是在/etc/pam.d/vsftpd中默认设置的。</span><br><span class="line">pam_service_name=vsftpd      # 指定vsftpd进行PAM认证时所使用的PAM配置文件名，默认值是vsftpd，默认PAM配置文件是/etc/pam.d/vsftpd，使用ftp虚拟用户时需要更改</span><br><span class="line">userlist_enable=NO           # 是否通过userlist_file列表控制可登陆的用户，默认为NO不启用，如果启用，列表中的用户默认拒绝登录FTP服务器，在输入用户名后，不提示输入密码</span><br><span class="line">userlist_deny=YES            # 决定禁止还是允许userlist_file指定文件中的用户登录FTP服务器，默认为YES禁止文件中的用户登录，此选项在userlist_enable选项启动后才生效，如果要允许在文件中的用户登录FTP服务器需要改为NO</span><br><span class="line">userlist_file=/etc/vsftpd/user_list    # userlist_enable选项指定的用户列表的文件。默认为/etc/vsftpd/user_list。</span><br><span class="line">tcp_wrappers=YES             # 在vsftpd中使用TCP_Wrappers封装数据，默认值为YES。</span><br></pre></td></tr></table></figure><h3 id="目录访问控制">4.2.目录访问控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chroot_list_enable=NO        # 是否锁定用户在其宿主目录中，默认值为NO不锁定。具体的用户在chroot_list_file参数所指定的文件中列出。</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list    # 指定要锁定在宿主目录中的用户，默认不设置。一行一用户，通常为/etc/vsftpd/chroot_list</span><br><span class="line">chroot_local_users=NO        # 将本地用户锁定在其宿主目录中，默认值为NO不锁定。</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">当chroot_local_users被激活时，chroot_list_enable和chroot_local_users参数的作用将发生变化，chroot_list_file所指定文件中的用户将不被锁定在自家目录。</span><br><span class="line">可能带来安全上的冲突，特别是当用户拥有上传、shell访问等权限时。</span><br><span class="line"></span><br><span class="line">passwd_chroot_enable=NO      # 当此选项需与chroot_local_user配合，chroot()容器的位置可以在每个用户的基础上指定。每个用户的容器来源于/etc/passwd中每个用户的自家目录字段。默认值为NO。</span><br></pre></td></tr></table></figure><h4 id="文件操作控制">4.3.文件操作控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hide_ids=YES|NO              # 是否隐藏文件的所有者和组信息。默认值为NO不隐藏，如果为YES，当用户使用&quot;ls -al&quot;之类的指令时，在目录列表中所有文件的拥有者和组信息都显示为ftp</span><br><span class="line">ls_recurse_enable=YES|NO     # 是否允许使用&quot;ls-R&quot;指令，默认值为NO不允许。如果在一个大型FTP站点的根目录下使用&quot;ls-R&quot;会消耗大量系统资源。</span><br><span class="line">write_enable=YES|NO          # 是否允许使用修改文件系统的FTP的指令，默认为NO不允许，比如STOR、DELE、RNFR、RNTO、MKD、RMD、APPE以及SITE</span><br><span class="line">secure_chroot_dir=           # 安全沙箱目录，指向一个ftp用户无写权限的空目录，默认为/usr/share/empty。当vsftpd不需要访问文件系统时，这个目录将被作为一个安全的容器，用户将被限制在此目录中。</span><br><span class="line">anon_umask=                  # 匿名用户新增文件的umask数值。默认值为077。</span><br><span class="line">file_open_mode=              # 上传文件的权限，默认值为0666。与chmod所使用的数值相同。如果希望上传的文件可以执行，设此值为0777。</span><br><span class="line">local_umask=                 # 本地用户新增文件时的umask数值，默认值为077。如果希望新增的文件他人可以访问的话，修改为022</span><br></pre></td></tr></table></figure><h3 id="提示信息">5.提示信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ftpd_banner=welcome          # 此参数定义了登录欢迎语，预设值为无，可修改</span><br><span class="line">banner_file=/etc/vsftpd/banner_file    # 当用户登录时会显示此文件中的内容，通常为欢迎话语或是说明。默认值为无。</span><br><span class="line">　　　　　　　　　　　　　　　　　# 与ftpd_banner相比，banner_file是文本文件的形式，而ftpd_banner是字串格式。banner_file选项将取代ftpd_banner选项。</span><br><span class="line">dirmessage_enable=YES        # 特定目录的提示信息，默认为YES启用。当用户进入指定目录，如果该目录下存在message_file指定的文件，则显示出现此文档的内容，通常这个文档会放置欢迎话语，或是对该目录的说明。</span><br><span class="line">message_file=                # dirmessage_enable选项启用时生效，指定提示内容的文档。默认为.message，以该扩展名结尾的文件</span><br></pre></td></tr></table></figure><h3 id="日志设置">6.日志设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xferlog_enable=NO            # 是否启用一个日志文件，记录上传和下载，默认为NO不启用，该日志文件由xferlog_file选项指定</span><br><span class="line">xferlog_file=/var/log/vsftpd.log    # 记录ftp日志。默认为/var/log/vsftpd.log</span><br><span class="line">xferlog_std_format=NO        # 日志文件格式是否使用xferlog的标准格式，默认为NO不使用。默认的日志格式更为可读性，使用xferlog格式可以使用已经存在的传输统计生成器。</span><br><span class="line">log_ftp_protocol=NO          # 是否记录所有的FTP请求和响应到日志中，这个选项一般用于调试，默认为NO不记录。使用此选项时xferlog_std_format不能被激活</span><br></pre></td></tr></table></figure><h3 id="其他设置">7.其他设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setproctitle_enable=NO       # 是否在系统进程列表中显示每个会话(session)的状态，默认为NO不显示。包括挂起、下载等</span><br><span class="line">text_userdb_names=No         # 用户使用ls -al命令时，列表信息是否显示拥有者名称而不是UID，默认为NO不显示</span><br><span class="line">use_localtime=NO             # vsftpd显示目录列表时是否使用服务器本地时区的时间。默认为NO显示GMT时间，建议修改为YES。由ftp命令“MDTM”返回的时间值也受此选项影响。</span><br><span class="line">check_shell=YES              # 本地用户登录时vsftpd是否检查/etc/shells文件以寻找一个有效的用户shell。默认为YES。此选项仅对不使用PAM方式的VSFTPD生效。</span><br><span class="line">nopriv_user=nobody           # 指定一个专用的除nobody以外的用户，当VSFTPD不想要什么权限时，使用此用户身份。默认值为nobody，如果使用建议修改，因为在大多数的机器上，nobody用户被用于大量重要的事情</span><br><span class="line">pam_service_name=            # 指明vsftpd使用用PAM验证服务时的PAM配置文件名。默认值为ftp。</span><br></pre></td></tr></table></figure><blockquote><p>文章转载来自<a href="https://www.cnblogs.com/tssc/p/9592600.html" target="_blank" rel="noopener">https://www.cnblogs.com/tssc/p/9592600.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;yum安装的vsftpd配置文件如下： &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;vim /etc/vsftpd/vsftpd.conf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1）以“#”字符开始的行是注释行。每一行为一个选项设置，格式为“option=value”，注意“=”号两边不能留空白符。
2）除了这个主配置文件外，还可以给特定用户设定个人配置文件&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="vsftpd" scheme="http://yoursite.com/tags/vsftpd/"/>
    
  </entry>
  
</feed>
