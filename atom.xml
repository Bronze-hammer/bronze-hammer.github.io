<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐子辉的个人站点</title>
  
  <subtitle>在总结中一步步提升自己，要善于总结，好记性不如烂笔头.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-11-01T06:41:15.416Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xuzh</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arrays.binarySearch()方法详解</title>
    <link href="http://yoursite.com/2023/09/05/Arrays-binarySearch-%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2023/09/05/Arrays-binarySearch-方法详解/</id>
    <published>2023-09-05T09:14:19.000Z</published>
    <updated>2023-11-01T06:41:15.416Z</updated>
    
    <content type="html"><![CDATA[<p>背景：我想校验一个指定的String字符串，是否存在于另一个String数组中，选择<code>Arrays.binarySearch()</code>方法实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String[] item = &#123;<span class="string">"0"</span>,<span class="string">"1"</span>,<span class="string">"16"</span>,<span class="string">"1591"</span>,<span class="string">"1594"</span>,<span class="string">"1596"</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (Arrays.binarySearch(item, <span class="string">"1591"</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"exists"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"not exists"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not exists</span><br></pre></td></tr></table></figure><p>很直观的能看到item数组里面存在字符串<code>1591</code>，为什么程序运行的结果却是找不到该元素呢？</p><a id="more"></a><p>首先来看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Searches the specified array for the specified object using the binary</span></span><br><span class="line"><span class="comment"> * search algorithm. The array must be sorted into ascending order</span></span><br><span class="line"><span class="comment"> * according to the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125;</span></span><br><span class="line"><span class="comment"> * of its elements (as by the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #sort(Object[])&#125; method) prior to making this call.</span></span><br><span class="line"><span class="comment"> * If it is not sorted, the results are undefined.</span></span><br><span class="line"><span class="comment"> * (If the array contains elements that are not mutually comparable (for</span></span><br><span class="line"><span class="comment"> * example, strings and integers), it &lt;i&gt;cannot&lt;/i&gt; be sorted according</span></span><br><span class="line"><span class="comment"> * to the natural ordering of its elements, hence results are undefined.)</span></span><br><span class="line"><span class="comment"> * If the array contains multiple</span></span><br><span class="line"><span class="comment"> * elements equal to the specified object, there is no guarantee which</span></span><br><span class="line"><span class="comment"> * one will be found.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array to be searched</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the value to be searched for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> index of the search key, if it is contained in the array;</span></span><br><span class="line"><span class="comment"> *         otherwise, &lt;tt&gt;(-(&lt;i&gt;insertion point&lt;/i&gt;) - 1)&lt;/tt&gt;.  The</span></span><br><span class="line"><span class="comment"> *         &lt;i&gt;insertion point&lt;/i&gt; is defined as the point at which the</span></span><br><span class="line"><span class="comment"> *         key would be inserted into the array: the index of the first</span></span><br><span class="line"><span class="comment"> *         element greater than the key, or &lt;tt&gt;a.length&lt;/tt&gt; if all</span></span><br><span class="line"><span class="comment"> *         elements in the array are less than the specified key.  Note</span></span><br><span class="line"><span class="comment"> *         that this guarantees that the return value will be &amp;gt;= 0 if</span></span><br><span class="line"><span class="comment"> *         and only if the key is found.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the search key is not comparable to the</span></span><br><span class="line"><span class="comment"> *         elements of the array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(Object[] a, Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, <span class="number">0</span>, a.length, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，注释上提到了两个重点：</p><ol type="1"><li>使用二分查找算法在指定数组中搜索指定对象；</li><li>在调用此方法之前，必须根据元素的自然顺序(如通过sort(Object[])方法)将数组按升序排序。</li></ol><p>也就是说，数组不是遍历每一个元素，与目标值做对比，校验是否相同，而是通过二分查找算法，先找到数组中间的元素，与目标值做比较：如果目标值大于中间值，则继续比较数组后半部分的元素；如果目标值小于中间值，则继续比较数组前半部分的元素；如果等于，那么就直接返回中间元素的数组下标。因此在调用此方法之前，要先对数组进行升序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(Object[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">        Comparable midVal = (Comparable)a[mid];</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中，是中间值通过<code>(low + high) &gt;&gt;&gt; 1</code>的方式获取的。</p><p>这是一个在二分查找算法中常见的代码片段。low 和 high通常表示搜索范围的下界和上界。mid 是下界和上界的中间值，通过 (low +high) &gt;&gt;&gt; 1 计算得出。</p><p>这是由于在Java中，+运算符对于整数是按照整数算术运算（即舍去小数点）来执行的。这可能会导致整数的溢出。例如，如果low 是 -1000000000，而 high 是 1000000000，那么 low + high 的结果将会是-999999999 + 1000000000，这将导致整数溢出。</p><p>而使用&gt;&gt;&gt;（无符号右移运算符）则可以避免这个问题。位运算中，右移运算符&gt;&gt;对于负数会将移位后的左侧填充部分填充为该数的符号位（即负数的话填充为1，正数的话填充为0）。而&gt;&gt;&gt;是无符号右移运算符，无论该数是正数还是负数，都会将左侧填充部分填充为0。</p><p>所以 (low + high) &gt;&gt;&gt; 1 的结果就是 low + high的值除以2的整数部分，无论 low 和 high 的值是多少。</p><p>拿到数组的中间元素后，通过<code>int cmp = midVal.compareTo(key)</code>的方法比较中间元素和目标值。</p><p>compareTo() 方法按字典顺序比较两个字符串（比较基于字符串中每个字符的Unicode 值）。</p><p>接下来回到最开始的问题中，通过调试发现，中间元素<code>16</code>与目标值<code>1591</code>比较，结果cmp=1，也就是说比较的结果居然是<code>16</code>大于<code>1591</code>。</p><img src="/2023/09/05/Arrays-binarySearch-方法详解/微信截图_20230905182124.png"><p>由于比较的结果大于0，因此<code>mid-1</code>，接下来会拿数组左边部分的值与目标值做对比，而<code>16</code>左边的几个元素不存在<code>1591</code>，因此最终结果是在数组中找不到与目标值一致的元素。</p><p>这是因为，<code>16</code>和<code>1591</code>都是字符串类型，而非数值类型，字符串类型通过<code>compareTo()</code>方法进行比较，是比较两个字符串相应位置字符的Unicode值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Compares two strings lexicographically.</span></span><br><span class="line"><span class="comment"> * The comparison is based on the Unicode value of each character in</span></span><br><span class="line"><span class="comment"> * the strings. The character sequence represented by this</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> String&#125; object is compared lexicographically to the</span></span><br><span class="line"><span class="comment"> * character sequence represented by the argument string. The result is</span></span><br><span class="line"><span class="comment"> * a negative integer if this &#123;<span class="doctag">@code</span> String&#125; object</span></span><br><span class="line"><span class="comment"> * lexicographically precedes the argument string. The result is a</span></span><br><span class="line"><span class="comment"> * positive integer if this &#123;<span class="doctag">@code</span> String&#125; object lexicographically</span></span><br><span class="line"><span class="comment"> * follows the argument string. The result is zero if the strings</span></span><br><span class="line"><span class="comment"> * are equal; &#123;<span class="doctag">@code</span> compareTo&#125; returns &#123;<span class="doctag">@code</span> 0&#125; exactly when</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method would return &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This is the definition of lexicographic ordering. If two strings are</span></span><br><span class="line"><span class="comment"> * different, then either they have different characters at some index</span></span><br><span class="line"><span class="comment"> * that is a valid index for both strings, or their lengths are different,</span></span><br><span class="line"><span class="comment"> * or both. If they have different characters at one or more index</span></span><br><span class="line"><span class="comment"> * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string</span></span><br><span class="line"><span class="comment"> * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as</span></span><br><span class="line"><span class="comment"> * determined by using the &amp;lt; operator, lexicographically precedes the</span></span><br><span class="line"><span class="comment"> * other string. In this case, &#123;<span class="doctag">@code</span> compareTo&#125; returns the</span></span><br><span class="line"><span class="comment"> * difference of the two character values at position &#123;<span class="doctag">@code</span> k&#125; in</span></span><br><span class="line"><span class="comment"> * the two string -- that is, the value:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * this.charAt(k)-anotherString.charAt(k)</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> * If there is no index position at which they differ, then the shorter</span></span><br><span class="line"><span class="comment"> * string lexicographically precedes the longer string. In this case,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> compareTo&#125; returns the difference of the lengths of the</span></span><br><span class="line"><span class="comment"> * strings -- that is, the value:</span></span><br><span class="line"><span class="comment"> * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * this.length()-anotherString.length()</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   anotherString   the &#123;<span class="doctag">@code</span> String&#125; to be compared.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  the value &#123;<span class="doctag">@code</span> 0&#125; if the argument string is equal to</span></span><br><span class="line"><span class="comment"> *          this string; a value less than &#123;<span class="doctag">@code</span> 0&#125; if this string</span></span><br><span class="line"><span class="comment"> *          is lexicographically less than the string argument; and a</span></span><br><span class="line"><span class="comment"> *          value greater than &#123;<span class="doctag">@code</span> 0&#125; if this string is</span></span><br><span class="line"><span class="comment"> *          lexicographically greater than the string argument.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引申：但是要注意的是，这只适用于两个字符都属于基本字母或数字的情况。如果字符包含其他字符（比如特殊字符、标点符号等），或者涉及非数字字符，那么结果可能不会如你所预期。例如，如果'A'和'中'（Unicode值为65296）进行相减，结果将会是-38321，这显然不是我们期望的结果。因此，在进行这种操作时，一定要确保字符的取值范围和你的预期相符。</p></blockquote><p>至此，文章开头 <code>1591</code>为什么在目标数组中<code>{"0","1","16","1591","1594","1596"}</code>匹配不到的问题，原因就是如此。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背景：我想校验一个指定的String字符串，是否存在于另一个String数组中，选择&lt;code&gt;Arrays.binarySearch()&lt;/code&gt;方法实现，代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;String[] item = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;16&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;1591&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;1594&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;1596&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Arrays.binarySearch(item, &lt;span class=&quot;string&quot;&gt;&quot;1591&quot;&lt;/span&gt;) &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;exists&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;not exists&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;not exists&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很直观的能看到item数组里面存在字符串&lt;code&gt;1591&lt;/code&gt;，为什么程序运行的结果却是找不到该元素呢？&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>泛型以及如何绕过泛型定义</title>
    <link href="http://yoursite.com/2023/08/28/%E6%B3%9B%E5%9E%8B%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E6%B3%9B%E5%9E%8B%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2023/08/28/泛型以及如何绕过泛型定义/</id>
    <published>2023-08-28T08:50:01.000Z</published>
    <updated>2023-08-28T08:59:09.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型定义以及其带来的好处">泛型定义以及其带来的好处</h1><p>泛型使类型（类和接口）能够在定义类、接口和方法时成为参数。与方法声明中使用的更熟悉的形式参数非常相似，类型参数为您提供了一种通过不同输入重复使用相同代码的方法。区别在于形式参数的输入是值，而类型参数的输入是类型。</p><p>使用泛型的代码比非泛型代码有很多好处：</p><ol type="1"><li>编译时更强的类型检查。 Java编译器对泛型代码应用强类型检查，如果代码违反类型安全，则会发出错误。修复编译时错误比修复运行时错误更容易，后者很难发现。</li></ol><a id="more"></a><ol start="2" type="1"><li>避免类型转换</li></ol><p>以下没有泛型的代码片段需要强制转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = (String) list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当重写为使用泛型时，代码不需要转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">String s = list.get(<span class="number">0</span>);   <span class="comment">// no cast</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>使程序员能够实现通用算法。通过使用泛型，程序员可以实现适用于不同类型集合的泛型算法，可以自定义，并且类型安全且更易于阅读。</li></ol><h1 id="绕过泛型定义">绕过泛型定义</h1><p>使用反射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"aa"</span>);</span><br><span class="line">    list.add(<span class="string">"bb"</span>);</span><br><span class="line">    Class clazz = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line">    Method method = clazz.getMethod(<span class="string">"add"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    method.invoke(list, <span class="number">123</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[aa, bb, 123]</span><br></pre></td></tr></table></figure><p>注意：</p><p>如果通过循环遍历输出list的元素，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String str : list) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(p -&gt; System.out.println(p));</span><br></pre></td></tr></table></figure><p>就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1382)</span><br><span class="line">at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580)</span><br><span class="line">at com.springcloud.business.controller.BusinessController.main(BusinessController.java:45)</span><br></pre></td></tr></table></figure><p>这是因为遍历的时候，会把集合里的元素拿出来，作为泛型定义的<code>String</code>类型输出，而我们通过反射添加了一个<code>Integer</code>类型的值，因此造成类型转换错误。</p><p>除非我们这样遍历输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Object str : list) &#123;</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">123</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;泛型定义以及其带来的好处&quot;&gt;泛型定义以及其带来的好处&lt;/h1&gt;
&lt;p&gt;泛型使类型（类和接口）能够在定义类、接口和方法时成为参数。与方法声明中使用的更熟悉的形式参数非常相似，类型参数为您提供了一种通过不同输入重复使用相同代码的方法。区别在于形式参数的输入是值，而类型参数的输入是类型。&lt;/p&gt;
&lt;p&gt;使用泛型的代码比非泛型代码有很多好处：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;编译时更强的类型检查。 Java
编译器对泛型代码应用强类型检查，如果代码违反类型安全，则会发出错误。修复编译时错误比修复运行时错误更容易，后者很难发现。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>判断两个相同类型对象的值是否相等</title>
    <link href="http://yoursite.com/2023/08/25/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <id>http://yoursite.com/2023/08/25/判断两个相同类型对象的值是否相等/</id>
    <published>2023-08-25T07:21:34.000Z</published>
    <updated>2023-08-25T07:55:24.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="double类型">1.Double类型</h1><p>在Java中，将两个double值转换为String类型，然后使用equals方法进行比较是一个常见的做法，但是这种方法并不是完全可靠，特别是在涉及浮点数的精度时仍然可能会遇到问题。</p><p>浮点数在内部以二进制表示，有时会存在舍入误差，这可能会导致两个在数值上非常接近的浮点数在转换为字符串后变得稍有不同。因此，尽管你可以使用字符串比较来避免直接比较浮点数时的精度问题，但这种方法并不是绝对可靠的。</p><a id="more"></a><p>以下是一个示例，展示了使用字符串比较来判断两个double值是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleStringComparison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">        String xStr = Double.toString(x);</span><br><span class="line">        String yStr = Double.toString(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xStr.equals(yStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"They are equal."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"They are not equal."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方法可以避免直接比较浮点数时的精度问题，但是需要注意的是，由于字符串表示法可能会引入额外的舍入或转换误差，因此在某些情况下，仍然可能会得到错误的结果。</p><p>在许多编程语言中，使用浮点数（例如double类型）进行相等性比较时可能会遇到精度问题。由于浮点数的存储方式和精度表示的特性，直接比较两个浮点数是否相等可能会导致意外的结果。因此，在判断两个double类型的值是否相等时，应该使用一些容忍误差的方法。</p><p>一种常见的方法是使用一个很小的阈值（epsilon）来比较两个浮点数的差异，如果它们的差异小于这个阈值，则认为它们是相等的。这个阈值通常取决于你的应用场景和需要的精度。</p><p>以下是一个Java示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleComparison</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areEqual</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> epsilon)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(a - b) &lt; epsilon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">        <span class="keyword">double</span> y = <span class="number">0.3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> epsilon = <span class="number">1e-9</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (areEqual(x, y, epsilon)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"They are equal."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"They are not equal."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，epsilon的值取决于你的具体情况，你可能需要根据浮点数的大小范围和精度需求来调整这个值。这个方法可以帮助你避免由于浮点数的精度问题而产生的误判。在其他编程语言中也可以使用类似的方法来进行浮点数的相等性比较。</p><h1 id="string类型">2.String类型</h1><p>判断两个字符串是否相同，可用于判断一个字段在逻辑处理前后，值是否有变化。</p><p>其中重点是要考虑两个字符串是否有为null的情况，如果其中一个，或者两个都为空，用<code>str1.equals(str2)</code>直接判断，就会报<code>NullPointerException</code>的错误。</p><p>所以可用采用下面方法进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">areEqual</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str1 == <span class="keyword">null</span> &amp;&amp; str2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str1 == <span class="keyword">null</span> || str2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str1.equals(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果两个字符串同时为null，可以认为两个字符串是一样的，或者字符串的值没有变化；</li><li>排除两个字符串都为null的情况，如果其中一个字符串为null，那么两个字符串的值就不一致；</li><li>最后在确定两个字符串都不为null，那么就可以使用<code>equals()</code>进行判断。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;double类型&quot;&gt;1.Double类型&lt;/h1&gt;
&lt;p&gt;在Java中，将两个double值转换为String类型，然后使用equals方法进行比较是一个常见的做法，但是这种方法并不是完全可靠，特别是在涉及浮点数的精度时仍然可能会遇到问题。&lt;/p&gt;
&lt;p&gt;浮点数在内部以二进制表示，有时会存在舍入误差，这可能会导致两个在数值上非常接近的浮点数在转换为字符串后变得稍有不同。因此，尽管你可以使用字符串比较来避免直接比较浮点数时的精度问题，但这种方法并不是绝对可靠的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Double - String" scheme="http://yoursite.com/tags/Double-String/"/>
    
  </entry>
  
  <entry>
    <title>MySQL行转列函数</title>
    <link href="http://yoursite.com/2023/08/25/MySQL%E8%A1%8C%E8%BD%AC%E5%88%97%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2023/08/25/MySQL行转列函数/</id>
    <published>2023-08-25T07:10:12.000Z</published>
    <updated>2023-08-25T07:25:27.177Z</updated>
    
    <content type="html"><![CDATA[<h1 id="group_concat函数">GROUP_CONCAT()函数</h1><p>创建表<code>person_info</code>，并插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`family`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">8</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'张三'</span>, <span class="string">'张三爸'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'张三'</span>, <span class="string">'张三妈'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'李四爸'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'李四妈'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'李四大哥'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'王二'</span>, <span class="string">'王二爷爷'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_info (<span class="keyword">name</span>, family) <span class="keyword">VALUES</span>(<span class="string">'王二'</span>, <span class="string">'王二姐姐'</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><table><thead><tr class="header"><th>id</th><th>name</th><th>family</th></tr></thead><tbody><tr class="odd"><td>1</td><td>张三</td><td>张三爸</td></tr><tr class="even"><td>2</td><td>张三</td><td>张三妈</td></tr><tr class="odd"><td>3</td><td>李四</td><td>李四爸</td></tr><tr class="even"><td>4</td><td>李四</td><td>李四妈</td></tr><tr class="odd"><td>5</td><td>李四</td><td>李四大哥</td></tr><tr class="even"><td>6</td><td>王二</td><td>王二爷爷</td></tr><tr class="odd"><td>7</td><td>王二</td><td>王二姐姐</td></tr></tbody></table><p>语法： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GROUP_CONCAT([DISTINCT] expr [,expr ...]</span><br><span class="line">             [ORDER BY &#123;unsigned_integer | col_name | expr&#125;</span><br><span class="line">                 [ASC | DESC] [,col_name ...]]</span><br><span class="line">             [SEPARATOR str_val])</span><br></pre></td></tr></table></figure></p><p>示例： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, <span class="keyword">GROUP_CONCAT</span>(family SEPARATOR <span class="string">'&amp;'</span>) <span class="keyword">AS</span> familys <span class="keyword">FROM</span> person_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure></p><p>结果：</p><img src="/2023/08/25/MySQL行转列函数/微信截图_20230823102642.png"><p>可以看看我上篇写的关于GROUP_CONCAT()的文章<a href="https://blog.csdn.net/bronzehammer/article/details/132319248?spm=1001.2014.3001.5501" target="_blank" rel="noopener">【笔记】MySQL数据库GROUP_CONCAT()函数输出结果的长度限制</a></p><h1 id="case函数">CASE函数</h1><p>MySQL中的CASE表达式不是行转列函数。它是一种条件表达式，用于根据条件对数据进行选择、计算和转换。</p><p>然而，你可以使用CASE表达式来实现行转列的效果。通过在CASE表达式中定义不同的条件和相应的结果，你可以将行的数据按照不同的条件拆分到不同的列中。</p><p>创建表<code>person_grade</code>，并插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`person_grade`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`subject`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`mark`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">5</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_grade (<span class="keyword">name</span>, subject, mark) <span class="keyword">VALUES</span>(<span class="string">'张三'</span>, <span class="string">'数学'</span>, <span class="number">66</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_grade (<span class="keyword">name</span>, subject, mark) <span class="keyword">VALUES</span>(<span class="string">'张三'</span>, <span class="string">'语文'</span>, <span class="number">99</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_grade (<span class="keyword">name</span>, subject, mark) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'数学'</span>, <span class="number">77</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> niffler.person_grade (<span class="keyword">name</span>, subject, mark) <span class="keyword">VALUES</span>(<span class="string">'李四'</span>, <span class="string">'政治'</span>, <span class="number">80</span>);</span><br></pre></td></tr></table></figure><table><thead><tr class="header"><th>id</th><th>name</th><th>subject</th><th>mark</th></tr></thead><tbody><tr class="odd"><td>1</td><td>张三</td><td>数学</td><td>66</td></tr><tr class="even"><td>2</td><td>张三</td><td>语文</td><td>99</td></tr><tr class="odd"><td>3</td><td>李四</td><td>数学</td><td>77</td></tr><tr class="even"><td>4</td><td>李四</td><td>政治</td><td>80</td></tr></tbody></table><p>以subject列为表头，展示每个人的成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> , </span><br><span class="line">(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'数学'</span> ,</span><br><span class="line">(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'语文'</span> ,</span><br><span class="line">(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'政治'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'政治'</span> </span><br><span class="line"><span class="keyword">from</span> person_grade;</span><br></pre></td></tr></table></figure><p>结果</p><img src="/2023/08/25/MySQL行转列函数/微信截图_20230823132128.png"><p>确实是按照subject列作为表头展示了成绩，但是每条成绩都占用一行，那么如何把同一个人的成绩都在一行展示呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> , </span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'数学'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'数学'</span> ,</span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'语文'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'语文'</span> ,</span><br><span class="line"><span class="keyword">MAX</span>(<span class="keyword">case</span> subject <span class="keyword">when</span> <span class="string">'政治'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">'政治'</span> </span><br><span class="line"><span class="keyword">from</span> person_grade</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span> ;</span><br></pre></td></tr></table></figure><p>结果</p><img src="/2023/08/25/MySQL行转列函数/微信截图_20230823132414.png"><blockquote><p>上面的脚本，把MAX函数换成SUM函数，效果一样；除了CASE函数，也可使用IF函数实现行转列的效果。</p></blockquote><h1 id="group_concat和case结合实现动态行转列">GROUP_CONCAT()和CASE()结合实现动态行转列</h1><p>通过CASE()函数的例子可以看到，表头行字段<code>数学</code>、<code>语文</code>、<code>政治</code>都是我们提前已经知晓并且手动指定的，那么如果我们事先不知道有哪些表头字段，怎么办呢？</p><p>可以通过下面的脚本实现：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">DISTINCT</span></span><br><span class="line">    <span class="keyword">CONCAT</span>(</span><br><span class="line">      <span class="string">'max(case when subject = '''</span>,</span><br><span class="line">      subject,</span><br><span class="line">      <span class="string">''' then mark end) '</span>,</span><br><span class="line">      subject</span><br><span class="line">    )</span><br><span class="line">  ) <span class="keyword">INTO</span> @<span class="keyword">sql</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  Meeting;</span><br><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = <span class="keyword">CONCAT</span>(<span class="string">'SELECT Meeting_id, '</span>, @<span class="keyword">sql</span>, <span class="string">' </span></span><br><span class="line"><span class="string">                  FROM Meeting </span></span><br><span class="line"><span class="string">                   GROUP BY Meeting_id'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">PREPARE</span> stmt <span class="keyword">FROM</span> @<span class="keyword">sql</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义预处理语句</span></span><br><span class="line"><span class="comment"># PREPARE stmt_name FROM preparable_stmt;</span></span><br><span class="line"><span class="comment"># 执行预处理语句</span></span><br><span class="line"><span class="comment"># EXECUTE stmt_name [USING @var_name [, @var_name] ...];</span></span><br><span class="line"><span class="comment"># 删除(释放)定义</span></span><br><span class="line"><span class="comment"># &#123;DEALLOCATE | DROP&#125; PREPARE stmt_name;</span></span><br></pre></td></tr></table></figure><p>先来看看这句的执行的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">GROUP_CONCAT</span>(<span class="keyword">DISTINCT</span></span><br><span class="line">    <span class="keyword">CONCAT</span>(</span><br><span class="line">      <span class="string">'max(case when subject = '''</span>,</span><br><span class="line">      subject,</span><br><span class="line">      <span class="string">''' then mark end) as '</span>,</span><br><span class="line">      subject</span><br><span class="line">    )</span><br><span class="line">  ) </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  Meeting;</span><br></pre></td></tr></table></figure><p>执行结果： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max(case when subject = &apos;政治&apos; then mark end) as 政治,max(case when subject = &apos;数学&apos; then mark end) as 数学,max(case when subject = &apos;语文&apos; then mark end) as 语文</span><br></pre></td></tr></table></figure></p><p>是不是已经看出来了，就是为了动态得到行，不是由我们手动指定的，而是通过脚本自动生成、拼接而来。</p><p>然后把拼接后的结果 <code>INTO @sql</code></p><p>再通过</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @<span class="keyword">sql</span> = <span class="keyword">CONCAT</span>(<span class="string">'SELECT name, '</span>, @<span class="keyword">sql</span>, <span class="string">' </span></span><br><span class="line"><span class="string">                  FROM person_grade </span></span><br><span class="line"><span class="string">                   GROUP BY name'</span>);</span><br></pre></td></tr></table></figure><p>拼成完整的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> subject = <span class="string">'政治'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> 政治,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> subject = <span class="string">'数学'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> 数学,</span><br><span class="line"><span class="keyword">max</span>(<span class="keyword">case</span> <span class="keyword">when</span> subject = <span class="string">'语文'</span> <span class="keyword">then</span> mark <span class="keyword">end</span>) <span class="keyword">as</span> 语文</span><br><span class="line"><span class="keyword">FROM</span> person_grade </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;group_concat函数&quot;&gt;GROUP_CONCAT()函数&lt;/h1&gt;
&lt;p&gt;创建表&lt;code&gt;person_info&lt;/code&gt;，并插入数据&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;`person_info`&lt;/span&gt; (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;bigint&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`name`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;string&quot;&gt;`family`&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;NULL&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  PRIMARY &lt;span class=&quot;keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`id`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;) &lt;span class=&quot;keyword&quot;&gt;ENGINE&lt;/span&gt;=&lt;span class=&quot;keyword&quot;&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;CHARSET&lt;/span&gt;=utf8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;张三&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;张三爸&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;张三&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;张三妈&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;李四&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;李四爸&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;李四&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;李四妈&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;李四&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;李四大哥&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;王二&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;王二爷爷&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;INTO&lt;/span&gt; niffler.person_info (&lt;span class=&quot;keyword&quot;&gt;name&lt;/span&gt;, family) &lt;span class=&quot;keyword&quot;&gt;VALUES&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;王二&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;王二姐姐&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="group_concat" scheme="http://yoursite.com/tags/group-concat/"/>
    
      <category term="行转列" scheme="http://yoursite.com/tags/%E8%A1%8C%E8%BD%AC%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>经典Integer对象赋值128问题</title>
    <link href="http://yoursite.com/2023/08/25/%E7%BB%8F%E5%85%B8Integer%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC128%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/08/25/经典Integer对象赋值128问题/</id>
    <published>2023-08-25T03:56:50.000Z</published>
    <updated>2023-08-25T06:59:20.221Z</updated>
    
    <content type="html"><![CDATA[<p>Integer经典面试问题：两个Integer对象都赋值为128，这两个对象比较是否相同？为什么？</p><p>回答这个问题，首先我们要知道，在Java中，当你写<code>Integer a = 1;</code>实际上是调用了Java的自动装箱功能。这会将整数 1自动装箱为Integer对象，然后将这个对象赋值给变量a。</p><p>自动装箱功能是由编译器自动插入的，实际上它相当于执行了如下的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer a = Integer.valueOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里的valueOf方法是Integer类的一个静态方法，它的作用就是将传入的参数（通常是基本数据类型）自动转换为对应的包装类对象。对于Integer类来说，就是将整数值转换为Integer对象。</p><a id="more"></a><p>知道这一点之后，我们看看Integer.valueOf方法的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment"> * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment"> * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment"> * caching frequently requested values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment"> * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注解上说：如果不需要新的Integer实例，则通常应该优先使用此方法，而不是构造函数Integer(int)，因为通过缓存频繁请求的值，该方法可能会产生更好的空间和时间性能。此方法将始终缓存-128到127(包括-128到127)范围内的值，并可能缓存此范围之外的其他值。</p></blockquote><p>接下来看看IntegerCache缓存的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>缓存在第一次使用时初始化。缓存的大小可以通过-XX:AutoBoxCacheMax=<size>选项来控制。在虚拟机初始化过程中，可以设置java.lang.Integer.IntegerCache.high属性，并保存在sun.misc.VM类的私有系统属性中。</size></p></blockquote><p>IntegerCache缓存范围的最小值固定为-128，最大值默认为127.但是最大值是可以被重新定义的，那么可定义的范围是多少呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = Math.max(i, <span class="number">127</span>);</span><br><span class="line"><span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>上面的两行已经定义了IntegerCache缓存最大值的范围：</p><ol type="1"><li><p>定义最大值范围大于等于127；</p></li><li><p>定义最大值范围小于等于<code>Integer.MAX_VALUE - (-low) -1</code>;</p></li></ol><p>Integer.MAX_VALUE的定义：（2的23次方 - 1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>   MAX_VALUE = <span class="number">0x7fffffff</span>;</span><br></pre></td></tr></table></figure><p>IntegerCache缓存的范围定义好后，为区间范围赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">cache[k] = <span class="keyword">new</span> Integer(j++);</span><br></pre></td></tr></table></figure><p>最后通过断言检查 IntegerCache.high 是否大于等于 127。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line"><span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br></pre></td></tr></table></figure><p>IntegerCache.high 是 Java 中 Integer 缓存的一部分，这个缓存用于存储-128 到 127 之间的整数，以提高这个范围内的整数在多次使用时的性能。</p><p><code>assert</code> 是一个用于调试的语句，当 IntegerCache.high &lt;127 时，该语句将抛出 <code>AssertionError</code>。</p><p>JLS7 5.1.7 是 Java Language Specification的一个部分，这部分规定了对于字符串字面值，编译器必须将它们在编译期放入字符串池中，以避免内存浪费。</p><p>这段代码的目的是确保 IntegerCache 的范围在 [-128, 127] 内，因为这是String 缓存这个优化策略可以应用的范围。如果 IntegerCache的范围超出了这个范围，那么可能会导致无法进行这种优化，从而可能降低性能。</p><p>需要注意的是，assert语句在默认情况下是关闭的，如果你想要开启它，需要在启动 JVM 时添加<code>-ea</code>（或 <code>-enableassertions</code>）参数。</p><p>因此，当写 <code>Integer i1 = 128;</code> 和<code>Integer i2 = 128;</code>，实际上在内存中创建了两个不同的对象，即使它们包含相同的值。</p><p>可以通过调用 <code>equals()</code>方法来比较这两个对象的内容是否相同，而不是使用 <code>==</code>运算符。这是因为<code>==</code>在比较对象时实际上是检查它们是否指向内存中的同一个对象，而不是比较它们的内容。而<code>equals()</code> 方法则是比较对象的内容。</p><p>如果使用 <code>equals()</code>方法来比较这两个对象，它们会被视为相等，因为它们包含相同的内容。但是，如果你使用<code>==</code>运算符来比较，它们会被视为不相等，因为它们是不同的对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Integer经典面试问题：两个Integer对象都赋值为128，这两个对象比较是否相同？为什么？&lt;/p&gt;
&lt;p&gt;回答这个问题，首先我们要知道，在Java中，当你写&lt;code&gt;Integer a = 1;&lt;/code&gt;
实际上是调用了Java的自动装箱功能。这会将整数 1
自动装箱为Integer对象，然后将这个对象赋值给变量a。&lt;/p&gt;
&lt;p&gt;自动装箱功能是由编译器自动插入的，实际上它相当于执行了如下的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer a = Integer.valueOf(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里的valueOf方法是Integer类的一个静态方法，它的作用就是将传入的参数（通常是基本数据类型）自动转换为对应的包装类对象。对于Integer类来说，就是将整数值转换为Integer对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="Integer" scheme="http://yoursite.com/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>【翻译】MySQL数据库InnoDB存储引擎</title>
    <link href="http://yoursite.com/2023/08/24/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/2023/08/24/MySQL数据库InnoDB存储引擎/</id>
    <published>2023-08-24T12:28:42.000Z</published>
    <updated>2023-08-28T02:30:03.963Z</updated>
    
    <content type="html"><![CDATA[<p>InnoDB is a general-purpose storage engine that balances highreliability and high performance. In MySQL 8.0, InnoDB is the defaultMySQL storage engine. Unless you have configured a different defaultstorage engine, issuing a CREATE TABLE statement without an ENGINEclause creates an InnoDB table.</p><p>InnoDB是一种平衡高可靠性和高性能的通用存储引擎。在MySQL8.0中，InnoDB是MySQL默认的存储引擎。除非您配置了不同的默认存储引擎，否则发出不带ENGINE 子句的 CREATE TABLE 语句将创建一个 InnoDB 表。</p><a id="more"></a><h1 id="key-advantages-of-innodb-innodb的主要优势">Key Advantages ofInnoDB InnoDB的主要优势</h1><p>Its DML operations follow the ACID model, with transactions featuringcommit, rollback, and crash-recovery capabilities to protect userdata.</p><p>其DML操作遵循ACID模型，事务具有提交、回滚和崩溃恢复功能，以保护用户数据</p><p>Row-level locking and Oracle-style consistent reads increasemulti-user concurrency and performance.</p><p>行级锁定和 Oracle 风格的一致性读取提高了多用户并发性和性能</p><p>InnoDB tables arrange your data on disk to optimize queries based onprimary keys. Each InnoDB table has a primary key index called theclustered index that organizes the data to minimize I/O for primary keylookups.</p><p>InnoDB 表在磁盘上排列数据以根据主键优化查询。每个 InnoDB表都有一个称为聚集索引的主键索引，用于组织数据以最大程度地减少主键查找的I/O。</p><p>To maintain data integrity, InnoDB supports FOREIGN KEY constraints.With foreign keys, inserts, updates, and deletes are checked to ensurethey do not result in inconsistencies across related tables</p><p>为了保持数据完整性，InnoDB 支持 FOREIGN KEY约束。使用外键，检查插入、更新和删除，以确保它们不会导致相关表之间的不一致。</p><h1 id="acid">ACID</h1><p>An acronym standing for atomicity, consistency, isolation, anddurability. These properties are all desirable in a database system, andare all closely tied to the notion of a transaction. The transactionalfeatures of InnoDB adhere to the ACID principles.</p><p>ACID代表原子性、一致性、隔离性和持久性的缩写。这些属性都是数据库系统所需要的，并且都与事务的概念密切相关。InnoDB 的事务特性遵循 ACID 原则。</p><p>Transactions are atomic units of work that can be committed or rolledback. When a transaction makes multiple changes to the database, eitherall the changes succeed when the transaction is committed, or all thechanges are undone when the transaction is rolled back.</p><p>事务是可以提交或回滚的原子工作单元。当一个事务对数据库进行多次更改时，要么在事务提交时所有更改都成功，要么在事务回滚时所有更改都被撤消。</p><p>The database remains in a consistent state at all times — after eachcommit or rollback, and while transactions are in progress. If relateddata is being updated across multiple tables, queries see either all oldvalues or all new values, not a mix of old and new values.</p><p>数据库始终保持一致的状态——每次提交或回滚之后以及事务正在进行时。如果跨多个表更新相关数据，则查询会看到所有旧值或所有新值，而不是新旧值的混合。</p><p>Transactions are protected (isolated) from each other while they arein progress; they cannot interfere with each other or see each other'suncommitted data. This isolation is achieved through the lockingmechanism. Experienced users can adjust the isolation level, trading offless protection in favor of increased performance and concurrency, whenthey can be sure that the transactions really do not interfere with eachother.</p><p>交易在进行过程中相互保护（隔离）；他们不能互相干扰或看到彼此未提交的数据。这种隔离是通过锁定机制实现的。当有经验的用户可以确定事务确实不会相互干扰时，他们可以调整隔离级别，以减少保护来提高性能和并发性。</p><p>The results of transactions are durable: once a commit operationsucceeds, the changes made by that transaction are safe from powerfailures, system crashes, race conditions, or other potential dangersthat many non-database applications are vulnerable to. Durabilitytypically involves writing to disk storage, with a certain amount ofredundancy to protect against power failures or software crashes duringwrite operations. (In InnoDB, the doublewrite buffer assists withdurability.)</p><p>事务的结果是持久的：一旦提交操作成功，该事务所做的更改就不会受到电源故障、系统崩溃、竞争条件或许多非数据库应用程序容易遭受的其他潜在危险的影响。持久性通常涉及写入磁盘存储，并具有一定量的冗余，以防止写入操作期间发生电源故障或软件崩溃。（在 InnoDB 中，双写缓冲区有助于提高耐用性。）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;InnoDB is a general-purpose storage engine that balances high
reliability and high performance. In MySQL 8.0, InnoDB is the default
MySQL storage engine. Unless you have configured a different default
storage engine, issuing a CREATE TABLE statement without an ENGINE
clause creates an InnoDB table.&lt;/p&gt;
&lt;p&gt;InnoDB是一种平衡高可靠性和高性能的通用存储引擎。在MySQL
8.0中，InnoDB是MySQL默认的存储引擎。除非您配置了不同的默认存储引擎，否则发出不带
ENGINE 子句的 CREATE TABLE 语句将创建一个 InnoDB 表。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库GROUP_CONCAT()函数输出结果的长度限制</title>
    <link href="http://yoursite.com/2023/08/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93GROUP_CONCAT()%E5%87%BD%E6%95%B0%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E7%9A%84%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6/"/>
    <id>http://yoursite.com/2023/08/16/MySQL数据库GROUP_CONCAT()函数输出结果的长度限制/</id>
    <published>2023-08-16T07:09:39.000Z</published>
    <updated>2023-08-16T07:22:46.045Z</updated>
    
    <content type="html"><![CDATA[<p>GROUP_CONCAT()函数输出的结果，发现被截取了一部分，并没有显示完整，原来GROUP_CONCAT()默认的输出长度为1024字节，超出的部分会被截掉不显示。</p><a id="more"></a><h2 id="group_concat">GROUP_CONCAT()</h2><p>MySQL官方文档关于<a href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html#function_group-concat" target="_blank" rel="noopener">GROUP_CONCAT()</a>函数的说明：</p><img src="/2023/08/16/MySQL数据库GROUP_CONCAT()函数输出结果的长度限制/微信截图_20230816145238.png"><p>文档中除了 GROUP_CONCAT()函数的语法和使用，还提到：</p><blockquote><p>结果被截断为 <code>group_concat_max_len</code>系统变量指定的最大长度，该变量的默认值为 1024</p></blockquote><p>group_concat() 函数输出的结果长度，由<code>group_concat_max_len</code>系统变量所限制，超出设置的最大长度，将会被截掉，<code>group_concat_max_len</code> 的默认长度为<code>1024</code></p><p>在运行时更改 <code>group_concat_max_len</code> 值的语法如下，其中 val是无符号整数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [GLOBAL | SESSION] group_concat_max_len = val;</span><br></pre></td></tr></table></figure><h2 id="groyp_concat_max_len">GROYP_CONCAT_MAX_LEN</h2><p>MySQL官方文档关于服务器系统变量 <a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_group_concat_max_len" target="_blank" rel="noopener">group_concat_max_len</a>的解释：</p><img src="/2023/08/16/MySQL数据库GROUP_CONCAT()函数输出结果的长度限制/微信截图_20230816144139.png"><p>GROUP_CONCAT() 函数的长度以字节为单位，默认值为 1024。</p><p>64位系统值<code>18446744073709551615</code>,63为系统值<code>4294967295</code>,最小值都为<code>4</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GROUP_CONCAT()函数输出的结果，发现被截取了一部分，并没有显示完整，原来GROUP_CONCAT()
默认的输出长度为1024字节，超出的部分会被截掉不显示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="group_concat" scheme="http://yoursite.com/tags/group-concat/"/>
    
      <category term="group_concat_max_len" scheme="http://yoursite.com/tags/group-concat-max-len/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot与SpringCloud</title>
    <link href="http://yoursite.com/2023/07/14/SpringBoot%E4%B8%8ESpringCloud/"/>
    <id>http://yoursite.com/2023/07/14/SpringBoot与SpringCloud/</id>
    <published>2023-07-14T05:33:33.000Z</published>
    <updated>2023-07-14T11:17:26.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot">1. SpringBoot</h1><h2 id="springboot的作用">1.1 SpringBoot的作用</h2><p>SpringBoot是一个快速构建项目并简化项目配置的工具，内部集成了Tomcat及大多数第三方应用和Spring框架的默认配置。与我们学习的SpringMVC和SpringCloud并无冲突,SpringBoot提供的这些默认配置，大大简化了SpringMVC、SpringCloud等基于Spring的Web应用的开发。</p><h2 id="springboot的自动配置原理如何实现">1.2.SpringBoot的自动配置原理（如何实现）？</h2><h3 id="springboot的自动配置是如何实现的">SpringBoot的自动配置是如何实现的？</h3><p>一般我们的SpringBoot项目启动类都会添加<code>@SpringBootApplication</code>注解，而这个注解的其中一个二级注解是<code>@EnableAutoConfiguration</code>注解。而<code>@EnableAutoConfiguration</code>注解通过<code>@Import</code>注解，以<code>ImportSelector</code>接口的方法来导入classpath下的<code>META-INF/spring.factories</code>文件，这些文件中会指定需要加载的一些类名称。</p><p>这些类一般都加了<code>@Configuration</code>注解，并且完成了对某框架（例如Redis、SpringMVC）的默认配置，当这些类符合条件时，就会被实例化，其中的配置生效，那么自动配置自然生效了。</p><a id="more"></a><h3 id="满足怎样的条件配置才会生效">满足怎样的条件配置才会生效？</h3><p>一般提供默认配置的类都会添加<code>@ConditionalOnXxx</code>这样的注解，例如：<code>@ConditionalOnClass</code>，<code>@ConditionalOnProperties</code>等。<code>@ConditionalOnClass</code>表示只有classpath中存在某些指定的类时，条件满足，此时该配置类才会生效。例如Redis的默认配置其实早就有了，但是只有你引入redis的starter依赖，才满足了条件，触发自动配置。</p><h3 id="那如果我需要覆盖这些默认配置呢">那如果我需要覆盖这些默认配置呢？</h3><p>有两种方式可以覆盖默认配置：</p><ul><li>SpringBoot提供默认配置时，会在提供的Bean上加注解@ConditionalOnMissingBean，意思是如果这个Bean不存在时条件满足，那么我们只要配置了相同的Bean，那么SpringBoot提供的默认配置就会失效</li><li>SpringBoot提供默认配置时，一些关键属性会通过读取application.yml或者application.properties文件来获取，因此我们可以通过覆盖任意一个文件中的属性来覆盖默认配置。</li></ul><h2 id="自定义springboot的stater">1.3 自定义SpringBoot的stater？</h2><p>项目中某些中间件的客户端（如Redis、ElasticSearch）会进行二次封装，并通过starter方式提供jar包，供大家使用。</p><p>一般定义starter包括下面几个子工程：</p><ul><li>xxx-spring-boot-starter：pom格式，管理当前starter中需要的各种依赖</li><li>xxx-spring-boot-autoconfigure：jar格式，自动配置的核心代码</li></ul><p>以elasticsearch为例来说说autoconfigure中包含哪些</p><ul><li>elasticsearch的工具类</li><li>属性加载的类，一般通过@ConfigurationProperties注解读取yaml文件中的es地址</li><li>添加了@Configuration的配置类，作用是初始化elasticsearch工具类，初始化elasticsearch客户端，初始化一些其它必备的实例。</li><li>resource下定义META-INF文件夹，并且文件夹下定义spring.factories文件，文件中是key-value形式:key是EnableAutoConfiguration这个注解的全路径名,value是我们自定义自动配置类（加了@Configuration的类），如果有多个以","隔开</li></ul><h2 id="springboot项目的启动流程">1.4 SpringBoot项目的启动流程</h2><p>SpringBoot项目启动第一步就是创建SpringApplication的实例，并且调用SpringApplication.run()这个方法。</p><p>创建SpringApplication实例主要完成三件事情：</p><ul><li>记录当前启动类字节码</li><li>判断当前项目类型，普通Servlet、响应式WebFlux、NONE</li><li>加载/META-INF/spring.factories文件，初始化ApplicationContextInitializer和ApplicationListener实例</li></ul><p>而后的run()方法则会创建spring容器，流程如下：</p><ul><li>准备监听器，监听Spring启动的各个过程</li><li>创建并配置环境参数Environment</li><li>创建ApplicationContext</li><li>prepareContext()：初始化ApplicationContext，准备运行环境</li><li>refreshContext(context)：准备Bean工厂，调用一个BeanDefinition和BeanFactory的后处理器，初始化各种Bean，初始化tomcat</li><li>afterRefresh()：拓展功能，目前为空</li><li>发布容器初始化完毕的事件</li></ul><h2 id="springboot的配置加载优先级">1.5 SpringBoot的配置加载优先级</h2><p>SpringBoot参数配置方式很多，比较常用参数配置方式按照优先级从高到低分别是：</p><ul><li>在命令行中传入的参数</li><li>java 的系统属性，可以通过System.getProperties()获得的内容</li><li>操作系统的环境变量</li><li>针对不同{profile}环境的配置文件内容，例如applicaiton-{profile}.yaml</li><li>application.yml或application.proerties文件</li><li>在@Configration注解修改的类中，通过@PropertySource注解定义的属性</li></ul><h1 id="springcloud">2 SpringCloud</h1><h2 id="springcloud和dubbo的区别">2.1 SpringCloud和Dubbo的区别</h2><p>两者都是现在主流的微服务框架，但却存在不少差异：</p><ul><li>初始定位不同：SpringCloud定位为微服务架构下的一站式解决方案；Dubbo是 SOA 时代的产物，它的关注点主要在于服务的调用和治理</li><li>生态环境不同：SpringCloud依托于Spring平台，具备更加完善的生态体系；而Dubbo一开始只是做RPC远程调用，生态相对匮乏，现在逐渐丰富起来。</li><li>调用方式：SpringCloud是采用Http协议做远程调用，接口一般是Rest风格，比较灵活；Dubbo是采用Dubbo协议，接口一般是Java的Service接口，格式固定。但调用时采用Netty的NIO方式，性能较好。</li><li>组件差异比较多，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper</li></ul><p>SpringCloud生态丰富，功能完善，更像是品牌机，Dubbo则相对灵活，可定制性强，更像是组装机。</p><p>两者的生态对比：</p><table><thead><tr class="header"><th>功能</th><th>Dubbo</th><th>SpringCloud</th></tr></thead><tbody><tr class="odd"><td>服务注册中心</td><td>Zookeeper</td><td>Eureka(主流）、Consul、zookeeper</td></tr><tr class="even"><td>服务调用方式</td><td>RPC基于Dubbo协议</td><td>REST API 基于Http协议</td></tr><tr class="odd"><td>服务监控</td><td>Dubbo-Monitor</td><td>Spring Boot Admin</td></tr><tr class="even"><td>熔断器</td><td>不完善</td><td>Spring Cloud Netflix Hystrix</td></tr><tr class="odd"><td>服务网关</td><td>无</td><td>Spring Cloud Netflix Zuul、Gateway</td></tr><tr class="even"><td>分布式配置</td><td>无</td><td>Spring Cloud Config</td></tr><tr class="odd"><td>服务跟踪</td><td>无</td><td>Spring Cloud Sleuth+Zipkin(一般)</td></tr><tr class="even"><td>数据流</td><td>无</td><td>Spring Cloud Stream</td></tr><tr class="odd"><td>批量任务</td><td>无</td><td>Spring Cloud Task</td></tr><tr class="even"><td>信息总线</td><td>无</td><td>Spring Cloud Bus</td></tr></tbody></table><p>Spring Cloud 的功能很明显比 Dubbo 更加强大，涵盖面更广，而且作为Spring 的旗舰项目，它也能够与 Spring Framework、Spring Boot、SpringData、Spring Batch 等其他 Spring项目完美融合，这些对于微服务而言是至关重要的。</p><p>使用 Dubbo构建的微服务架构就像组装电脑，各环节选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果使用者是一名高手，那这些都不是问题。</p><h2 id="dubbo和feign远程调用的差异">2.2 dubbo和Feign远程调用的差异</h2><p>Feign是SpringCloud中的远程调用方式，基于成熟Http协议，所有接口都采用Rest风格。因此接口规范更统一，而且只要符合规范，实现接口的微服务可以采用任意语言或技术开发。但受限于http协议本身的特点，请求和响应格式臃肿，其通信效率相对会差一些。</p><p>Dubbo框架默认采用Dubbo自定义通信协议，与Http协议一样底层都是TCP通信。但是Dubbo协议自定义了Java数据序列化和反序列化方式、数据传输格式，因此Dubbo在数据传输性能上会比Http协议要好一些。</p><p>不过这种性能差异除非是达极高的并发量级，否则无需过多考虑。</p><h2 id="eureka和zookeeper注册中心的区别">2.3Eureka和Zookeeper注册中心的区别</h2><p>SpringCloud和Dubbo都支持多种注册中心，不过目前主流来看SpringCloud用Eureka较多，Dubbo则以Zookeeper为主。两者存在较大的差异：</p><ul><li>从集群设计来看：Eureka集群各节点平等，没有主从关系，因此可能出现数据不一致情况；ZK为了满足一致性，必须包含主从关系，一主多从。集群无主时，不对外提供服务</li><li>CAP原则来看：Eureka满足AP原则，为了保证整个服务可用性，牺牲了集群数据的一致性；而Zookeeper满足CP原则，为了保证各节点数据一致性，牺牲了整个服务的可用性。</li><li>服务拉取方式来看：Eureka采用的是服务主动拉取策略，消费者按照固定频率（默认30秒）去Eureka拉取服务并缓存在本地；ZK中的消费者首次启动到ZK订阅自己需要的服务信息，并缓存在本地。然后监听服务列表变化，以后服务变更ZK会推送给消费者。</li></ul><p><strong>扩展：</strong></p><p>首先，Eureka和Zookeeper都是服务治理框架，但是设计上有一定的差别。</p><p>先看下CAP原则：C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。</p><p>Eureka满足AP，Zookeeper满足CP</p><p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是Zookeeper和Eureka在一致性与可用性间做出了不同的选择。</p><p>Zookeeper：Zookeeper的设计追求数据的一致性，不保证服务的可用性。当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30~ 120s,且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p><p>Eureka：Eureka追求的是服务的可用性，从而牺牲了数据的一致性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况。</p><ol type="1"><li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li><li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li><li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li></ol><p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p><p>Eureka集群各节点平等，Zookeeper中有主从之分</p><ol type="1"><li>如果Zookeeper集群中部分宕机，可能会导致整个集群因为选主而阻塞，服务不可用</li><li>Eureka集群宕机部分，不会对其它机器产生影响</li></ol><p>Eureka的服务发现需要主动去拉取，Zookeeper服务发现是监听机制</p><ol type="1"><li>Eureka中获取服务列表后会缓存起来，每隔30秒重新拉取服务列表</li><li>Zookeeper则是监听节点信息变化，当服务节点信息变化时，客户端立即就得到通知</li></ol><h2 id="springcloud中的常用组件有哪些">2.4SpringCloud中的常用组件有哪些？</h2><p>Spring Cloud的子项目很多，比较常见的都是Netflix开源的组件：</p><ul><li>Spring Cloud Config</li></ul><p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p><ul><li>Spring Cloud Netflix</li></ul><p>Netflix OSS开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p><p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；Feign：基于Ribbon和Hystrix的声明式服务调用组件；Zuul：API网关组件，对请求提供路由及过滤功能。 Spring Cloud Bus用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p><ul><li>Spring Cloud Consul</li></ul><p>基于Hashicorp Consul的服务治理组件。</p><ul><li>Spring Cloud Security</li></ul><p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p><ul><li>Spring Cloud Sleuth</li></ul><p>SpringCloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p><ul><li>Spring Cloud Stream</li></ul><p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为ApacheKafka及RabbitMQ。</p><ul><li>Spring Cloud Task</li></ul><p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p><ul><li>Spring Cloud Zookeeper</li></ul><p>基于Apache Zookeeper的服务治理组件。</p><ul><li>Spring Cloud Gateway</li></ul><p>API网关组件，对请求提供路由及过滤功能。</p><ul><li>Spring Cloud OpenFeign</li></ul><p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于SpringMVC注解的接口实现用于服务调用，在Spring Cloud2.0中已经取代Feign成为了一等公民。</p><hr><p>未完待续</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;springboot&quot;&gt;1. SpringBoot&lt;/h1&gt;
&lt;h2 id=&quot;springboot的作用&quot;&gt;1.1 SpringBoot的作用&lt;/h2&gt;
&lt;p&gt;SpringBoot是一个快速构建项目并简化项目配置的工具，内部集成了Tomcat及大多数第三方应用和Spring框架的默认配置。与我们学习的SpringMVC和SpringCloud并无冲突,SpringBoot提供的这些默认配置，大大简化了SpringMVC、SpringCloud等基于Spring的Web应用的开发。&lt;/p&gt;
&lt;h2 id=&quot;springboot的自动配置原理如何实现&quot;&gt;1.2.SpringBoot的自动配置原理（如何实现）？&lt;/h2&gt;
&lt;h3 id=&quot;springboot的自动配置是如何实现的&quot;&gt;SpringBoot的自动配置是如何实现的？&lt;/h3&gt;
&lt;p&gt;一般我们的SpringBoot项目启动类都会添加&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解，而这个注解的其中一个二级注解是&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解。而&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;注解通过&lt;code&gt;@Import&lt;/code&gt;注解，以&lt;code&gt;ImportSelector&lt;/code&gt;接口的方法来导入classpath下的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;文件，这些文件中会指定需要加载的一些类名称。&lt;/p&gt;
&lt;p&gt;这些类一般都加了&lt;code&gt;@Configuration&lt;/code&gt;注解，并且完成了对某框架（例如Redis、SpringMVC）的默认配置，当这些类符合条件时，就会被实例化，其中的配置生效，那么自动配置自然生效了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis配置allowMultiQueries=true允许使用foreach标签批量插入或更新数据</title>
    <link href="http://yoursite.com/2023/06/30/MyBatis%E9%85%8D%E7%BD%AEallowMultiQueries-true%E5%85%81%E8%AE%B8%E4%BD%BF%E7%94%A8foreach%E6%A0%87%E7%AD%BE%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%88%96%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2023/06/30/MyBatis配置allowMultiQueries-true允许使用foreach标签批量插入或更新数据/</id>
    <published>2023-06-30T04:59:35.000Z</published>
    <updated>2023-06-30T05:01:00.437Z</updated>
    
    <content type="html"><![CDATA[<p>执行update更新操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"batchUpdate"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">separator</span>=<span class="string">";"</span> <span class="attr">open</span>=<span class="string">""</span> <span class="attr">close</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">        update test_table</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.a != null"</span>&gt;</span>output_amount = #&#123;item.a&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.b!= null"</span>&gt;</span>invoice_amount = #&#123;item.b&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.c!= null"</span>&gt;</span>payment_amount = #&#123;item.c&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        where id = #&#123;item.id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行报错： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error updating database.  </span><br><span class="line">Cause: java.sql.SQLSyntaxErrorException: </span><br><span class="line">You have an error in your SQL syntax; </span><br><span class="line">check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;update test_table set a = 1, &apos; at line 14</span><br></pre></td></tr></table></figure></p><p>刚开始出现这个错误，以为是update语句写的有问题，但是检查了很多遍都没有问题。奇怪的是，同样的代码，同样的数据，本地启的环境不行，测试环境却可以。经过同事提醒了一下，于是检查了一下配置文件，果然发现配置文件上的jdbc配置，测试环境比开发环境多了个<code>allowMultiQueries=true</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://127.0.0.1:3306/db?useUnicode=true&amp;characterEncoding=utf8&amp;allowMultiQueries=true&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8&amp;nullCatalogMeansCurrent=true</span><br></pre></td></tr></table></figure><p>MyBatis默认情况下不允许批量插入或更新数据的原因是出于安全考虑。在许多情况下，数据的插入和更新都需要经过验证和控制，以确保数据的完整性和一致性。如果允许默认的批量操作，可能会导致不正确的数据插入或更新，从而影响应用程序的正常运行。</p><p>通过配置<code>allowMultiQueries=true</code>可以开启MyBatis的批量操作功能。这个配置项告诉MyBatis允许在单个数据库连接中执行多个SQL语句，从而实现批量插入或更新数据的功能。但是要注意，在开启批量操作之前，确保你已经了解并理解了可能引发的安全风险，并且在使用批量操作时要进行适当的验证和控制，以确保数据的完整性和安全性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;执行update更新操作&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
      <category term="代码人生" scheme="http://yoursite.com/categories/MySQL/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
      <category term="数据库" scheme="http://yoursite.com/categories/MySQL/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="allowMultiQueries" scheme="http://yoursite.com/tags/allowMultiQueries/"/>
    
  </entry>
  
  <entry>
    <title>Flowable工作流重启已经结束的流程</title>
    <link href="http://yoursite.com/2023/06/30/Flowable%E5%B7%A5%E4%BD%9C%E6%B5%81%E9%87%8D%E5%90%AF%E5%B7%B2%E7%BB%8F%E7%BB%93%E6%9D%9F%E7%9A%84%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2023/06/30/Flowable工作流重启已经结束的流程/</id>
    <published>2023-06-30T03:51:32.000Z</published>
    <updated>2023-06-30T03:57:41.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用historyservice接口来查询历史流程实例">使用<code>HistoryService</code>接口来查询历史流程实例</h2><p>在Flowable中，已终止的流程实例不能通过<code>RuntimeService</code>接口直接查询到。相反，你需要使用<code>HistoryService</code>接口来查询历史流程实例，并从中筛选出已终止的实例。以下是正确的步骤：</p><ol type="1"><li><p>确保你的应用程序连接到正确的Flowable流程引擎实例。你需要使用Flowable的API来执行后续的操作。</p></li><li><p>使用<code>HistoryService</code>接口的<code>createHistoricProcessInstanceQuery()</code>方法构建查询，设置适当的条件来筛选已终止的流程实例。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HistoricProcessInstanceQuery query = historyService.createHistoricProcessInstanceQuery()</span><br><span class="line">.finished();</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>执行查询并获取已终止的流程实例列表。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;HistoricProcessInstance&gt; terminatedInstances = query.list();</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><p>根据需要选择要重启的流程实例。你可以根据流程实例的ID或其他属性进行选择。</p></li><li><p>如果你需要将已终止的流程实例重新激活，可以创建一个新的流程实例，或者使用历史流程实例中的数据进行修复。请注意，这取决于你的业务需求和流程定义的复杂性。</p></li></ol><p>请注意，已终止的流程实例是历史数据，因此无法直接重新激活。你需要根据业务需求进行相应的处理。使用<code>HistoryService</code>接口可以提供有关已终止流程实例的详细信息，但不能直接操作它们。</p><a id="more"></a><h2 id="使用historyservice获取的流程实例信息重新发起一个新的流程实例">使用<code>HistoryService</code>获取的流程实例信息重新发起一个新的流程实例</h2><p>要使用<code>HistoryService</code>获取的流程实例信息重新发起一个新的流程实例，你需要执行以下步骤：</p><ol type="1"><li>获取已终止流程实例的相关信息，如流程定义ID、业务关联键等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String processDefinitionId = historicProcessInstance.getProcessDefinitionId();</span><br><span class="line">String businessKey = historicProcessInstance.getBusinessKey();</span><br><span class="line"><span class="comment">// 其他需要的信息</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>RuntimeService</code>接口的<code>startProcessInstanceById()</code>方法或<code>startProcessInstanceByKey()</code>方法来启动新的流程实例。根据你的需求选择合适的方法。</li></ol><p>如果你选择使用流程定义ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessInstance newProcessInstance = runtimeService</span><br><span class="line">.startProcessInstanceById(processDefinitionId, businessKey);</span><br></pre></td></tr></table></figure><p>如果你选择使用流程定义的键（Key）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessInstance newProcessInstance = runtimeService</span><br><span class="line">.startProcessInstanceByKey(processDefinitionKey, businessKey);</span><br></pre></td></tr></table></figure><p>在这里，<code>processDefinitionKey</code>是流程定义的键（Key）。</p><ol start="3" type="1"><li>在启动新的流程实例后，你可以执行后续的操作，例如处理任务等，以继续流程的执行。</li></ol><p>请注意，重新发起的新流程实例与原始已终止的流程实例是独立的。你需要根据需求来处理任何必要的数据复制或流程初始化操作。</p><h2 id="设置重新发起的流程实例的变量variables">设置重新发起的流程实例的变量（variables）</h2><p>要设置重新发起的流程实例的变量（variables），你可以使用<code>RuntimeService</code>接口的<code>startProcessInstanceById()</code>或<code>startProcessInstanceByKey()</code>方法的重载版本来指定变量的值。以下是设置变量的步骤：</p><ol type="1"><li>获取已终止流程实例的相关信息，如流程定义ID、业务关联键等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String processDefinitionId = historicProcessInstance.getProcessDefinitionId();</span><br><span class="line">String businessKey = historicProcessInstance.getBusinessKey();</span><br><span class="line"><span class="comment">// 其他需要的信息</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>创建一个<code>Map</code>对象，将变量名和对应的值放入该对象中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; variables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">variables.put(<span class="string">"variable1"</span>, value1);</span><br><span class="line">variables.put(<span class="string">"variable2"</span>, value2);</span><br><span class="line"><span class="comment">// 添加其他变量</span></span><br></pre></td></tr></table></figure><p>在上述代码中，"variable1"和"variable2"是变量名，value1和value2是对应的值。</p><ol start="3" type="1"><li>使用<code>RuntimeService</code>接口的<code>startProcessInstanceById()</code>方法或<code>startProcessInstanceByKey()</code>方法的重载版本来启动新的流程实例，并在参数中传递变量的Map对象。</li></ol><p>如果你选择使用流程定义ID：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessInstance newProcessInstance = runtimeService</span><br><span class="line">.startProcessInstanceById(processDefinitionId, businessKey, variables);</span><br></pre></td></tr></table></figure><p>如果你选择使用流程定义的键（Key）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ProcessInstance newProcessInstance = runtimeService</span><br><span class="line">.startProcessInstanceByKey(processDefinitionKey, businessKey, variables);</span><br></pre></td></tr></table></figure><ol start="4" type="1"><li>通过上述步骤，变量将与新的流程实例关联，并可以在流程的执行中使用。</li></ol><p>请注意，如果重新发起的流程实例需要使用历史流程实例的数据作为变量的值，你需要根据业务需求将这些数据复制到新的流程实例中。</p><h2 id="关于新发起流程的processinstancename为空的情况说明">关于新发起流程的<code>processInstanceName</code>为空的情况说明</h2><p>在Flowable中，流程实例的名称（process instancename）是一个可选的属性，并且不会自动从历史流程实例中继承。因此，在重新发起流程实例时，<code>processInstanceName</code>默认为空。</p><p>如果你想为重新发起的流程实例设置一个名称，可以通过设置流程变量的方式来实现。以下是设置流程实例名称的步骤：</p><ol type="1"><li>获取已终止流程实例的相关信息，如流程定义ID、业务关联键等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String processDefinitionId = historicProcessInstance.getProcessDefinitionId();</span><br><span class="line">String businessKey = historicProcessInstance.getBusinessKey();</span><br><span class="line"><span class="comment">// 其他需要的信息</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>使用<code>RuntimeService</code>接口的<code>startProcessInstanceById()</code>或<code>startProcessInstanceByKey()</code>方法启动新的流程实例，并在参数中传递变量的Map对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; variables = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">variables.put(<span class="string">"processInstanceName"</span>, <span class="string">"My Process Instance"</span>); <span class="comment">// 设置流程实例名称</span></span><br><span class="line"></span><br><span class="line">ProcessInstance newProcessInstance = runtimeService</span><br><span class="line">.startProcessInstanceById(processDefinitionId, businessKey, variables);</span><br></pre></td></tr></table></figure><p>在上述代码中，我们将流程实例名称作为变量<code>"processInstanceName"</code>的值传递给了<code>startProcessInstanceById()</code>方法。</p><ol start="3" type="1"><li>在新的流程实例中，你可以使用<code>RuntimeService</code>接口的<code>getVariable()</code>方法来获取流程实例名称。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String processInstanceName = runtimeService</span><br><span class="line">.getVariable(newProcessInstance.getId(), <span class="string">"processInstanceName"</span>);</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>newProcessInstance.getId()</code>是重新发起的流程实例的ID。</p><p>通过上述步骤，你可以在重新发起的流程实例中设置和获取流程实例名称。</p><h2 id="关于流程中historicprocessinstance的endtime字段为空的情况说明">关于流程中<code>HistoricProcessInstance</code>的<code>endTime</code>字段为空的情况说明</h2><p>在Flowable中，<code>HistoricProcessInstance</code>的<code>endTime</code>字段为空是因为该字段仅在流程实例完成时被设置为非空值。当你重新发起一个新的流程实例时，该实例尚未完成，因此<code>endTime</code>字段仍然为空。</p><p><code>HistoricProcessInstance</code>对象表示已完成或已终止的流程实例的历史记录，其中<code>endTime</code>字段指示流程实例的结束时间。只有在流程实例完成时，即流程的所有活动都已完成，<code>endTime</code>字段才会被设置为相应的时间戳。</p><p>当你重新发起一个新的流程实例时，新的流程实例将被视为全新的实例，其<code>endTime</code>字段将在实例完成时被设置为相应的时间戳。因此，刚刚重新发起的流程实例的<code>endTime</code>字段为空是符合预期的行为。</p><p>如果你需要确定新流程实例的完成状态，你可以使用<code>RuntimeService</code>接口或其他相关接口来查询并检查流程实例的状态。例如，可以使用<code>RuntimeService</code>的<code>createProcessInstanceQuery()</code>方法查询并判断流程实例是否已完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProcessInstanceQuery query = runtimeService</span><br><span class="line">.createProcessInstanceQuery().processInstanceId(newProcessInstanceId);</span><br><span class="line"><span class="keyword">boolean</span> isProcessInstanceFinished = query.singleResult() == <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>newProcessInstanceId</code>是你重新发起的新流程实例的ID。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用historyservice接口来查询历史流程实例&quot;&gt;使用&lt;code&gt;HistoryService&lt;/code&gt;接口来查询历史流程实例&lt;/h2&gt;
&lt;p&gt;在Flowable中，已终止的流程实例不能通过&lt;code&gt;RuntimeService&lt;/code&gt;接口直接查询到。相反，你需要使用&lt;code&gt;HistoryService&lt;/code&gt;接口来查询历史流程实例，并从中筛选出已终止的实例。以下是正确的步骤：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;确保你的应用程序连接到正确的Flowable流程引擎实例。你需要使用Flowable的API来执行后续的操作。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;HistoryService&lt;/code&gt;接口的&lt;code&gt;createHistoricProcessInstanceQuery()&lt;/code&gt;方法构建查询，设置适当的条件来筛选已终止的流程实例。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;HistoricProcessInstanceQuery query = historyService.createHistoricProcessInstanceQuery()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		.finished();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;3&quot; type=&quot;1&quot;&gt;
&lt;li&gt;执行查询并获取已终止的流程实例列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;HistoricProcessInstance&amp;gt; terminatedInstances = query.list();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol start=&quot;4&quot; type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;根据需要选择要重启的流程实例。你可以根据流程实例的ID或其他属性进行选择。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你需要将已终止的流程实例重新激活，可以创建一个新的流程实例，或者使用历史流程实例中的数据进行修复。请注意，这取决于你的业务需求和流程定义的复杂性。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请注意，已终止的流程实例是历史数据，因此无法直接重新激活。你需要根据业务需求进行相应的处理。使用&lt;code&gt;HistoryService&lt;/code&gt;接口可以提供有关已终止流程实例的详细信息，但不能直接操作它们。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
      <category term="Flowable" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/Flowable/"/>
    
    
      <category term="flowable" scheme="http://yoursite.com/tags/flowable/"/>
    
  </entry>
  
  <entry>
    <title>List＜String＞集合转Long[]数组</title>
    <link href="http://yoursite.com/2023/06/13/List%EF%BC%9CString%EF%BC%9E%E9%9B%86%E5%90%88%E8%BD%ACLong-%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2023/06/13/List＜String＞集合转Long-数组/</id>
    <published>2023-06-13T07:54:46.000Z</published>
    <updated>2023-06-13T07:58:35.155Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Long[] item = list.toArray(<span class="keyword">new</span> Long[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p><code>List&lt;String&gt;</code>直接以toArray的方式转换<code>Long数组</code>是错误的，运行后报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayStoreException</span><br></pre></td></tr></table></figure><p>查看<code>java.util.List.toArray(T[])</code>方法，注释中明确写到：</p><blockquote><p><span class="citation" data-cites="throws">@throws</span>ArrayStoreException if the runtime type of the specified array is not asupertype of the runtime type of every element in this list如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型</p></blockquote><p>明显Long类型不是String类型的超类。</p><p>可以通过下面的方式实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">Long[] item = list.stream().map(Long::valueOf).toArray(Long[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>引申：</strong></p><p>如何实现 <code>List&lt;String&gt;</code> 转<code>List&lt;Long&gt;</code> ?</p><p>实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>);</span><br><span class="line">List&lt;Long&gt; longList = stringList.stream().map(Long::valueOf).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr><p><code>java.util.List.toArray(T[])</code> 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an array containing all of the elements in this list in</span></span><br><span class="line"><span class="comment">     * proper sequence (from first to last element); the runtime type of</span></span><br><span class="line"><span class="comment">     * the returned array is that of the specified array.  If the list fits</span></span><br><span class="line"><span class="comment">     * in the specified array, it is returned therein.  Otherwise, a new</span></span><br><span class="line"><span class="comment">     * array is allocated with the runtime type of the specified array and</span></span><br><span class="line"><span class="comment">     * the size of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the list fits in the specified array with room to spare (i.e.,</span></span><br><span class="line"><span class="comment">     * the array has more elements than the list), the element in the array</span></span><br><span class="line"><span class="comment">     * immediately following the end of the list is set to &lt;tt&gt;null&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     * (This is useful in determining the length of the list &lt;i&gt;only&lt;/i&gt; if</span></span><br><span class="line"><span class="comment">     * the caller knows that the list does not contain any null elements.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Like the &#123;<span class="doctag">@link</span> #toArray()&#125; method, this method acts as bridge between</span></span><br><span class="line"><span class="comment">     * array-based and collection-based APIs.  Further, this method allows</span></span><br><span class="line"><span class="comment">     * precise control over the runtime type of the output array, and may,</span></span><br><span class="line"><span class="comment">     * under certain circumstances, be used to save allocation costs.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Suppose &lt;tt&gt;x&lt;/tt&gt; is a list known to contain only strings.</span></span><br><span class="line"><span class="comment">     * The following code can be used to dump the list into a newly</span></span><br><span class="line"><span class="comment">     * allocated array of &lt;tt&gt;String&lt;/tt&gt;:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     String[] y = x.toArray(new String[0]);</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that &lt;tt&gt;toArray(new Object[0])&lt;/tt&gt; is identical in function to</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;toArray()&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a the array into which the elements of this list are to</span></span><br><span class="line"><span class="comment">     *          be stored, if it is big enough; otherwise, a new array of the</span></span><br><span class="line"><span class="comment">     *          same runtime type is allocated for this purpose.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an array containing the elements of this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ArrayStoreException if the runtime type of the specified array</span></span><br><span class="line"><span class="comment">     *         is not a supertype of the runtime type of every element in</span></span><br><span class="line"><span class="comment">     *         this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Long[] item = list.toArray(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Long[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;直接以toArray的方式转换&lt;code&gt;Long数组&lt;/code&gt;是错误的，运行后报错：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayStoreException&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看&lt;code&gt;java.util.List.toArray(T[])&lt;/code&gt;方法，注释中明确写到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;citation&quot; data-cites=&quot;throws&quot;&gt;@throws&lt;/span&gt;
ArrayStoreException if the runtime type of the specified array is not a
supertype of the runtime type of every element in this list
如果指定数组的运行时类型不是此列表中每个元素的运行时类型的超类型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;明显Long类型不是String类型的超类。&lt;/p&gt;
&lt;p&gt;可以通过下面的方式实现&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;String&amp;gt; stringList = Arrays.asList(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Long[] item = list.stream().map(Long::valueOf).toArray(Long[]::&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="List" scheme="http://yoursite.com/tags/List/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
      <category term="Long" scheme="http://yoursite.com/tags/Long/"/>
    
  </entry>
  
  <entry>
    <title>读取jar包中指定资源文件的内容</title>
    <link href="http://yoursite.com/2023/06/12/%E8%AF%BB%E5%8F%96jar%E5%8C%85%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://yoursite.com/2023/06/12/读取jar包中指定资源文件的内容/</id>
    <published>2023-06-12T11:05:13.000Z</published>
    <updated>2023-06-12T11:10:31.549Z</updated>
    
    <content type="html"><![CDATA[<p>背景描述：SpringBoot项目构建打包生成的jar包，在资源文件夹下有个普通txt文件，路径：<code>/templates/content.txt</code></p><h2 id="方式一">方式一：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(ResourceUtils.getURL(<span class="string">"classpath:"</span>).getPath());</span><br><span class="line">File templateFile = <span class="keyword">new</span> File(file, <span class="string">"/templates/content.txt"</span>);</span><br><span class="line">BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer sbf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));</span><br><span class="line">    String tempStr;</span><br><span class="line">    <span class="keyword">while</span> ((tempStr = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sbf.append(tempStr);</span><br><span class="line">    &#125;</span><br><span class="line">    reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sbf.toString();</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方式二">方式二：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">"templates/content.txt"</span>);</span><br><span class="line">BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">StringBuffer sbf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream));</span><br><span class="line">String tempStr;</span><br><span class="line"><span class="keyword">while</span> ((tempStr = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sbf.append(tempStr);</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sbf.toString();</span><br></pre></td></tr></table></figure><p>文件位置示例：</p><img src="/2023/06/12/读取jar包中指定资源文件的内容/resourcesfile.png">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;背景描述：SpringBoot项目构建打包生成的jar包，在资源文件夹下有个普通txt文件，路径：&lt;code&gt;/templates/content.txt&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;方式一&quot;&gt;方式一：&lt;/h2&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;File file = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(ResourceUtils.getURL(&lt;span class=&quot;string&quot;&gt;&quot;classpath:&quot;&lt;/span&gt;).getPath());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;File templateFile = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; File(file, &lt;span class=&quot;string&quot;&gt;&quot;/templates/content.txt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BufferedReader reader = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;StringBuffer sbf = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; StringBuffer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reader = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BufferedReader(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileReader(file));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String tempStr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; ((tempStr = reader.readLine()) != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sbf.append(tempStr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reader.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    e.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;finally&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (reader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            reader.close();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (IOException e1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            e1.printStackTrace();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; sbf.toString();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="jar" scheme="http://yoursite.com/tags/jar/"/>
    
      <category term="File" scheme="http://yoursite.com/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>Convert Image File to Base64 String or Base64 String to Image File in Java</title>
    <link href="http://yoursite.com/2023/06/07/Convert-Image-File-to-Base64-String-or-Base64-String-to-Image-File-in-Java/"/>
    <id>http://yoursite.com/2023/06/07/Convert-Image-File-to-Base64-String-or-Base64-String-to-Image-File-in-Java/</id>
    <published>2023-06-07T10:11:27.000Z</published>
    <updated>2023-06-07T10:29:25.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="add-maven-dependency">Add Maven Dependency</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="image-file-convert-base64-string">Image File Convert Base64String</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] fileContent = FileUtils.readFileToByteArray(<span class="keyword">new</span> File(filePath));</span><br><span class="line">String encodedString = Base64.getEncoder().encodeToString(fileContent);</span><br></pre></td></tr></table></figure><h2 id="base64-string-convert-image-file">Base64 String Convert ImageFile</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] decodedBytes = Base64.getDecoder().decode(encodedString);</span><br><span class="line">FileUtils.writeByteArrayToFile(<span class="keyword">new</span> File(outputFileName), decodedBytes);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;add-maven-dependency&quot;&gt;Add Maven Dependency&lt;/h2&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot项目下实践设计模式之工厂模式</title>
    <link href="http://yoursite.com/2023/04/23/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%8B%E5%AE%9E%E8%B7%B5%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/</id>
    <published>2023-04-23T08:50:50.000Z</published>
    <updated>2023-04-23T08:57:24.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="示例结构红框内的">示例结构（红框内的）</h2><p>工厂模式（Factory Pattern）是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p><p>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过new就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><a id="more"></a><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423161023.png"><h2 id="接口">接口</h2><p><code>com.springcloud.business.service.ICarService</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xbronze</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类">实现类</h2><p><code>com.springcloud.business.service.impl.BusServiceImpl</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"大巴车一般要求时速控制在每小时80公里"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>com.springcloud.business.service.impl.SuperCarServiceImpl</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperCarServiceImpl</span> <span class="keyword">implements</span> <span class="title">ICarService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"超跑的车速轻松能达到每小时200公里"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个工厂注册类">一个工厂注册类</h2><p><code>com.springcloud.business.service.impl.CarServiceContent</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 15:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarServiceContent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, ICarService&gt; carServiceMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ICarService <span class="title">getCarService</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (carServiceMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.carServiceMap.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>项目启动，系统会把<code>ICarService</code>的实现类都注入到<code>carServiceMap</code>，key值为实现类上@Service注解定义的value，如果没有显式的设置value，如示例上所示，那么默认value值为类名（首字母小写）。## Controller类VehicleController</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/vehicle"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IVehicleService vehicleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;type&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">vehicle</span><span class="params">(@PathVariable(<span class="string">"type"</span>)</span> String type)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vehicleService.choose(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口ivehicleservice">接口IVehicleService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 14:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVehicleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">choose</span><span class="params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现类vehicleserviceimpl">实现类VehicleServiceImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springcloud.business.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.ICarService;</span><br><span class="line"><span class="keyword">import</span> com.springcloud.business.service.IVehicleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: xbronze</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2023-04-23 15:17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleServiceImpl</span> <span class="keyword">implements</span> <span class="title">IVehicleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CarServiceContent carServiceContent;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">choose</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        ICarService carService = carServiceContent.getCarService(type);</span><br><span class="line">        <span class="keyword">return</span> carService.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试">测试</h2><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164156.png"><p><br></p><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164134.png"><p><br></p><img src="/2023/04/23/SpringBoot项目下实践设计模式之工厂模式/微信截图_20230423164322.png"><p><br></p><hr><p>完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;示例结构红框内的&quot;&gt;示例结构（红框内的）&lt;/h2&gt;
&lt;p&gt;工厂模式（Factory Pattern）是 Java
中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。&lt;/p&gt;
&lt;p&gt;作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过
new
就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工程模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>单点登录解决方案</title>
    <link href="http://yoursite.com/2023/04/20/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yoursite.com/2023/04/20/单点登录解决方案/</id>
    <published>2023-04-20T01:59:13.000Z</published>
    <updated>2023-04-20T11:12:27.167Z</updated>
    
    <content type="html"><![CDATA[<p>单点登录 (SSO)是一种身份验证过程，在该过程中，用户仅使用一组登录凭据即可访问多个应用程序或网站，这避免了用户分别登录不同应用程序需要输入不同验证信息的麻烦。用户凭据和其他识别信息由称为身份提供者(IdP)的集中式系统存储和管理。身份提供者是一个受信任的系统，可以提供对其他网站和应用程序的访问。基于单点登录(SSO)的身份验证系统通常用于员工需要访问其组织的多个应用程序的企业环境中。</p><a id="more"></a><h1 id="单点登录sso的好处">单点登录SSO的好处</h1><ol type="1"><li>由于 SSO允许用户使用他们自己的登录系统进行身份验证，因此它还允许管理员管理用户帐户并使员工能够在公司使用的多个应用程序中使用它。</li><li>SSO 允许管理员立即控制对所有应用程序的访问，而不是登录 100个不同的用户管理门户来更改用户权限。</li><li>重要的是，SSO还有助于提高安全性。由于只有一个系统保存所有员工信息，因此保护一个地方比保护数百个不同的帐户容易得多，后者可能成为可能的“泄漏”。</li></ol><h1 id="单点登录验证过程示例图">单点登录验证过程示例图</h1><img src="/2023/04/20/单点登录解决方案/sso-for-login.png"><p><br></p><h1 id="saml-2.0-oauth-2.0-openid-connect的对比">SAML 2.0、 OAuth 2.0、OpenID Connect的对比</h1><table><colgroup><col style="width: 25%"><col style="width: 23%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr class="header"><th></th><th>SAML</th><th>OAuth</th><th>OpenID Connect</th></tr></thead><tbody><tr class="odd"><td>Description</td><td>Open standard for authorization and authentication</td><td>Open standard for authorization</td><td>Open standard for authentication</td></tr><tr class="even"><td>Primary user case</td><td>SSO for enterprise applications</td><td>API authorization</td><td>SSO for consumer applications</td></tr><tr class="odd"><td>Data format</td><td>XML</td><td>JSON</td><td>JSON</td></tr></tbody></table><p><br></p><h1 id="saml-2.0-协议">SAML 2.0 协议</h1><p>SAML是唯一同时支持身份验证和授权的标准。SAML通过支持服务提供商和身份提供商端的数据签名和加密，为公司提供更多控制，以保持其SSO登录更安全。因此，如果需要，可以对整个过程的数据进行加密，并且攻击无法对其进行解密，除非他们已经可以访问服务和身份提供者的私钥。</p><img src="/2023/04/20/单点登录解决方案/saml.png"><p><br></p><p>该过程进行如下：</p><ol type="1"><li>用户向服务提供商请求启动 SSO。</li><li>服务提供商创建 base64编码的身份验证请求并将其发送给身份提供商。</li><li>身份提供者接收身份验证请求，对其进行验证，并请求用户进行身份验证（登录）。</li><li>身份提供者发送带有 base64 编码 SAML 响应的用户 XHTML 表单。</li><li>用户向服务提供商发送 SAML 响应。</li><li>服务提供商验证 SAML 响应并将用户重定向到目标资源。</li></ol><h1 id="实施单点登录">实施单点登录</h1><p>大多数情况下，身份验证请求是使用 HTTP-Redirect 或 HTTP-Post绑定发送的，因为数据负载很小。但是，由于 SAML 响应通常太大而无法放入url，因此通常的做法是使用 HTTP-Post 绑定来传输 SAML 响应数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单点登录 (SSO)
是一种身份验证过程，在该过程中，用户仅使用一组登录凭据即可访问多个应用程序或网站，这避免了用户分别登录不同应用程序需要输入不同验证信息的麻烦。用户凭据和其他识别信息由称为身份提供者(IdP)的集中式系统存储和管理。身份提供者是一个受信任的系统，可以提供对其他网站和应用程序的访问。基于单点登录
(SSO)
的身份验证系统通常用于员工需要访问其组织的多个应用程序的企业环境中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="SSO" scheme="http://yoursite.com/tags/SSO/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList去重方式总结</title>
    <link href="http://yoursite.com/2023/04/17/ArrayList%E5%8E%BB%E9%87%8D%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2023/04/17/ArrayList去重方式总结/</id>
    <published>2023-04-17T11:37:05.000Z</published>
    <updated>2023-04-18T10:26:55.375Z</updated>
    
    <content type="html"><![CDATA[<p>我在日常工作中常用Stream方式去重，满足了工作上业务的需求即可，并没有深入了解和尝试其他方式的去重操作，这对于个人的成长是很有局限性的，遂借此机会整理ArrayList的去重方法。</p><a id="more"></a><h2 id="使用迭代器遍历去重">1.使用迭代器遍历去重</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to remove duplicates from an ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">removeDuplicates</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new ArrayList</span></span><br><span class="line">ArrayList&lt;T&gt; newList = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse through the first list</span></span><br><span class="line"><span class="keyword">for</span> (T element : list) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If this element is not present in newList</span></span><br><span class="line"><span class="comment">// then add it</span></span><br><span class="line"><span class="keyword">if</span> (!newList.contains(element)) &#123;</span><br><span class="line"></span><br><span class="line">newList.add(element);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the new list</span></span><br><span class="line"><span class="keyword">return</span> newList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the ArrayList with duplicate values</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays</span><br><span class="line">.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove duplicates</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">newList = removeDuplicates(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 3, 10, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><h2 id="使用linkedhashset">2.使用LinkedHashSet</h2><p>可以将ArrayList转换成不允许值重复的Set集合，因此LinkedHashSet是最好的选择，因为它不允许重复.</p><blockquote><p>HashSet也能实现同样的去重效果，但是HashSet与LinkedHashSet的不同之处在于，LinkedHashSet同时保留了插入顺序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GFG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to remove duplicates from an ArrayList</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ArrayList&lt;T&gt; <span class="title">removeDuplicates</span><span class="params">(ArrayList&lt;T&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new LinkedHashSet</span></span><br><span class="line">Set&lt;T&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the elements to set</span></span><br><span class="line">set.addAll(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the list</span></span><br><span class="line">list.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">// add the elements of set</span></span><br><span class="line"><span class="comment">// with no duplicates to the list</span></span><br><span class="line">list.addAll(set);</span><br><span class="line"></span><br><span class="line"><span class="comment">// return the list</span></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the ArrayList with duplicate values</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays</span><br><span class="line">.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove duplicates</span></span><br><span class="line">ArrayList&lt;Integer&gt;</span><br><span class="line">newList = removeDuplicates(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 10, 3, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><blockquote><p>更简单的方法可以这样写 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(yourList);</span><br><span class="line">yourList.clear();</span><br><span class="line">yourList.addAll(set);</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="使用java-8版本中的stream.distinct方法">3.使用Java8版本中的Stream.distinct()方法</h2><p>distinct()方法根据equals()方法返回的结果返回一个没有重复元素的新Stream，可用于进一步处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java program to remove duplicates from ArrayList</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Program to remove duplicates from a List in Java 8</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GFG</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// input list with duplicates</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">Arrays.asList(<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// Print the Arraylist</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates: "</span></span><br><span class="line">+ list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct a new list from the set constucted from elements</span></span><br><span class="line"><span class="comment">// of the original list</span></span><br><span class="line">List&lt;Integer&gt; newList = list.stream().distinct().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print the ArrayList with duplicates removed</span></span><br><span class="line">System.out.println(<span class="string">"ArrayList with duplicates removed: "</span></span><br><span class="line">+ newList);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList with duplicates: [1, 10, 1, 2, 2, 3, 10, 3, 3, 4, 5, 5]</span><br><span class="line">ArrayList with duplicates removed: [1, 10, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在日常工作中常用Stream方式去重，满足了工作上业务的需求即可，并没有深入了解和尝试其他方式的去重操作，这对于个人的成长是很有局限性的，遂借此机会整理ArrayList的去重方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>总结学习HashMap和HashTable</title>
    <link href="http://yoursite.com/2023/04/14/%E6%80%BB%E7%BB%93%E5%AD%A6%E4%B9%A0HashMap%E5%92%8CHashTable/"/>
    <id>http://yoursite.com/2023/04/14/总结学习HashMap和HashTable/</id>
    <published>2023-04-14T06:20:08.000Z</published>
    <updated>2023-04-17T11:21:34.105Z</updated>
    
    <content type="html"><![CDATA[<p>HashMap 和 Hashtable都用于以键和值的形式存储数据。两者都使用散列技术来存储唯一密钥。但是HashMap和Hashtable类之间也是有许多区别。</p><a id="more"></a><h2 id="hashmap是不同步的即非线程安全hashtable是同步的即线程安全">1.HashMap是不同步的，即非线程安全；Hashtable是同步的，即线程安全。</h2><p>HashMap部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="keyword">this</span>.getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    HashMap.Node e;</span><br><span class="line">    <span class="keyword">return</span> (e = <span class="keyword">this</span>.removeNode(hash(key), key, (Object)<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ? </span><br><span class="line">    <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>HashTable部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Hashtable.Entry e = tab[index]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// put</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(Hashtable.Entry entry = tab[index]; entry != <span class="keyword">null</span>; entry = entry.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.hash == hash &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">                V old = entry.value;</span><br><span class="line">                entry.value = value;</span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.addEntry(hash, key, value, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Hashtable.Entry&lt;?, ?&gt;[] tab = <span class="keyword">this</span>.table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">2147483647</span>) % tab.length;</span><br><span class="line">    Hashtable.Entry&lt;K, V&gt; e = tab[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Hashtable.Entry prev = <span class="keyword">null</span>; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                prev.next = e.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tab[index] = e.next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++<span class="keyword">this</span>.modCount;</span><br><span class="line">            --<span class="keyword">this</span>.count;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="hashmap可以通过collections.synchronizedmapmapk-v-m实现同步hashtable不能实现非同步">2.HashMap可以通过Collections.synchronizedMap(Map&lt;K,V&gt; m)实现同步；Hashtable不能实现非同步。</h2><blockquote><p>虽然HashMap不是线程安全的，但是我们可以通过<code>Collections.synchronizedMap(Map&lt;K, V&gt; m)</code>实现线程安全.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = Collections.synchronizedMap(m);</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">//调用execute()方法创建线程</span></span><br><span class="line">            threadPool.execute(() -&gt; map.put(atomicInteger.incrementAndGet(), </span><br><span class="line">            (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>))</span><br><span class="line">        );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        threadPool.awaitTermination(<span class="number">1000</span>, TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap允许一个空键和多个空值hashtable不允许任何空键和空值">3.HashMap允许一个空键和多个空值；HashTable不允许任何空键和空值</h2><p>从HashTable的源码可以看到，如果key或value是null，会抛出<code>NullPointerException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maps the specified &lt;code&gt;key&lt;/code&gt; to the specified</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;value&lt;/code&gt; in this hashtable. Neither the key nor the</span></span><br><span class="line"><span class="comment"> * value can be &lt;code&gt;null&lt;/code&gt;. &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method</span></span><br><span class="line"><span class="comment"> * with a key that is equal to the original key.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      key     the hashtable key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      value   the value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     the previous value of the specified key in this hashtable,</span></span><br><span class="line"><span class="comment"> *             or &lt;code&gt;null&lt;/code&gt; if it did not have one</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span>  NullPointerException  if the key or value is</span></span><br><span class="line"><span class="comment"> *               &lt;code&gt;null&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     Object#equals(Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     #get(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashmap是jdk-1.2中引入的新类.-hashtable是jdk-1.0中的类">4.HashMap是JDK1.2中引入的新类. Hashtable是JDK 1.0中的类</h2><h2 id="hashmap比hashtable更快.">5.HashMap比Hashtable更快.</h2><h2 id="hashmap由iterator实现遍历.-hashtable由enumerator和iterator实现遍历.">6.HashMap由Iterator实现遍历.Hashtable由Enumerator和Iterator实现遍历.</h2><h2 id="hashmap中的迭代器是快速失败机制.-hashtable是安全失败机制.">7.HashMap中的迭代器是快速失败机制.Hashtable是安全失败机制.</h2><p>HashMap不是线程安全的，在遍历HashMap的内容时，如果有其他线程修改了HashMap的内容，那么将抛出<code>ConcurrentModificationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterators</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>modCount用于记录修改次数，对HashMap的修改都将增加这个值，在迭代器初始化过程中会将modCount传递给expectedModCount。在迭代中就是根据<code>modCount != expectedModCount</code>判断Map是否已被其他线程修改。</p><p>Hashtable是<a href="https://blog.csdn.net/striner/article/details/86375684" target="_blank" rel="noopener">fail-safe安全失败</a>机制</p><p>fail-safe:这种遍历基于容器的一个克隆。因此，对容器内容的修改不影响遍历。java.util.concurrent包下的容器都是安全失败的,可以在多线程下并发使用,并发修改。常见的的使用fail-safe方式遍历的容器有ConcerrentHashMap和CopyOnWriteArrayList等。</p><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModification Exception。</p><p>缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><h2 id="hashmap继承abstractmap类hashtable继承dictionary类.">8.HashMap继承AbstractMap类；Hashtable继承Dictionary类.</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HashMap 和 Hashtable
都用于以键和值的形式存储数据。两者都使用散列技术来存储唯一密钥。但是HashMap和Hashtable
类之间也是有许多区别。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="Hashtable" scheme="http://yoursite.com/tags/Hashtable/"/>
    
  </entry>
  
  <entry>
    <title>程序猿三部曲之白银时代</title>
    <link href="http://yoursite.com/2023/04/04/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E7%99%BD%E9%93%B6%E6%97%B6%E4%BB%A3/"/>
    <id>http://yoursite.com/2023/04/04/程序猿三部曲之白银时代/</id>
    <published>2023-04-04T07:22:38.000Z</published>
    <updated>2023-08-21T07:22:33.696Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某篇<a href="https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ" target="_blank" rel="noopener">公众号文章</a>中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。</p><p>曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。</p><a id="more"></a><h1 id="hashmap和concurrenthashmap有什么区别">1HashMap和ConcurrentHashMap有什么区别？</h1><p>HashMap是传统集合下的类，ConcurrentHashMap是并发集合下的类。除此之外，它们之间还有各种不同之处：</p><ul><li>HashMap本质上是非同步的，即HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</li><li>HashMap性能比较高，因为它是非同步的，任意数量的线程都可以同时访问它。而ConcurrentHashMap性能比较低，因为有时候线程需要在ConcurrentHashMap上等待请求。</li><li>当一个线程正在迭代HashMap时，如果有另外一个线程试图对这个HashMap的元素进行新增或者修改，我们将得到运行时异常ConcurrentModificationException。然而，我们在迭代ConcurrentHashMap时执行任何修改都不会出现任何异常。</li><li>HashMap的key和value可以为null，ConcurrentHashMap不允许，否则会报运行时异常NullPointerException.</li><li>HashMap 是在 JDK 1.2 中引入的，而 ConcurrentHashMap 是由 SUNMicrosystem 在 JDK 1.5 中引入的</li></ul><h1 id="synchronized关键字">2 synchronized关键字</h1><p>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</p><ol type="1"><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</li><li>修饰一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象。</li><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li></ol><p>资料：<a href="https://www.cnblogs.com/weibanggang/p/9470718.html" target="_blank" rel="noopener">Java中Synchronized的用法（简单介绍）</a></p><h1 id="volatile关键字">3 volatile关键字</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoVisibility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> ready;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReaderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ReaderThread().start();</span><br><span class="line">        number = <span class="number">42</span>;</span><br><span class="line">        ready = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。</p><h2 id="volatile原理">3.1 volatile原理</h2><p>Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</p><img src="/2023/04/04/程序猿三部曲之白银时代/cpu_read_memory.png"><p>当对非 volatile变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的CPU cache 中。</p><p>而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPUcache 这一步。</p><h2 id="当一个变量定义为volatile之后将具备两种特性">3.2当一个变量定义为volatile之后，将具备两种特性</h2><ol type="1"><li>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。</li><li>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“loadaddl $0x0,(%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</li></ol><h2 id="volatile-性能">3.3 volatile 性能：</h2><p>volatile的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><p>资料：<a href="https://www.cnblogs.com/zhengbin/p/5654805.html" target="_blank" rel="noopener">Java中Volatile关键字详解</a></p><h1 id="堆和栈的区别堆中存放的是什么栈中存放的是什么">4堆和栈的区别，堆中存放的是什么，栈中存放的是什么？</h1><h2 id="堆空间">4.1 堆空间</h2><p>Java堆空间被Java运行时用来为对象和JRE类分配内存。每当我们创建一个对象时，它总是创建在Heap空间中。垃圾收集在堆内存上运行，以释放没有任何引用的对象所使用的内存。在堆空间中创建的任何对象都具有全局访问权，并且可以从应用程序的任何地方引用。</p><h2 id="栈内存">4.2 栈内存</h2><p>JavaStack内存用于线程的执行。它们包含特定于方法的值，这些值存在时间很短，并引用从该方法引用的堆中其他对象。堆栈内存总是按照后进先出(LIFO)的顺序引用。每当调用一个方法时，就会在堆栈内存中为该方法创建一个新的块，用于保存本地原语值并引用该方法中的其他对象。方法一结束，该块就变为未使用的，并可用于下一个方法。与堆内存相比，堆栈内存大小要小得多。</p><h2 id="栈和堆申请空间后系统的响应">4.3 栈和堆申请空间后系统的响应</h2><ul><li>栈：只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。</li><li>堆：操作系统有一个记录空间内存地址的链表，当系统收到程序的申请时，会遍历链表，寻找第一个空间大于所申请空间的堆节点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序。对于大多数操作系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的对节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入到链表中。</li></ul><h2 id="java-程序中的堆和栈内存">4.4 Java 程序中的堆和栈内存</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// Line 1</span></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">1</span>; <span class="comment">// Line 2</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// Line 3</span></span><br><span class="line">Memory mem = <span class="keyword">new</span> Memory(); <span class="comment">// Line 4</span></span><br><span class="line">mem.foo(obj); <span class="comment">// Line 5</span></span><br><span class="line">&#125; <span class="comment">// Line 9</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Object param)</span> </span>&#123; <span class="comment">// Line 6</span></span><br><span class="line">String str = param.toString(); <span class="comment">//// Line 7</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125; <span class="comment">// Line 8</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图显示了程序运行中堆空间和堆内存的引用，以及它们如何用于存储基元、对象和引用变量。</p><img src="/2023/04/04/程序猿三部曲之白银时代/Java-Heap-Stack-Memory.png"><ol type="1"><li>当我们运行该程序，系统会将所有运行时类加载到堆空间中。当在第一步执行main()方法时，JavaRuntime会创建栈内存以供main()方法线程使用。</li><li>Line 2定义局部变量，它会被创建并存储到main()方法的栈内存中。</li><li>Line 3new了一个Object对象，Object对象会在堆空间创建，而栈内存保存对象的引用obj，同理，Line4也是一样的过程。</li><li>当我们在Line5调用foo()方法时，栈内存会在顶部创建一个块以供foo()方法使用。</li><li>由于Java是按值传递的，因此在Line6处的栈内存块中创建了对Object的新引用。</li><li>在Line7创建一个字符串，它进入堆空间中的字符串池，并在foo()堆空间中为它创建一个引用。</li><li>foo()方法在Line 8终止，此时分配给foo()的堆栈内存块变为空闲。</li><li>在Line9，main()方法终止，为main()方法创建的堆栈内存被销毁。此外，程序在此行结束，因此JavaRuntime释放所有内存并结束程序的执行。</li></ol><h2 id="java堆空间和栈内存的区别">4.5 Java堆空间和栈内存的区别</h2><p>基于上面的解释，我们可以很容易的得出以下Heap和Stack内存的区别。</p><ol type="1"><li>栈内存仅能被一个线程执行，堆空间可以被程序中所有部分使用；</li><li>每当创建一个对象时，它总是存储在堆空间中，栈内存包含对它的引用。栈内存只包含本地原始变量和堆空间中对象的引用变量；</li><li>存储在堆中的对象是全局可访问的，而堆栈内存不能被其他线程访问；</li><li>Memory management in stack is done in LIFO manner whereas it’s morecomplex in Heap memory because it’s used globally. Heap memory isdivided into Young-Generation, Old-Generation etc, more details at <a href="https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java" target="_blank" rel="noopener">JavaGarbage Collection</a>；</li><li>堆栈内存是短暂的，而堆内存从应用程序执行开始到结束都存在；</li><li>我们可以使用JVM的<code>-Xms</code>和<code>-Xmx</code>选项来定义堆内存的启动内存和最大内存。我们可以使用<code>-Xss</code>来定义栈内存大小；</li><li>当堆栈内存已满时，Java 运行时会抛出java.lang.StackOverFlowError，而如果堆内存已满，则会抛出java.lang.OutOfMemoryError: Java Heap Space 错误;</li><li>与堆内存相比，堆栈内存非常小。由于内存分配(LIFO)的简单性，与堆内存相比，堆栈内存非常快。</li></ol><p>资料：<a href="https://www.digitalocean.com/community/tutorials/java-heap-space-vs-stack-memory" target="_blank" rel="noopener">JavaHeap Space vs Stack - Memory Allocation in Java</a></p><h1 id="字符串池">5 字符串池</h1><p>顾名思义，java中的String Pool就是一个存储在Java HeapMemory中的Strings池。我们知道 String 是 java中的一个特殊类，我们可以使用 new 运算符创建 String对象，也可以在双引号中提供值。</p><h2 id="java中的字符串池">5.1 Java中的字符串池</h2><p>下面这张图很清楚的解释了StringPool在java堆空间中是如何维护的，以及当我们使用不同的方式创建String时会发生什么</p><img src="/2023/04/04/程序猿三部曲之白银时代/String-Pool-Java.png"><p>当我们使用双引号创建一个字符串时，它首先在字符串池中寻找具有相同值的字符串，如果找到则返回引用，否则在池中创建一个新的字符串，然后返回引用。但是使用new运算符，我们强制String类在堆空间中创建一个新的String对象。我们可以使用intern() 方法将其放入池中，或者从字符串池中引用另一个具有相同值的 String对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.journaldev.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Java String Pool example</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s2 = <span class="string">"Cat"</span>;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"s1 == s2 :"</span>+(s1==s2));</span><br><span class="line">        System.out.println(<span class="string">"s1 == s3 :"</span>+(s1==s3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 == s2 :true</span><br><span class="line">s1 == s3 :false</span><br></pre></td></tr></table></figure><h2 id="在字符串池中创建了多少字符串对象">5.2在字符串池中创建了多少字符串对象？</h2><p>有时候在java面试中，你会被问到一个关于Stringpool的问题。例如，在下面的语句中创建了多少个字符串对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>首先在堆空间创建一个“Cat”对象，在栈内存创建str，并指向堆空间的“Cat”对象;然后检查堆空间中的字符串池中查看是否存在“Cat”对象，如果存在，则将new出来的“Cat”对象与字符串池中的“Cat”对象联系起来。若不存在，则在字符串池中创建“Cat”对象，并将堆中的“Cat”对象与之关联起来。</p><p>资料：<a href="https://www.digitalocean.com/community/tutorials/what-is-java-string-pool" target="_blank" rel="noopener">Whatis Java String Pool?</a></p><h1 id="io和nio的区别">6. IO和NIO的区别</h1><p>NIO是为了弥补IO操作的不足而诞生的，NIO的特性包括：非阻塞I/O，选择器，缓冲以及管道。其中管道（Channel）、缓冲（Buffer）、选择器（Selector）是NIO的三大主要特征。</p><ul><li><p>管道（Channel）：它就像传统IO中的流，到任何目的地（或来自任何地方）的所有数据都必须通过一个Channel对象。</p></li><li><p>缓存（Buffer）：一个Buffer实际上就是一个容器对象。Java的每一种基本类型都有一种缓冲区类型：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte----ByteBuffer</span><br><span class="line">char----CharBuffer</span><br><span class="line">shotr----ShortBuffer</span><br><span class="line">int----IntBuffer</span><br><span class="line">long----LongBuffer</span><br><span class="line">float----FloatBuffer</span><br><span class="line">double----DoubleBuffer</span><br></pre></td></tr></table></figure><ul><li>选择器（Selector）：用于监听多个管道（Channel）的事件，使用传统的阻塞IO时我们可以方便的知道什么时候可以进行读写，而使用NIO非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器证实为这个需要而诞生的。</li></ul><p>IO和NIO的主要区别：</p><ol type="1"><li>IO是面向流的，NIO是面向快（缓冲区）的。</li></ol><p>IO面向流的操作是一次一个字节的处理数据。一个输入流产生一个字节，一个输出流消耗一个字节，这样的操作就导致了IO对数据的读取和写入效率低下。</p><p>NIO面向块的操作是一次产生或消耗一个数据块。这样按照数据块进行数据处理就明显比按照字节处理数据快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性。总的来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。</p><ol start="2" type="1"><li>IO是阻塞的，NIO是非阻塞的。</li></ol><p>传统的IO中一个线程调用read()或write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再做任何事情。</p><p>而NIO使用的是一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时的线程可以去执行别的任务，不会像IO中的线程那样只能等待响应完。</p><p>虽然从上面可以看出NIO是为了弥补IO读取数据效率慢这个缺点而诞生的，但是NIO也有其自身的缺陷，NIO是面向缓冲区的操作，这样的话就必须考虑一个问题，NIO在对缓冲区的数据进行处理之前必须对缓冲区数据的完整性进行判断，如果数据不完整的话，NIO的读取就不存在任何意义，因此NIO每次数据处理之前都要检测缓冲区数据的完整性。</p><blockquote><p>如果管理的是成千上万个连接，但是这些连接每次只是发送少量的数据，例如我们常用的聊天服务器，这时候选择NIO处理数据可能是个很好的选择;如果是少量连接，而这些连接每次都要发送大量的数据，这时候就应该选择IO对数据进行操作。</p></blockquote><hr><p>未完，待续...</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在某篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公众号文章&lt;/a&gt;中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。&lt;/p&gt;
&lt;p&gt;曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>程序猿三部曲之青铜时代</title>
    <link href="http://yoursite.com/2023/03/14/%E7%A8%8B%E5%BA%8F%E7%8C%BF%E4%B8%89%E9%83%A8%E6%9B%B2%E4%B9%8B%E9%9D%92%E9%93%9C%E6%97%B6%E4%BB%A3/"/>
    <id>http://yoursite.com/2023/03/14/程序猿三部曲之青铜时代/</id>
    <published>2023-03-14T07:49:34.000Z</published>
    <updated>2023-08-28T06:27:20.718Z</updated>
    
    <content type="html"><![CDATA[<p>之前在某篇<a href="https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ" target="_blank" rel="noopener">公众号文章</a>中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。</p><p>曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。</p><a id="more"></a><h1 id="接口和抽象类的关系和区别">1 接口和抽象类的关系和区别</h1><h2 id="理解接口和抽象类">1.1 理解接口和抽象类</h2><p>这个问题之前有了解过，也看过一些文章，但是好长时间不复习，也总是会忘记。因为工作中其实也不会很严谨的按照规则去使用接口和抽象类，总是按照controller、interface、mapper这样的通用格式，实现功能。借此机会，再次学习一下。</p><p>接口关心的是对象可以做什么，抽象类主要是描述对象是什么。定义一个狗狗的抽象类，这个类可以被藏獒继承、也可以被哈士奇、柯基继承，但是不能被人类继承。一个活动的接口，定义一个奔跑的方法，这个接口就不局限于藏獒和人类了，只要对象具有奔跑的能力，就可以实现这个接口，拥有奔跑的能力（方法）。所以在java中，类的单继承多实现就很好理解了。在应用场景中，抽象类用于同类事物，而接口多是可以横跨很多个类。</p><h2 id="接口和抽象类的区别">1.2 接口和抽象类的区别</h2><ol type="1"><li>抽象类则可以包含普通方法，接口中的普通方法默认为抽象方法。</li><li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 publicstatic final 类型的，并且必须赋值，否则通不过编译。</li><li>接口不能包含构造器，抽象类可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li><li>接口里不能包含初始化块，但抽象类里完全可以包含初始化块。</li><li>就是我们所说的单继承多实现了。</li></ol><h2 id="什么时候应该使用接口而不用抽象类">1.3什么时候应该使用接口而不用抽象类</h2><ol type="1"><li>需要实现多态</li><li>要实现的方法(功能)不是当前类族的必要(属性).</li><li>要为不同类族的多个类实现同样的方法(功能).</li></ol><p>参考资料：<a href="https://cloud.tencent.com/developer/article/1677833" target="_blank" rel="noopener">搞了这么多年终于知道接口和抽象类的应用场景了</a></p><h1 id="反射机制和动态代理">2 反射机制和动态代理</h1><h2 id="反射机制">2.1 反射机制</h2><p>反射(Reflection)是Java程序开发语言的特征之一它允许运行中的Java程序获取自身的信息，并且可以操作类或对象的内部属性。通过反射机制，可以在运行时访问Java对象的属性，方法，构造方法等。</p><h3 id="反射的应用场景">2.1.1 反射的应用场景</h3><p>反射的主要应用场景有：</p><ol type="1"><li>开发通用框架 - 反射最重要的用途就是开发各种通用框架。很多框架（比如Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter等），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</li><li>动态代理 -在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</li><li>注解 -注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。如果没有反射机制，注解并不比注释更有用。</li><li>可扩展性功能 -应用程序可以通过使用完全限定名称创建可扩展性对象实例来使用外部的用户定义类。</li></ol><h3 id="反射的缺点">2.1.2 反射的缺点</h3><ol type="1"><li>性能开销 - 由于反射涉及动态解析的类型，因此无法执行某些 Java虚拟机优化。因此，反射操作的性能要比非反射操作的性能要差，应该在性能敏感的应用程序中频繁调用的代码段中避免。</li><li>破坏封装性 -反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li><li>内部曝光 -由于反射允许代码执行在非反射代码中非法的操作，例如访问私有字段和方法，所以反射的使用可能会导致意想不到的副作用，这可能会导致代码功能失常并可能破坏可移植性。反射代码打破了抽象，因此可能会随着平台的升级而改变行为。</li></ol><h2 id="动态代理">2.2 动态代理</h2><p>代理模式是为了提供额外或不同的操作，而插入的用来替代“实际”对象的对象，这些操作涉及到与“实际”对象的通信，因此代理通常充当中间人角色。Java的动态代理比代理的思想更前进了一步，它可以动态地创建并代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的策略。</p><p>学习Spring的时候，我们知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，它利用的是反射机制，依赖注入就不用多说了，而对于Spring的核心AOP来说，使用了动态代理，其实底层也是反射。我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。</p><p>参考资料： <a href="https://zhuanlan.zhihu.com/p/60805342" target="_blank" rel="noopener">深入理解Java反射和动态代理</a><a href="https://www.cnblogs.com/aspirant/p/9036805.html" target="_blank" rel="noopener">深入理解Java反射+动态代理</a></p><h1 id="项目中事务的使用">3 项目中事务的使用</h1><p>事务的四个特征：原子性、一致性、隔离性、持久性</p><h2 id="事务传播属性">3.1 事务传播属性</h2><ol type="1"><li>Propagation.REQUIRED:支持当前事务,如果当前没有事务,则新建一个事务,默认使用这种,也是最常见的.</li><li>Propagation.SUPPORTS:支持当前事务,如果没有事务,就以非事务的方式执行.</li><li>Propagation.MANDATORY:支持当前事务,如果没有事务,就抛出异常.</li><li>Propagation.REQUIRES_NEW:新建事务,如果当前存在事务,就把当前事务挂起.</li><li>Propagation.NOT_SUPPORTED:以非事务的方式执行操作,如果当前存在事务,就把当前事务挂起.</li><li>Propagation.NEVER:以非事务的方式执行,如果当前存在事务,则会抛出异常.</li><li>Propagation.NESTED:如果当前事务存在，则执行嵌套事务，否则执行类似REQUIRED的操作.</li></ol><p>SpringBoot注解@Transactional实现事务</p><blockquote><p>一个事务内部，没有隔离的概念的。打个比方：在同一个事务里，先对一条记录执行更新操作，然后再执行查询操作，整个事务没有完全的执行完毕，那么在执行查询的时候，虽然事务还没结束，但是查询的仍然是最新的更新的值，如果是另外一个事务查询这条记录，因为第一个事务并没有完全结束，所以查询到的就是老值。</p></blockquote><h2 id="transactional事务不生效的场景">3.2 <span class="citation" data-cites="Transactional事务不生效的场景">@Transactional事务不生效的场景</span></h2><p>spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效。</p><ol type="1"><li><p>private、final、static方法，事务不生效，入口方法必须是public,spring的AOP特性决定的，spring认为private自己用的方法应该自己控制，不应该用事务切进去</p></li><li><p>Spring的事务管理默认只对出现运行期异常(java.lang.RuntimeException及其子类)进行回滚（至于为什么spring要这么设计：因为spring认为Checked的异常属于业务的，coder需要给出解决方案而不应该直接扔该框架）</p></li><li><p>同类调用不生效（service方法中调用本类中的另一个方法，事务没有生效）：</p></li><li><p>如果使用的是rollbakfor的默认，已检查的异常（所有派生自Error和RuntimeException的类,都是未检查异常.其余的是已检查异常，比如nullPointException是未检查的，IllegalAccessException是已检查的）不回滚,可设为rollbackFor={Exception.class}</p></li><li><p>最好不要把@Trasaction注解到接口上：在接口上使用 <span class="citation" data-cites="Transactional">@Transactional</span>注解，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</p></li><li><p>确认你的类是否被代理了（因为spring的事务实现原理为AOP，只有通过代理对象调用方法才能被拦截，事务才能生效）。</p></li><li><p>确保你的业务和事务入口在同一个线程里，否则事务也是不生效的。</p></li></ol><p>参考资料： <a href="https://juejin.cn/post/6844904186870497287" target="_blank" rel="noopener">《java开发事务篇】之一分钟搞懂事务、使用方式和特定场景》</a></p><h1 id="spring-ioc和aop">4 Spring IoC和AOP</h1><h2 id="ioc-控制反转">4.1 IoC 控制反转</h2><p>IoC 是 Inversion of Control的简写，译为“控制反转”，它不是一门技术，而是一种设计思想，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。Spring通过 IoC容器来管理所有Java对象的实例化和初始化，控制对象与对象之间的依赖关系。我们将由IoC 容器管理的 Java 对象称为 Spring Bean，它与使用关键字 new 创建的 Java对象没有任何区别。</p><p>在传统的 Java应用中，一个类想要调用另一个类中的属性或方法，通常会先在其代码中通过 newObject()的方式将后者的对象创建出来，然后才能实现属性或方法的调用。为了方便理解和描述，我们可以将前者称为“调用者”，将后者称为“被调用者”。也就是说，调用者掌握着被调用者对象创建的控制权。</p><p>但在 Spring 应用中，Java 对象创建的控制权是掌握在 IoC容器手里的，其大致步骤如下。</p><ol type="1"><li>开发人员通过 XML 配置文件、注解、Java 配置类等方式，对 Java对象进行定义，例如在 XML 配置文件中使用 &lt;bean&gt; 标签、在 Java类上使用 <span class="citation" data-cites="Component">@Component</span>注解等。</li><li>Spring 启动时，IoC容器会自动根据对象定义，将这些对象创建并管理起来。这些被 IoC容器创建并管理的对象被称为 Spring Bean。</li><li>当我们想要使用某个 Bean 时，可以直接从 IoC 容器中获取（例如通过ApplicationContext 的 getBean() 方法），而不需要手动通过代码（例如 newObejct() 的方式）创建。</li></ol><p><em>IoC带来的最大改变不是代码层面的，而是从思想层面上发生了“主从换位”的改变。原本调用者是主动的一方，它想要使用什么资源就会主动出击，自己创建；但在Spring 应用中，IoC容器掌握着主动权，调用者则变成了被动的一方，被动的等待 IoC容器创建它所需要的对象（Bean）。</em></p><p>这个过程在职责层面发生了控制权的反转，把原本调用者通过代码实现的对象的创建，反转给IoC 容器来帮忙实现，因此我们将这个过程称为 Spring 的“控制反转”。</p><blockquote><p>依赖注入（Denpendency Injection，简写为 DI）是 Martin Fowler 在 2004年在对“控制反转”进行解释时提出的。Martin Fowler认为“控制反转”一词很晦涩，无法让人很直接的理解“到底是哪里反转了”，因此他建议使用“依赖注入”来代替“控制反转”。控制反转核心思想就是由Spring负责对象的创建。在对象创建过程中，Spring会自动根据依赖关系，将它依赖的对象注入到当前对象中，这就是所谓的“依赖注入”。</p><p>依赖注入本质上是 Spring Bean属性注入的一种，只不过这个属性是一个对象属性而已。</p></blockquote><p>参考资料：<a href="http://c.biancheng.net/spring/inversion-control.html" target="_blank" rel="noopener">SpringIoC（控制反转）</a></p><h2 id="aop-面向切面编程">4.2 AOP 面向切面编程</h2><p>AOP保证在不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。</p><h1 id="在实际工作中怎样对sql进行调优">5在实际工作中怎样对SQL进行调优</h1><h2 id="防止索引失效">5.1 防止索引失效</h2><p>索引会提升数据的查询效率，但是会降低“增删改”的效率。尽管如此，索引还是很划算的，因为我们大多数的操作就是查询，查询对于程序的性能影响是很大的。索引分为单值索引、唯一索引、复合索引。</p><ul><li>在MySQL中不建议使用leftjoin，即使on过滤条件列索引，一些情况也不会走索引，导致大量的数据行被扫描，SQL性能变得很差；</li><li>使用 <code>!=</code> 或者<code>&lt;&gt;</code>会导致索引失效，进而会全表搜索，所以如果数据量大的话，谨慎使用；</li><li>类型不一致也将导致索引失效，比如age的类型是varchar类型，那么查询的时候如果where条件设置age=12，那么索引就会失效，但是有一种情况不会使索引失效，如果age的类型是int，查询条件age传的是varchar类型的值，是可以走索引的，因为MySQL内部做了隐式类型转换。</li><li>索引列作为函数的入参，会导致索引失效；</li><li>如果索引对列进行了四则运算（+，-，*，/，!)，都会使索引失效；</li><li>OR导致索引失效，例如where user = 'zhangsan' or age =11。但是也不是所有的OR都使索引失效，如果OR连接的是同一个字段，那么索引不会失效；</li><li>模糊查询导致索引失效；</li><li>NOT IN、 NOT EXISTS这两种用法都不走索引，但是IN还是走索引的；</li><li>IS NULL不走索引，IS NOT NULL走索引。</li></ul><blockquote><p>在设计字段时，如果字段没有要求‘没有值的情况下一定要设置为NULL’，那么建议设置为空字符串。</p></blockquote><h2 id="select检查">5.2 SELECT检查</h2><ul><li>尽量不使用<code>select *</code>，需要什么字段就取什么字段；</li><li>SQL语句的SELECT后面使用自定义函数，那么SQL查询结果返回多少行，那么UDF函数就会被调用多少次，非常影响性能；</li><li>如果SELECT出现text类型的字段，就会消耗大量的网络和IO宽带，由于返回的内容过大，超过max_allowed_packet设置会导致程序报错，需要评估谨慎使用。</li><li><code>gorup_concat</code>是一个字符串聚合函数，会影响SQL的响应时间，如果返回的值过大超过了max_allowed_packet设置会导致程序报错。</li><li>在select后面有子查询的情况称为内联子查询，SQL返回多少行，子查询就需要执行过多少次，严重影响SQL性能。</li></ul><h2 id="limit">5.3 LIMIT</h2><ul><li>当查询我们知道只会有一条结果或者我们只需要一条结果的时候，加上limit1可以增加性能，因为mysql数据库引擎会在找到一条数据后停止检索，而不是往后查找下一条符合条件的数据。</li><li>慎用LIMITm,n分页查询，越往后面翻页，即m值越大的情况下SQL的耗时会越长。</li></ul><h1 id="redis是如何实现高可用的">6 Redis是如何实现高可用的？</h1><p>Redis实现高可用的手段主要有以下四种：</p><ol type="1"><li>数据持久化：保证了数据不丢失；</li><li>Redis主从同步：让Redis从单机变成了多机。它有两种模式：主从模式和从从模式，但当主节点出现问题时，需要人工手动恢复系统；</li><li>Redis哨兵模式：用来监控 Redis主从模式，并提供了自动容灾恢复的功能。</li><li>Redis集群：除了可以提供主从和哨兵的功能之外，还提供了多个主从节点的集群功能，这样就可以把数据均匀的存储各个主机主节点上，实现了系统的横向扩展，大大提高了Redis 的并发处理能力。</li></ol><h2 id="数据持久化">6.1 数据持久化</h2><p>数据持久化保证了系统在发生宕机或者重启之后数据不会丢失，增加了系统的可靠性和减少了系统不可用的时间（省去了手动恢复数据的过程）；</p><p>在 Redis 4.0之前数据持久化方式有两种：<code>AOF</code>方式和<code>RDB</code>方式，在Redis 4.0 推出了<code>混合持久化</code>的功能。</p><ul><li><p>RDB（RedisDataBase，快照恢复）是将某一个时刻的内存数据，以二进制的方式写入磁盘。RDB默认的保存文件为dump.rdb，优点是以二进制存储的，因此占用的空间更小、数据存储更紧凑，并且与AOF 相比，RDB 具备更快的重启恢复能力，但有数据丢失的风险。</p></li><li><p>AOF（Append-OnlyFile，只追加文件）是指将所有的操作命令，以文本的形式追加到文件中。AOF默认的保存文件为appendonly.aof，它的优点是存储频率更高，因此丢失数据的风险就越低，并且AOF并不是以二进制存储的，所以可读性更高。缺点是占用空间大，重启之后的数据恢复速度比较慢。</p></li><li><p>Redis 混合持久化的存储模式指的是 Redis 可以使用 RDB + AOF两种格式来进行数据持久化，开始的数据以 RDB的格式进行存储，因此只会占用少量的空间，之后的命令会以 AOF的方式进行数据追加，这样就可以减低数据丢失的风险，同时可以提高数据恢复的速度这样就可以做到扬长避短物尽其用了。</p></li></ul><p>可以使用<code>config get aof-use-rdb-preamble</code>的命令来查询Redis 混合持久化的功能是否开启</p><h2 id="redis主从同步">6.2 Redis主从同步</h2><p>主从同步是 Redis多机运行中最基础的功能，有一主节点和多个从节点，多个节点组成一个 Redis集群，在这个集群主节点用来进行数据的操作，其他从节点用于同步主节点的内容，并且提供给客户端进行数据查询。</p><p>Redis 主从同步分为：主从模式和从从模式。</p><ul><li>主从模式是一个主节点和多个一级从节点</li><li>从从模式是在主从模式的基础上，一级从节点下面还可以拥有更多的从节点</li></ul><p>使用主从模式就可以实现数据的读写分离，把写操作的请求分发到主节点上，把其他的读操作请求分发到从节点上，这样就减轻了Redis 主节点的运行压力，并且提高了 Redis的整体运行速度。不但如此使用主从模式还实现了 Redis的高可用，当主服务器宕机之后，可以很迅速的把从节点提升为主节点，为 Redis服务器的宕机恢复节省了宝贵的时间。并且主从复制还降低了数据丢失的风险，因为数据是完整拷贝在多台服务器上的，当一个服务器磁盘坏掉之后，可以从其他服务器拿到完整的备份数据。</p><h2 id="哨兵模式">6.3 哨兵模式</h2><p>Redis 主从同步有那么多的优点，但是有一个致命的缺点，就是当 Redis的主节点宕机之后，必须人工介入手动恢复，如果半夜突然发生主节点宕机的问题，此时如果等待人工去处理就会很慢，这个时候我们就需要用到Redis 的哨兵模式了。</p><p>Redis 哨兵模式就是用来监视 Redis 主从服务器的，当 Redis的主从服务器发生故障之后，Redis 哨兵提供了自动容灾修复的功能。</p><p>Redis哨兵模块存储在Redis应用根目录下的 src/redis-sentinel目录下，我们可以使用命令<code>./src/redis-sentinel sentinel.conf</code>来启动哨兵功能。</p><p>工作原理:</p><p>哨兵的工作原理是每个哨兵会以每秒钟 1次的频率，向已知的主服务器和从服务器，发送一个 PING命令。如果最后一次有效回复 PING命令的时间，超过了配置的最大下线时间（Down-After-Milliseconds）时，默认是30s，那么这个实例会被哨兵标记为主观下线。如果一个主服务器被标记为主观下线，那么正在监视这个主服务器的所有哨兵节点，要以每秒1 次的频率确认主服务器是否进入了主观下线的状态。如果有足够数量（quorum配置值）的哨兵证实该主服务器为主观下线，那么这个主服务器被标记为客观下线。此时所有的哨兵会按照规则（协商）自动选出新的主节点服务器，并自动完成主服务器的自动切换功能，而整个过程都是无须人工干预的。</p><h2 id="redis-集群">6.4 Redis 集群</h2><p>Redis集群也就是 Redis Cluster，它是 Redis 3.0 版本推出的 Redis集群方案，有多个主节点同时每个主节点有多个从节点，将数据分布在不同的主服务器上，以此来降低系统对单主节点的依赖，并且可以大大提高Redis 服务的读写性能。Redis 集群除了拥有主从模式 +哨兵模式的所有功能之外，还提供了多个主从节点的集群功能，实现了真正意义上的分布式集群服务。</p><p>Redis 集群可以实现数据分片服务，也就是说在 Redis 集群中有 16384个槽位用来存储所有的数据，当我们有 N 个主节点时，可以把 16384个槽位平均分配到 N 台主服务器上。当有键值存储时，Redis 会使用 crc16算法进行 hash 得到一个整数值，然后用这个整数值对 16384进行取模来得到具体槽位，再把此键值存储在对应的服务器上，读取操作也是同样的道理，这样我们就实现了数据分片的功能。</p><p>参考资料：<a href="https://www.cnblogs.com/liaowenhui/p/14618144.html" target="_blank" rel="noopener">Redis是如何实现高可用的？</a></p><h1 id="利用jdk不依赖外部工具实现一个简单的缓存机制">7利用JDK，不依赖外部工具，实现一个简单的缓存机制</h1><h2 id="存储集合的选择">7.1 存储集合的选择</h2><p>实现本地缓存，存储容器肯定是 key/value 形式的数据结构，在 Java中，也就是我们常用的 Map 集合。Map 中有HashMap、Hashtable、ConcurrentHashMap几种供我们选择，如果不考虑高并发情况下数据安全问题，我们可以选择HashMap，如果考虑高并发情况下数据安全问题，我们可以选择Hashtable、ConcurrentHashMap 中的一种集合，但是我们优先选择ConcurrentHashMap，因为 ConcurrentHashMap 的性能比 Hashtable 要好。</p><h2 id="过期缓存处理">7.2 过期缓存处理</h2><p>因为缓存直接存储在内存中，如果我们不处理过期缓存，内存将被大量无效缓存占用，这不是我们想要的，所以我们需要清理这些失效的缓存。过期缓存处理可以参考Redis 的策略来实现，Redis 采用的是定期删除 + 懒惰淘汰策略。</p><h3 id="定期删除策略">7.2.1 定期删除策略</h3><p>定期删除策略是每隔一段时间检测已过期的缓存，并且降之删除。这个策略的优点是能够确保过期的缓存都会被删除。同时也存在着缺点，过期的缓存不一定能够及时的被删除，这跟我们设置的定时频率有关系，另一个缺点是如果缓存数据较多时，每次检测也会给cup 带来不小的压力。</p><h3 id="懒惰淘汰策略">7.2.2 懒惰淘汰策略</h3><p>懒惰淘汰策略是在使用缓存时，先判断缓存是否过期，如果过期将它删除，并且返回空。这个策略的优点是只有在查找的时候，才判断是否过期，对CUP影响较。同时这种策略有致命的缺点，当存入了大量的缓存，这些缓存都没有被使用并且已过期，都将成为无效缓存，这些无效的缓存将占用你大量的内存空间，最后导致服务器内存溢出。</p><p>我们简单的了解了一下 Redis的两种过期缓存处理策略，每种策略都存在自己的优缺点。所以我们在使用过程中，可以将两种策略组合起来，结合效果还是非常理想的。</p><h2 id="缓存淘汰策略">7.3 缓存淘汰策略</h2><p>缓存淘汰跟过期缓存处理要区别开来，缓存淘汰是指当我们的缓存个数达到我们指定的缓存个数时，毕竟我们的内存不是无限的。如果我们需要继续添加缓存的话，我们就需要在现有的缓存中根据某种策略淘汰一些缓存，给新添加的缓存腾出位置，下面一起来认识几种常用的缓存淘汰策略。</p><h3 id="先进先出策略">7.3.1 先进先出策略</h3><p>最先进入缓存的数据在缓存空间不够的情况下会被优先被清除掉，以腾出新的空间接受新的数据。该策略主要比较缓存元素的创建时间。在一些对数据实效性要求比较高的场景下，可考虑选择该类策略，优先保障最新数据可用。</p><h3 id="最少使用策略">7.3.2 最少使用策略</h3><p>无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略主要比较元素的hitCount（命中次数），在保证高频数据有效性场景下，可选择这类策略。</p><h3 id="最近最少使用策略">7.3.3 最近最少使用策略</h3><p>无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。该策略主要比较缓存最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</p><h3 id="随机淘汰策略">7.3.4 随机淘汰策略</h3><p>无论是否过期，随机淘汰某个缓存，如果对缓存数据没有任何要求，可以考虑使用该策略。</p><h3 id="不淘汰策略">7.3.5 不淘汰策略</h3><p>当缓存达到指定值之后，不淘汰任何缓存，而是不能新增缓存，直到有缓存淘汰时，才能继续添加缓存。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/82074159" target="_blank" rel="noopener">实现 Java本地缓存，该从这几点开始</a></p><h1 id="exception和error的区别">8 Exception和Error的区别</h1><p>Exception和Error都继承了Throwable类。</p><p>Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理；Error是指在正常情况下，不大可能出现的情况，绝大部分的 Error都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态</p><img src="/2023/03/14/程序猿三部曲之青铜时代/ErrorVsException.png"><p>Exception 又分为cheked exception（检查异常） 和 uncheckedexception（不检查异常）。</p><p>checked exception 指的是在源代码里必须处理的异常。例如：</p><ul><li>IOException</li></ul><p>unchecked exception指的是不用在源代码里处理，为运行时异常。例如：</p><ul><li>NullPointerException</li><li>ClassCastException</li></ul><p>绝大数的Error会导致程序处于非正常状态。例如：</p><ul><li>NoClassDefFoundError</li><li>OutOfMemoryError</li><li>StackOverflowError</li></ul><p>参考资料： <a href="https://cloud.tencent.com/developer/article/1851847" target="_blank" rel="noopener">《谈谈你对Exception和 Error的理解》</a> <a href="https://cloud.tencent.com/developer/article/2177926" target="_blank" rel="noopener">《Exception和Error有什么区别吗》</a></p><h1 id="设计模式">9 设计模式</h1><p>23种经典设计模式，设计模式的具逻辑和实现，可移步<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a>了解。</p><h2 id="创建型模式">9.1 创建型模式</h2><p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p><ul><li>工厂模式（Factory Pattern）</li><li>抽象工厂模式（Abstract Factory Pattern）</li><li>单例模式（Singleton Pattern）</li><li>建造者模式（Builder Pattern）</li><li>原型模式（Prototype Pattern）</li></ul><h2 id="结构型模式">9.2 结构型模式</h2><p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><ul><li>适配器模式（Adapter Pattern）</li><li>桥接模式（Bridge Pattern）</li><li>过滤器模式（Filter、Criteria Pattern）</li><li>组合模式（Composite Pattern）</li><li>装饰器模式（Decorator Pattern）</li><li>外观模式（Facade Pattern）</li><li>享元模式（Flyweight Pattern）</li><li>代理模式（Proxy Pattern）</li></ul><h2 id="行为型模式">9.3 行为型模式</h2><p>这些设计模式特别关注对象之间的通信。</p><ul><li>责任链模式（Chain of Responsibility Pattern）</li><li>命令模式（Command Pattern）</li><li>解释器模式（Interpreter Pattern）</li><li>迭代器模式（Iterator Pattern）</li><li>中介者模式（Mediator Pattern）</li><li>备忘录模式（Memento Pattern）</li><li>观察者模式（Observer Pattern）</li><li>状态模式（State Pattern）</li><li>空对象模式（Null Object Pattern）</li><li>策略模式（Strategy Pattern）</li><li>模板模式（Template Pattern）</li><li>访问者模式（Visitor Pattern）</li></ul><h2 id="j2ee-模式">9.4 J2EE 模式</h2><p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p><ul><li>MVC 模式（MVC Pattern）</li><li>业务代表模式（Business Delegate Pattern）</li><li>组合实体模式（Composite Entity Pattern）</li><li>数据访问对象模式（Data Access Object Pattern）</li><li>前端控制器模式（Front Controller Pattern）</li><li>拦截过滤器模式（Intercepting Filter Pattern）</li><li>服务定位器模式（Service Locator Pattern）</li><li>传输对象模式（Transfer Object Pattern）</li></ul><h1 id="一个线程调用两次start方法会发生什么简单谈谈线程的几种状态">10一个线程调用两次start()方法会发生什么？简单谈谈线程的几种状态</h1><h2 id="调用两次start">10.1 调用两次start()</h2><p>Java的线程是不允许启动两次的，第二次调用必然会抛岀<code>IllegalThreadStateEXception</code>，这是一种运行时异常，多次调用start 被认为是编程错误。</p><h2 id="线程的生命周期线程状态">10.2 线程的生命周期（线程状态）</h2><ul><li>新建（NEW），表示线程被创建出来还没真正启动的状态，可以认为它是个Java内部状态。</li><li>就绪（RUNNABLE），表示该线程已经在WM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它cpu片段，在就绪队列里面排队。</li><li>运行（Running）在其他一些分析中，会额外区分一种状态 RUNNING，但是从Java API的角度，并不能表示出来。</li><li>阻塞（BLOCKED），这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待Monitorlock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li><li>等待（WAITING），表示正在等待其他线程釆取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。</li><li>计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本，如下面示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> wait（<span class="keyword">long</span> timeout） <span class="keyword">throws</span> InterruptedException；</span><br></pre></td></tr></table></figure><ul><li>终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡在第二次调用start()方法的时候，线程可能处于终止或者其他（非NEW）状态，但是不论如何，都是不可以再次启动的。</li></ul><img src="/2023/03/14/程序猿三部曲之青铜时代/thread_status.png"><p>参考资料：<a href="https://cloud.tencent.com/developer/article/1625433" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1625433</a></p><h1 id="rocketmq">11 RocketMQ</h1><p>RocketMQ是一个纯Java、分布式队列模型的消息中间件，具有高可用、高可靠、高实时、低延迟的特点。</p><h2 id="消息中间件的通用功能">11.1 消息中间件的通用功能</h2><ol type="1"><li>业务解耦：这也是发布订阅的消息模型。生产者发送指令到MQ中，然后下游订阅这类指令的消费者会收到这个指令执行相应的逻辑，整个过程与具体业务无关，抽象成了一个发送指令，存储指令，消费指令的过程。</li><li>前端削峰：前端发起的请求在短时间内太多后端无法处理，可以堆积在MQ中，后端按照一定的顺序处理，秒杀系统就是这么实现的。</li></ol><h2 id="rocketmq的特点">11.2 RocketMQ的特点</h2><ol type="1"><li>亿级消息的堆积能力：单个队列中的百万级消息的累积容量。</li><li>高可用性</li><li>高可靠性</li><li>支持分布式事务消息</li><li>支持顺序消息：消息在Broker中是采用队列的FIFO模式存储的，也就是发送是顺序的，只要保证消费的顺序性即可。</li><li>支持消息过滤：建议采用消费者业务端的tag过滤。</li><li>支持定时消息和延迟消息</li></ol><h2 id="rocketmq消息模型">11.3 RocketMQ消息模型</h2><h3 id="message">Message</h3><p>就是要传输的消息，一个消息必须有一个主题，一条消息也可以有一个可选的Tag（标签）和额外的键值对，可以用来设置一个业务的key，便于开发中在broker服务端查找消息。</p><h3 id="topic">Topic</h3><p>主题，是消息的第一级类型，每条消息都有一个主题，就像信件邮寄的地址一样。主题就是我们具体的业务，比如一个电商系统可以有订单消息，商品消息，采购消息，交易消息等。Topic和生产者和消费者的关系非常松散，生产者和Topic可以是1对多，多对1或者多对多，消费者也是这样。</p><h3 id="tag">Tag</h3><p>标签，是消息的第二级类型，可以作为某一类业务下面的二级业务区分，它的主要用途是在消费端的消息过滤。比如采购消息分为采购创建消息，采购审核消息，采购推送消息，采购入库消息，采购作废消息等，这些消息是同一Topic和不同的Tag，当消费端只需要采购入库消息时就可以用Tag来实现过滤，不是采购入库消息的tag就不处理。</p><h3 id="group">Group</h3><p>组，可分为ProducerGroup生产者组合ConsumerGroup消费者组，一个组可以订阅多个Topic。一般来说，某一类相同业务的生产者和消费者放在一个组里。</p><h3 id="message-queue">Message Queue</h3><p>消息队列，一个Topic可以划分成多个消息队列。Topic只是个逻辑上的概念，消息队列是消息的物理管理单位，当发送消息的时候，Broker会轮询包含该Topic的所有消息队列，然后将消息发出去。有了消息队列，可以使得消息的存储可以分布式集群化，具有了水平的扩展能力。</p><h3 id="offset">offset</h3><p>是指消息队列中的offset，可以认为就是下标，消息队列可看做数组。offset是javalong，64位，理论上100年不会溢出，所以可以认为消息队列是一个长度无限的数据结构。</p><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/521109575" target="_blank" rel="noopener">RocketMq面试题精选</a></p><h1 id="rocketmq和其他消息中间件的区别">12RocketMQ和其他消息中间件的区别</h1><img src="/2023/03/14/程序猿三部曲之青铜时代/diff_mq.png"><h1 id="序列化和反序列化">13 序列化和反序列化</h1><h2 id="什么是序列化和反序列化">13.1 什么是序列化和反序列化？</h2><p>序列化：就是将对象转化成字节序列的过程。</p><p>反序列化：就是将字节序列转化成对象的过程。</p><p>对象序列化成的字节序列会包含对象的类型信息、对象的数据等，说白了就是包含了描述这个对象的所有信息，能根据这些信息“复刻”出一个和原来一模一样的对象。</p><h2 id="为什么要序列化和反序列化">13.2 为什么要序列化和反序列化？</h2><ol type="1"><li>持久化：对象是存储在JVM中的堆区的，但是如果JVM停止运行了，对象也不存在了。序列化可以将对象转化成字节序列，可以写进硬盘文件中实现持久化。在新开启的JVM中可以读取字节序列进行反序列化成对象。</li><li>网络传输：网络直接传输数据，但是无法直接传输对象，可在传输前序列化，传输完成后反序列化成对象。所以所有可在网络上传输的对象都必须是可序列化的。</li></ol><h2 id="实现序列化和反序列化的方法">13.3 实现序列化和反序列化的方法</h2><p>Java为我们提供了对象序列化的机制，规定了要实现序列化对象的类要满足的条件和实现方法。</p><ol type="1"><li>对于要序列化对象的类要去实现Serializable接口或者Externalizable接口。</li><li>实现方法：JDK提供的ObjectOutputStream和ObjectInputStream来实现序列化和反序列化。</li></ol><h2 id="serialversionuid的作用">13.4 serialVersionUID的作用</h2><p>先讲述下序列化的过程：在进行序列化时，会把当前类的serialVersionUID写入到字节序列中（也会写入序列化的文件中），在反序列化时会将字节流中的serialVersionUID同本地对象中的serialVersionUID进行对比，一致的话进行反序列化，不一致则失败报错（报InvalidCastException异常）</p><p>serialVersionUID的生成有三种方式（private static final longserialVersionUID= XXXL ）：</p><ol type="1"><li>显式声明：默认的1L</li><li>显式声明：根据包名、类名、继承关系、非私有的方法和属性以及参数、返回值等诸多因素计算出的64位的hash值</li><li>隐式声明：未显式的声明serialVersionUID时java序列化机制会根据Class自动生成一个serialVersionUID（最好不要这样，因为如果Class发生变化，自动生成的serialVersionUID可能会随之发生变化，导致匹配不上）</li></ol><blockquote><p>序列化类增加属性时，最好不要修改serialVersionUID，避免反序列化失败</p></blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/316200445" target="_blank" rel="noopener">一文搞懂序列化与反序列化</a></p><h1 id="dubbo和springcloud核心组件feignribbinhystrix对比">14Dubbo和SpringCloud核心组件Feign、Ribbin、Hystrix对比</h1><h2 id="协议">14.1 协议</h2><p>Dubbo：支持多传输协议：Dubbo、Rmi、http，可灵活配置。</p><p>Feign：基于http传输协议，短连接，性能比Dubbo低。</p><h2 id="与springcloud集成">14.2 与SpringCloud集成</h2><p>Dubbo：在早期Dubbo是与Spring Cloud 集成有一些脱落,但是在Spring CloudAlibaba 出现后，spring-cloud-starter-dubbo 与Spring Cloud完美集成</p><p>Feign：Spring Cloud 最早支持的RPC框架，兼容性好</p><h2 id="负载均衡">14.3 负载均衡</h2><p>Dubbo内置了如下负载均衡算法，用户可直接配置使用：</p><table><colgroup><col style="width: 29%"><col style="width: 22%"><col style="width: 47%"></colgroup><thead><tr class="header"><th>算法</th><th>特性</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>RandomLandBalance</td><td>加权随机</td><td>默认算法，默认权重相同</td></tr><tr class="even"><td>RoundRobinLoadBalance</td><td>加权轮询</td><td>借鉴与Nginx的平滑加权轮询算法，默认权重相同</td></tr><tr class="odd"><td>LeastActiveLoadBalance</td><td>最少活跃优先+加权随机</td><td>背后是能者多劳的思想</td></tr><tr class="even"><td>ShortestResponseLoadBalance</td><td>最短响应优先+加权随机</td><td>更加关注响应速度</td></tr><tr class="odd"><td>ConsistentHashLoadBalance</td><td>一致性Hash</td><td>确定的入参，确定的提供者，适用于有状态的请求</td></tr></tbody></table><p>同时支持服务端负载均衡和客户端负载均衡配置，灵活度非常高</p><p>Fegin自身是没有负载均衡能力的，之前默认使用Ribbon作为负载均衡的组件，但是Netfix已经不再维护。新版本的SpringCloud已经将Ribbon替换成Spring Cloud LoadBalancer,Ribbon是客户端级别的负载均衡，不像dubbo支持客户端和服务端双向配置</p><h2 id="容错机制">14.4 容错机制</h2><h3 id="dubbo支持多种容错策略">Dubbo支持多种容错策略：</h3><ol type="1"><li>FailoverCluste：失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过retries="2" 来设置重试次数(不含第一次)。默认容错机制</li><li>FailfastCluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li>FailsafeCluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li>ForkingCluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过forks="2" 来设置最大并行数。</li><li>BroadcastCluster：广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ol><h3 id="feign">Feign</h3><p>Feign默认使用NetfixHystrix作为服务熔断的组件。Hystix提供了服务降级，服务熔断，依赖隔离，监控（HystrixDashboard）等功能。 目前 Hystrix已经处于维护（maintenance）状态，不再继续开发，这个消息是Netfix在2018年对外宣布的。HystrixGitHub页面上也说明了该项目目前处于维护模式</p><blockquote><p>在使用dubbo后续的熔断降级也还可以使用Alibaba Sentinel</p></blockquote><h2 id="迁移">14.5 迁移</h2><h3 id="dubbo">Dubbo</h3><p>dubbo为了提供对RestTemplate和OpenFeign客户端端的支持，在Dubbo SpringCloud提供了@DubboTransported注解，使客户端无需额外处理即可兼容RestTemplate和OpenFeign的调用，换而言之在不调整Feign 接口以及 RestTemplate URL 的前提下，可以实现无缝迁移比如在客户端使用OpenFeign调用duboo服务，只需要添加如下注解如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"order"</span>)</span><br><span class="line"><span class="meta">@DubboTransported</span>(protocol = <span class="string">"dubbo"</span>)</span><br></pre></td></tr></table></figure><p>使用RestTemplate或OpenFeign调用Dubbo服务会经历以下过程：</p><ol type="1"><li>根据服务名得到注册中心的Dubbo服务DubboMetadataService。</li><li>使用DubboMetadataService里提供的getServiceRestMetadata方法获取要使用的Dubbo服务和对应的Rest元数据。</li><li>基于Dubbo服务和Rest元数据构造GenericService。</li><li>服务调用过程中使用GenericService发起泛化调用。</li></ol><h3 id="feign-1">Feign</h3><p>没有提供对dubbo无缝迁移的支持</p><p>参考资料：<a href="https://juejin.cn/post/7042686801877663752" target="_blank" rel="noopener">SpringCloud RPC(Feign VS Dubbo)多维度对比选型</a></p><h1 id="线程的创建方式">15 线程的创建方式</h1><h2 id="继承thread类">15.1 继承Thread类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadObject().start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadObject</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"current thread name is :"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现runnable接口">15.2 实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnableObject());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableObject</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"current thread name is :"</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现callable接口">15.3 实现Callable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//执行Callable方式，需要FutureTask实现，用于接收运算结果</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> CallableObject());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取线程执行完毕后的返回值</span></span><br><span class="line">            Integer sum = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">"sum is :"</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Callable泛型定义返回值的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableObject</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            Integer sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于线程池创建">15.4 基于线程池创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++) &#123;</span><br><span class="line">            <span class="comment">//调用execute()方法创建线程</span></span><br><span class="line">            <span class="comment">//采用匿名内部类的方法，创建Runnable对象，并重写run()方法</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hashset和linkedhashset的区别">16.HashSet和LinkedHashSet的区别</h1><p>HashSet和LinkedHashSet都是Java集合框架中的Set接口的实现类，它们主要区别在于维护元素的顺序方式不同。</p><p>HashSet是基于哈希表实现的，它不保证元素的顺序，因此它的迭代顺序是不确定的。HashSet的优点是它的插入和查询操作的时间复杂度都是O(1)，因此它适用于需要快速查找元素的场景。</p><p>LinkedHashSet是基于哈希表和链表实现的，它维护了元素的插入顺序，因此它的迭代顺序是按照元素插入的顺序进行的。</p><p>LinkedHashSet的优点是它在保证快速查找元素的同时，还能保证元素的顺序，因此它适用于需要按照插入顺序遍历元素的场景。</p><h1 id="基本数据类型和引用数据类型的区别">17.基本数据类型和引用数据类型的区别</h1><img src="/2023/03/14/程序猿三部曲之青铜时代/base_data_type.png"><p>特点：</p><p>一、从概念方面来说</p><p>基本数据类型:变量名指向具体的数值引用数据类型:变量名指向存数据对象的内存地址,即变量名指向hash值</p><p>二、从内存构建方面来说</p><p>基本数据类型:变量在声明之后java就会立刻分配给他内存空间</p><p>引用数据类型:它以特殊的方式(类似C指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</p><p>三、从使用方面来说</p><p>基本数据类型:使用时需要赋具体值,判断时使用“==”号</p><p>引用数据类型:使用时可以赋null,判断时使用equals方法</p><p>来源<a href="https://www.cnblogs.com/sunli0205/p/5226716.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunli0205/p/5226716.html</a></p><h1 id="面向对象编程">18.面向对象编程</h1><h2 id="四大特性">18.1 四大特性</h2><h3 id="封装">18.1.1 封装</h3><p>也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h3 id="抽象">18.1.2 抽象</h3><p>抽象是封装的扩展，它使用包含数据和代码的类和对象来向用户隐藏程序的内部细节。这是通过在用户和更复杂的源代码之间创建一个抽象层来完成的，这有助于保护源代码中存储的敏感信息。</p><blockquote><p>封装关注的是如何隐藏内部实现细节，而抽象关注的是如何简化复杂的实现。在实践中，封装和抽象通常是同时使用的，它们共同提供了面向对象编程的强大功能。</p></blockquote><h3 id="继承">18.1.3 继承</h3><p>所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p><h3 id="多态">18.1.4 多态</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h2 id="五大原则">18.2 五大原则</h2><h3 id="单一功能原则">18.2.1 单一功能原则</h3><p>“对象应该仅具有一种单一功能”的概念。</p><h3 id="开闭原则">18.2.2 开闭原则</h3><p>“软件应该是对于扩展开放的，但是对于修改封闭的”的概念。</p><h3 id="里氏替换原则">18.2.3 里氏替换原则</h3><p>“程序中的对象应该是可以在不改变程序正确性的前提下被它的子类所替换的”的概念。(参考契约式设计。)</p><h3 id="接口隔离原则">18.2.4 接口隔离原则</h3><p>“多个特定客户端接口要好于一个宽泛用途的接口”的概念。</p><h3 id="依赖反转原则">18.2.5 依赖反转原则</h3><p>一个方法应该遵从“依赖于抽象而不是一个实例”的概念。</p><hr><p>未完，待续...</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在某篇&lt;a href=&quot;https://mp.weixin.qq.com/s/CfBwk0dttd1eb2PvOvGvuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;公众号文章&lt;/a&gt;中，看到工资10K、15K、20K的Java程序员应该掌握的技术。大致对应着初、中、高级开发人员，所以我打算针对这三个阶段，写三篇文章，一边学习，一边总结。&lt;/p&gt;
&lt;p&gt;曾经读过王小波的时代三部曲，分别是《青铜时代》、《白银时代》、《黄金时代》，遂借用来类比程序员的三个阶段。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
      <category term="线程" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Ioc和AOP" scheme="http://yoursite.com/tags/Ioc%E5%92%8CAOP/"/>
    
      <category term="反射" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%B0%84/"/>
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="Dubbo" scheme="http://yoursite.com/tags/Dubbo/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="序列化" scheme="http://yoursite.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList.retainAll()方法解析</title>
    <link href="http://yoursite.com/2023/03/09/ArrayList-retainAll-%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2023/03/09/ArrayList-retainAll-方法解析/</id>
    <published>2023-03-09T05:57:09.000Z</published>
    <updated>2023-03-10T08:40:08.263Z</updated>
    
    <content type="html"><![CDATA[<p>在工作中，用java.util.ArrayList.retainAll(Collection&lt;?&gt;)方法判断两个list集合是否有交集（两个list是否有相同的元素）。如果两个集合有相同元素，那么retainAll返回true。但是如果两个集合的元素完全相同，返回的结果却是false,而如果两个list集合的元素都不一样，retainAll却返回true。这是怎么回事呢？</p><a id="more"></a><p>先来看看<code>ArrayList.retainAll(Collection&lt;?&gt;)</code>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retains only the elements in this list that are contained in the</span></span><br><span class="line"><span class="comment"> * specified collection.  In other words, removes from this list all</span></span><br><span class="line"><span class="comment"> * of its elements that are not contained in the specified collection.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c collection containing elements to be retained in this list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if the class of an element of this list</span></span><br><span class="line"><span class="comment"> *         is incompatible with the specified collection</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if this list contains a null element and the</span></span><br><span class="line"><span class="comment"> *         specified collection does not permit null elements</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;),</span></span><br><span class="line"><span class="comment"> *         or if the specified collection is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Collection#contains(Object)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>retainAll注释的第一句已经基本交代了方法的功能</p><blockquote><p>Retains only the elements in this list that are contained in thespecified collection. In other words, removes from this list all of itselements that are not contained in the specified collection.</p><p>仅保留此列表中包含在指定集合中的元素。换句话说，从此列表中删除未包含在指定集合中的所有元素。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line"><span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">elementData[w++] = elementData[r];</span><br></pre></td></tr></table></figure><p>遍历此列表 <code>elementData</code> 中的元素，判断是否与<code>c</code>集合有相同元素，把相同的元素覆盖在此列表的第一个地址上，以此类推。以<code>w</code>记录相同元素的个数。</p><p>回到刚开始的问题上，为什么两个集合的元素都一样，结果返回 false，两个集合元素都不一样，结果返回 true 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    modCount += size - w;</span><br><span class="line">    size = w;</span><br><span class="line">    modified = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个集合的元素完全一样，<code>w == size</code>，这样会跳过判断，直接返回modified 的初始值 false;如果两个集合的元素都不一样，<code>w != size</code>满足条件，modified被赋值为true，返回结果即为true。</p><p>所以单纯用ArrayList.retainAll()方法，根据返回值true/false,判断两个集合是否有相同元素，是不准确的。</p><p>可以使用另一个方法<code>java.util.Collections.disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code>，两个指定collection中没有相同的元素，则返回true。如果其中一个集合为null，则抛出NullPointerException。</p><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if the two specified collections have no</span></span><br><span class="line"><span class="comment"> * elements in common.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Care must be exercised if this method is used on collections that</span></span><br><span class="line"><span class="comment"> * do not comply with the general contract for &#123;<span class="doctag">@code</span> Collection&#125;.</span></span><br><span class="line"><span class="comment"> * Implementations may elect to iterate over either collection and test</span></span><br><span class="line"><span class="comment"> * for containment in the other collection (or to perform any equivalent</span></span><br><span class="line"><span class="comment"> * computation).  If either collection uses a nonstandard equality test</span></span><br><span class="line"><span class="comment"> * (as does a &#123;<span class="doctag">@link</span> SortedSet&#125; whose ordering is not &lt;em&gt;compatible with</span></span><br><span class="line"><span class="comment"> * equals&lt;/em&gt;, or the key set of an &#123;<span class="doctag">@link</span> IdentityHashMap&#125;), both</span></span><br><span class="line"><span class="comment"> * collections must use the same nonstandard equality test, or the</span></span><br><span class="line"><span class="comment"> * result of this method is undefined.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Care must also be exercised when using collections that have</span></span><br><span class="line"><span class="comment"> * restrictions on the elements that they may contain. Collection</span></span><br><span class="line"><span class="comment"> * implementations are allowed to throw exceptions for any operation</span></span><br><span class="line"><span class="comment"> * involving elements they deem ineligible. For absolute safety the</span></span><br><span class="line"><span class="comment"> * specified collections should contain only elements which are</span></span><br><span class="line"><span class="comment"> * eligible elements for both collections.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that it is permissible to pass the same collection in both</span></span><br><span class="line"><span class="comment"> * parameters, in which case the method will return &#123;<span class="doctag">@code</span> true&#125; if and</span></span><br><span class="line"><span class="comment"> * only if the collection is empty.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c1 a collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c2 a collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the two specified collections have no</span></span><br><span class="line"><span class="comment"> * elements in common.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if either collection is &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if one collection contains a &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment"> * element and &#123;<span class="doctag">@code</span> null&#125; is not an eligible element for the other collection.</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ClassCastException if one collection contains an element that is</span></span><br><span class="line"><span class="comment"> * of a type which is ineligible for the other collection.</span></span><br><span class="line"><span class="comment"> * (&lt;a href="Collection.html#optional-restrictions"&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">disjoint</span><span class="params">(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The collection to be used for contains(). Preference is given to</span></span><br><span class="line">    <span class="comment">// the collection who's contains() has lower O() complexity.</span></span><br><span class="line">    Collection&lt;?&gt; contains = c2;</span><br><span class="line">    <span class="comment">// The collection to be iterated. If the collections' contains() impl</span></span><br><span class="line">    <span class="comment">// are of different O() complexity, the collection with slower</span></span><br><span class="line">    <span class="comment">// contains() will be used for iteration. For collections who's</span></span><br><span class="line">    <span class="comment">// contains() are of the same complexity then best performance is</span></span><br><span class="line">    <span class="comment">// achieved by iterating the smaller collection.</span></span><br><span class="line">    Collection&lt;?&gt; iterate = c1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Performance optimization cases. The heuristics:</span></span><br><span class="line">    <span class="comment">//   1. Generally iterate over c1.</span></span><br><span class="line">    <span class="comment">//   2. If c1 is a Set then iterate over c2.</span></span><br><span class="line">    <span class="comment">//   3. If either collection is empty then result is always true.</span></span><br><span class="line">    <span class="comment">//   4. Iterate over the smaller Collection.</span></span><br><span class="line">    <span class="keyword">if</span> (c1 <span class="keyword">instanceof</span> Set) &#123;</span><br><span class="line">        <span class="comment">// Use c1 for contains as a Set's contains() is expected to perform</span></span><br><span class="line">        <span class="comment">// better than O(N/2)</span></span><br><span class="line">        iterate = c2;</span><br><span class="line">        contains = c1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(c2 <span class="keyword">instanceof</span> Set)) &#123;</span><br><span class="line">        <span class="comment">// Both are mere Collections. Iterate over smaller collection.</span></span><br><span class="line">        <span class="comment">// Example: If c1 contains 3 elements and c2 contains 50 elements and</span></span><br><span class="line">        <span class="comment">// assuming contains() requires ceiling(N/2) comparisons then</span></span><br><span class="line">        <span class="comment">// checking for all c1 elements in c2 would require 75 comparisons</span></span><br><span class="line">        <span class="comment">// (3 * ceiling(50/2)) vs. checking all c2 elements in c1 requiring</span></span><br><span class="line">        <span class="comment">// 100 comparisons (50 * ceiling(3/2)).</span></span><br><span class="line">        <span class="keyword">int</span> c1size = c1.size();</span><br><span class="line">        <span class="keyword">int</span> c2size = c2.size();</span><br><span class="line">        <span class="keyword">if</span> (c1size == <span class="number">0</span> || c2size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// At least one collection is empty. Nothing will match.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c1size &gt; c2size) &#123;</span><br><span class="line">            iterate = c2;</span><br><span class="line">            contains = c1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Object e : iterate) &#123;</span><br><span class="line">        <span class="keyword">if</span> (contains.contains(e)) &#123;</span><br><span class="line">           <span class="comment">// Found a common element. Collections are not disjoint.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No common elements were found.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在工作中，用java.util.ArrayList.retainAll(Collection&amp;lt;?&amp;gt;)方法判断两个list集合是否有交集（两个list是否有相同的元素）。如果两个集合有相同元素，那么retainAll返回true。但是如果两个集合的元素完全相同，返回的结果却是false,而如果两个list集合的元素都不一样，retainAll却返回true。
这是怎么回事呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码人生" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
      <category term="retainAll()" scheme="http://yoursite.com/tags/retainAll/"/>
    
  </entry>
  
</feed>
